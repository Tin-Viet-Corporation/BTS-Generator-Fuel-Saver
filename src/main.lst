CCS PCH C Compiler, Version 5.109, 43599               20-Thg2-23 20:59

               Filename:   D:\Tin Viet Telecom Corp\BTS-Generator-Fuel-Saver\src\main.lst

               ROM used:   6496 bytes (10%)
                           Largest free fragment is 58204
               RAM used:   126 (3%) at main() level
                           303 (8%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 30

*
0000:  GOTO   15F8
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   01FA
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include "C:\Program Files (x86)\PICC\Devices\18f26k20.h"
.................... //////////// Standard Header file for the PIC18F26K20 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F26K20
00AE:  CLRF   FF7
00B0:  ADDLW  BE
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  RETURN 0
00BE:  DATA 00,00
00C0:  DATA 54,47
00C2:  DATA 20,54
00C4:  DATA 52,49
00C6:  DATA 20,48
00C8:  DATA 4F,41
00CA:  DATA 4E,20
00CC:  DATA 4D,50
00CE:  DATA 44,00
00D0:  DATA 50,48
00D2:  DATA 55,54
00D4:  DATA 3A,20
00D6:  DATA 25,30
00D8:  DATA 31,75
00DA:  DATA 00,00
00DC:  DATA 54,47
00DE:  DATA 20,43
00E0:  DATA 48,41
00E2:  DATA 59,20
00E4:  DATA 4C,49
00E6:  DATA 45,4E
00E8:  DATA 20,54
00EA:  DATA 55,43
00EC:  DATA 00,00
00EE:  DATA 47,49
00F0:  DATA 4F,3A
00F2:  DATA 20,25
00F4:  DATA 30,31
00F6:  DATA 75,00
00F8:  DATA 54,47
00FA:  DATA 20,54
00FC:  DATA 41,4D
00FE:  DATA 20,44
0100:  DATA 55,4E
0102:  DATA 47,20
0104:  DATA 4D,50
0106:  DATA 44,00
0108:  DATA 50,48
010A:  DATA 55,54
010C:  DATA 3A,20
010E:  DATA 25,30
0110:  DATA 31,75
0112:  DATA 00,00
0114:  DATA 4B,49
0116:  DATA 45,4D
0118:  DATA 20,54
011A:  DATA 52,41
011C:  DATA 20,41
011E:  DATA 43,00
0120:  DATA 47,49
0122:  DATA 41,59
0124:  DATA 3A,20
0126:  DATA 25,30
0128:  DATA 31,75
012A:  DATA 00,00
012C:  DATA 44,2E
012E:  DATA 41,50
0130:  DATA 20,41
0132:  DATA 43,20
0134:  DATA 42,54
0136:  DATA 48,55
0138:  DATA 4F,4E
013A:  DATA 47,00
013C:  DATA 4D,50
013E:  DATA 44,20
0140:  DATA 4C,4F
0142:  DATA 49,00
0144:  DATA 4D,50
0146:  DATA 44,20
0148:  DATA 54,4F
014A:  DATA 54,00
014C:  DATA 43,48
014E:  DATA 41,59
0150:  DATA 20,4D
0152:  DATA 50,44
0154:  DATA 00,00
0156:  DATA 4C,41
0158:  DATA 4E,3A
015A:  DATA 20,25
015C:  DATA 30,31
015E:  DATA 75,00
0160:  DATA 4D,50
0162:  DATA 44,20
0164:  DATA 4C,4F
0166:  DATA 49,00
0168:  DATA 50,48
016A:  DATA 55,54
016C:  DATA 3A,20
016E:  DATA 3C,25
0170:  DATA 30,31
0172:  DATA 75,3E
0174:  DATA 00,00
0176:  DATA 47,49
0178:  DATA 4F,3A
017A:  DATA 20,3C
017C:  DATA 25,30
017E:  DATA 31,75
0180:  DATA 3E,00
0182:  DATA 50,48
0184:  DATA 55,54
0186:  DATA 3A,20
0188:  DATA 3C,25
018A:  DATA 30,31
018C:  DATA 75,3E
018E:  DATA 00,00
0190:  DATA 47,49
0192:  DATA 41,59
0194:  DATA 3A,20
0196:  DATA 3C,25
0198:  DATA 30,31
019A:  DATA 75,3E
019C:  DATA 00,00
019E:  DATA 47,49
01A0:  DATA 41,59
01A2:  DATA 3A,20
01A4:  DATA 3C,25
01A6:  DATA 30,31
01A8:  DATA 75,3E
01AA:  DATA 00,00
01AC:  DATA 4C,41
01AE:  DATA 4E,3A
01B0:  DATA 20,3C
01B2:  DATA 25,30
01B4:  DATA 31,75
01B6:  DATA 3E,00
01B8:  DATA 20,20
01BA:  DATA 20,20
01BC:  DATA 20,20
01BE:  DATA 20,20
01C0:  DATA 20,20
01C2:  DATA 20,20
01C4:  DATA 20,20
01C6:  DATA 20,20
01C8:  DATA 20,00
01CA:  DATA 20,20
01CC:  DATA 3C,59
01CE:  DATA 45,53
01D0:  DATA 20,7C
01D2:  DATA 7C,20
01D4:  DATA 4E,4F
01D6:  DATA 3E,00
01D8:  DATA 4C,6F
01DA:  DATA 61,64
01DC:  DATA 69,6E
01DE:  DATA 67,20
01E0:  DATA 00,00
01E2:  DATA 2E,20
01E4:  DATA 20,00
01E6:  DATA 2E,2E
01E8:  DATA 20,00
01EA:  DATA 2E,2E
01EC:  DATA 2E,00
01EE:  DATA 20,2E
01F0:  DATA 2E,00
01F2:  DATA 20,20
01F4:  DATA 2E,00
01F6:  DATA 20,20
01F8:  DATA 20,00
*
032E:  ADDWF  FE8,W
0330:  CLRF   FF7
0332:  RLCF   FF7,F
0334:  ADDLW  49
0336:  MOVWF  FF6
0338:  MOVLW  03
033A:  ADDWFC FF7,F
033C:  TBLRD*-
033E:  MOVF   FF5,W
0340:  MOVWF  FFA
0342:  TBLRD*
0344:  MOVF   FF5,W
0346:  MOVWF  FF9
0348:  DATA 84,02
034A:  DATA 8C,02
034C:  DATA 8E,02
034E:  DATA A2,02
0350:  DATA C2,02
0352:  DATA EA,02
*
066C:  TBLRD*+
066E:  MOVF   FF5,F
0670:  BZ    068A
0672:  MOVFF  FF6,12A
0676:  MOVFF  FF7,12B
067A:  MOVFF  FF5,12C
067E:  RCALL  065C
0680:  MOVFF  12A,FF6
0684:  MOVFF  12B,FF7
0688:  BRA    066C
068A:  RETURN 0
068C:  MOVF   FEF,F
068E:  BZ    06AE
0690:  MOVFF  FEA,12B
0694:  MOVFF  FE9,12A
0698:  MOVFF  FEF,12C
069C:  RCALL  065C
069E:  MOVFF  12B,FEA
06A2:  MOVFF  12A,FE9
06A6:  INCF   FE9,F
06A8:  BTFSC  FD8.2
06AA:  INCF   FEA,F
06AC:  BRA    068C
06AE:  RETURN 0
*
0760:  ADDWF  FE8,W
0762:  CLRF   FF7
0764:  RLCF   FF7,F
0766:  ADDLW  7B
0768:  MOVWF  FF6
076A:  MOVLW  07
076C:  ADDWFC FF7,F
076E:  TBLRD*-
0770:  MOVF   FF5,W
0772:  MOVWF  FFA
0774:  TBLRD*
0776:  MOVF   FF5,W
0778:  MOVWF  FF9
077A:  DATA 02,07
077C:  DATA 0E,07
077E:  DATA 1A,07
0780:  DATA 26,07
0782:  DATA 32,07
0784:  DATA 3E,07
0786:  TBLRD*+
0788:  MOVFF  FF6,12A
078C:  MOVFF  FF7,12B
0790:  MOVFF  FF5,12C
0794:  RCALL  065C
0796:  MOVFF  12A,FF6
079A:  MOVFF  12B,FF7
079E:  MOVLB  1
07A0:  DECFSZ x29,F
07A2:  BRA    07A6
07A4:  BRA    07AA
07A6:  MOVLB  0
07A8:  BRA    0786
07AA:  MOVLB  0
07AC:  RETURN 0
07AE:  MOVLB  1
07B0:  MOVF   x2C,W
07B2:  CLRF   01
07B4:  SUBWF  x2B,W
07B6:  BC    07BE
07B8:  MOVFF  12B,00
07BC:  BRA    07D6
07BE:  CLRF   00
07C0:  MOVLW  08
07C2:  MOVWF  x2D
07C4:  RLCF   x2B,F
07C6:  RLCF   00,F
07C8:  MOVF   x2C,W
07CA:  SUBWF  00,W
07CC:  BTFSC  FD8.0
07CE:  MOVWF  00
07D0:  RLCF   01,F
07D2:  DECFSZ x2D,F
07D4:  BRA    07C4
07D6:  MOVLB  0
07D8:  RETURN 0
07DA:  MOVF   01,W
07DC:  MOVFF  129,12B
07E0:  MOVLW  64
07E2:  MOVLB  1
07E4:  MOVWF  x2C
07E6:  MOVLB  0
07E8:  RCALL  07AE
07EA:  MOVFF  00,129
07EE:  MOVF   01,W
07F0:  MOVLW  30
07F2:  BNZ   0804
07F4:  MOVLB  1
07F6:  BTFSS  x2A.1
07F8:  BRA    0818
07FA:  BTFSC  x2A.3
07FC:  BRA    0818
07FE:  BTFSC  x2A.4
0800:  MOVLW  20
0802:  BRA    080C
0804:  MOVLB  1
0806:  BCF    x2A.3
0808:  BCF    x2A.4
080A:  BSF    x2A.0
080C:  ADDWF  01,F
080E:  MOVFF  01,12C
0812:  MOVLB  0
0814:  RCALL  065C
0816:  MOVLB  1
0818:  MOVFF  129,12B
081C:  MOVLW  0A
081E:  MOVWF  x2C
0820:  MOVLB  0
0822:  RCALL  07AE
0824:  MOVFF  00,129
0828:  MOVF   01,W
082A:  MOVLW  30
082C:  BNZ   083E
082E:  MOVLB  1
0830:  BTFSC  x2A.3
0832:  BRA    0848
0834:  BTFSS  x2A.0
0836:  BRA    0848
0838:  BTFSC  x2A.4
083A:  MOVLW  20
083C:  MOVLB  0
083E:  ADDWF  01,F
0840:  MOVFF  01,12C
0844:  RCALL  065C
0846:  MOVLB  1
0848:  MOVLW  30
084A:  ADDWF  x29,F
084C:  MOVFF  129,12C
0850:  MOVLB  0
0852:  RCALL  065C
0854:  RETURN 0
*
0AAE:  ADDWF  FE8,W
0AB0:  CLRF   FF7
0AB2:  RLCF   FF7,F
0AB4:  ADDLW  C9
0AB6:  MOVWF  FF6
0AB8:  MOVLW  0A
0ABA:  ADDWFC FF7,F
0ABC:  TBLRD*-
0ABE:  MOVF   FF5,W
0AC0:  MOVWF  FFA
0AC2:  TBLRD*
0AC4:  MOVF   FF5,W
0AC6:  MOVWF  FF9
0AC8:  DATA 68,08
0ACA:  DATA 6C,08
0ACC:  DATA BE,08
0ACE:  DATA 10,09
0AD0:  DATA 62,09
0AD2:  DATA B4,09
0AD4:  DATA 24,0A
0AD6:  DATA 76,0A
*
0F3A:  ADDWF  FE8,W
0F3C:  CLRF   FF7
0F3E:  RLCF   FF7,F
0F40:  ADDLW  55
0F42:  MOVWF  FF6
0F44:  MOVLW  0F
0F46:  ADDWFC FF7,F
0F48:  TBLRD*-
0F4A:  MOVF   FF5,W
0F4C:  MOVWF  FFA
0F4E:  TBLRD*
0F50:  MOVF   FF5,W
0F52:  MOVWF  FF9
0F54:  DATA 88,0E
0F56:  DATA 8A,0E
0F58:  DATA D8,0E
0F5A:  DATA E6,0E
0F5C:  DATA F4,0E
0F5E:  DATA 02,0F
0F60:  DATA 10,0F
0F62:  DATA 1E,0F
0F64:  DATA 2C,0F
*
1014:  ADDWF  FE8,W
1016:  CLRF   FF7
1018:  RLCF   FF7,F
101A:  ADDLW  2F
101C:  MOVWF  FF6
101E:  MOVLW  10
1020:  ADDWFC FF7,F
1022:  TBLRD*-
1024:  MOVF   FF5,W
1026:  MOVWF  FFA
1028:  TBLRD*
102A:  MOVF   FF5,W
102C:  MOVWF  FF9
102E:  DATA 72,0F
1030:  DATA 74,0F
1032:  DATA C4,0F
1034:  DATA CE,0F
1036:  DATA D8,0F
1038:  DATA E2,0F
103A:  DATA F0,0F
103C:  DATA FE,0F
103E:  DATA 0C,10
*
159A:  ADDWF  FE8,W
159C:  CLRF   FF7
159E:  RLCF   FF7,F
15A0:  ADDLW  B5
15A2:  MOVWF  FF6
15A4:  MOVLW  15
15A6:  ADDWFC FF7,F
15A8:  TBLRD*-
15AA:  MOVF   FF5,W
15AC:  MOVWF  FFA
15AE:  TBLRD*
15B0:  MOVF   FF5,W
15B2:  MOVWF  FF9
15B4:  DATA 28,13
15B6:  DATA 36,13
15B8:  DATA 44,13
15BA:  DATA 52,13
15BC:  DATA 54,13
15BE:  DATA 62,13
15C0:  DATA 7C,13
15C2:  DATA 7C,13
15C4:  DATA 7C,13
15C6:  DATA 7C,13
15C8:  DATA 70,13
15CA:  ADDWF  FE8,W
15CC:  CLRF   FF7
15CE:  RLCF   FF7,F
15D0:  ADDLW  E5
15D2:  MOVWF  FF6
15D4:  MOVLW  15
15D6:  ADDWFC FF7,F
15D8:  TBLRD*-
15DA:  MOVF   FF5,W
15DC:  MOVWF  FFA
15DE:  TBLRD*
15E0:  MOVF   FF5,W
15E2:  MOVWF  FF9
15E4:  DATA 1C,13
15E6:  DATA 7E,13
15E8:  DATA 9E,13
15EA:  DATA E6,13
15EC:  DATA 2E,14
15EE:  DATA 76,14
15F0:  DATA BE,14
15F2:  DATA 06,15
15F4:  DATA 4E,15
15F6:  DATA 5C,15
*
18E4:  ADDWF  FE8,W
18E6:  CLRF   FF7
18E8:  RLCF   FF7,F
18EA:  ADDLW  FF
18EC:  MOVWF  FF6
18EE:  MOVLW  18
18F0:  ADDWFC FF7,F
18F2:  TBLRD*-
18F4:  MOVF   FF5,W
18F6:  MOVWF  FFA
18F8:  TBLRD*
18FA:  MOVF   FF5,W
18FC:  MOVWF  FF9
18FE:  DATA 20,17
1900:  DATA 22,17
1902:  DATA 30,17
1904:  DATA 3E,17
1906:  DATA AA,17
1908:  DATA D4,17
190A:  DATA F6,17
190C:  DATA F6,17
190E:  DATA F6,17
1910:  DATA F6,17
1912:  DATA E2,17
1914:  ADDWF  FE8,W
1916:  CLRF   FF7
1918:  RLCF   FF7,F
191A:  ADDLW  2F
191C:  MOVWF  FF6
191E:  MOVLW  19
1920:  ADDWFC FF7,F
1922:  TBLRD*-
1924:  MOVF   FF5,W
1926:  MOVWF  FFA
1928:  TBLRD*
192A:  MOVF   FF5,W
192C:  MOVWF  FF9
192E:  DATA 0E,17
1930:  DATA F8,17
1932:  DATA FA,17
1934:  DATA FC,17
1936:  DATA FE,17
1938:  DATA 00,18
193A:  DATA 02,18
193C:  DATA 04,18
193E:  DATA 06,18
1940:  DATA 08,18
1942:  ADDWF  FE8,W
1944:  CLRF   FF7
1946:  RLCF   FF7,F
1948:  ADDLW  5D
194A:  MOVWF  FF6
194C:  MOVLW  19
194E:  ADDWFC FF7,F
1950:  TBLRD*-
1952:  MOVF   FF5,W
1954:  MOVWF  FFA
1956:  TBLRD*
1958:  MOVF   FF5,W
195A:  MOVWF  FF9
195C:  DATA 1C,18
195E:  DATA 3A,18
1960:  DATA 64,18
1962:  DATA 8E,18
.................... 
.................... #list
.................... 
.................... #device adc = 10
.................... #fuses hs, nolvp, protect, MCLR, NOPUT, BORV27
.................... #include "C:\Program Files (x86)\PICC\Drivers\stdlib.h"
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
0C6C:  MOVFF  7E,FE9
0C70:  MOVFF  7F,FEA
0C74:  MOVFF  FEF,82
0C78:  MOVFF  81,03
0C7C:  MOVFF  80,FE9
0C80:  MOVFF  81,FEA
0C84:  MOVF   FEF,W
0C86:  SUBWF  x82,W
0C88:  BNZ   0CB4
....................       if (*s1 == '\0')
0C8A:  MOVFF  7F,03
0C8E:  MOVFF  7E,FE9
0C92:  MOVFF  03,FEA
0C96:  MOVF   FEF,F
0C98:  BNZ   0CA0
....................          return(0);
0C9A:  MOVLW  00
0C9C:  MOVWF  01
0C9E:  BRA    0CDE
0CA0:  MOVFF  7F,03
0CA4:  MOVF   x7E,W
0CA6:  INCF   x7E,F
0CA8:  BTFSC  FD8.2
0CAA:  INCF   x7F,F
0CAC:  INCF   x80,F
0CAE:  BTFSC  FD8.2
0CB0:  INCF   x81,F
0CB2:  BRA    0C6C
....................    return((*s1 < *s2) ? -1: 1);
0CB4:  MOVFF  7F,03
0CB8:  MOVFF  7E,FE9
0CBC:  MOVFF  7F,FEA
0CC0:  MOVFF  FEF,82
0CC4:  MOVFF  81,03
0CC8:  MOVFF  80,FE9
0CCC:  MOVFF  81,FEA
0CD0:  MOVF   FEF,W
0CD2:  SUBWF  x82,W
0CD4:  BC    0CDA
0CD6:  MOVLW  FF
0CD8:  BRA    0CDC
0CDA:  MOVLW  01
0CDC:  MOVWF  01
0CDE:  GOTO   0D26 (RETURN)
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
0C38:  MOVFF  81,83
0C3C:  MOVFF  80,82
0C40:  MOVFF  83,03
0C44:  MOVFF  82,FE9
0C48:  MOVFF  83,FEA
0C4C:  MOVF   FEF,F
0C4E:  BZ    0C58
0C50:  INCF   x82,F
0C52:  BTFSC  FD8.2
0C54:  INCF   x83,F
0C56:  BRA    0C40
....................    return(sc - s);
0C58:  MOVF   x80,W
0C5A:  SUBWF  x82,W
0C5C:  MOVWF  00
0C5E:  MOVF   x81,W
0C60:  SUBWFB x83,W
0C62:  MOVWF  03
0C64:  MOVFF  00,01
0C68:  MOVWF  02
0C6A:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #fuses WDT16384
.................... #use delay(clock = 24000000)
*
0354:  MOVLW  01
0356:  MOVWF  FEA
0358:  MOVLW  2E
035A:  MOVWF  FE9
035C:  MOVF   FEF,W
035E:  BZ    037C
0360:  MOVLW  07
0362:  MOVWF  01
0364:  CLRF   00
0366:  DECFSZ 00,F
0368:  BRA    0366
036A:  DECFSZ 01,F
036C:  BRA    0364
036E:  MOVLW  C7
0370:  MOVWF  00
0372:  DECFSZ 00,F
0374:  BRA    0372
0376:  NOP   
0378:  DECFSZ FEF,F
037A:  BRA    0360
037C:  RETURN 0
.................... #include "lcd_lib_4bit.c"
.................... //#include <stddef.h>
.................... #include "C:\Program Files (x86)\PICC\Drivers\stddef.h"
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... #define LCD_RS          PIN_B1
.................... #define LCD_EN          PIN_B0
.................... #define LCD_D4          PIN_C7
.................... #define LCD_D5          PIN_C6
.................... #define LCD_D6          PIN_C5
.................... #define LCD_D7          PIN_C4
.................... #define Line_1          0x80
.................... #define Line_2          0xC0
.................... #define Clear_Scr       0x01
.................... 
.................... void LCD_Init ();// ham khoi tao LCD
.................... void LCD_SetPosition ( unsigned int cX );//Thiet lap vi tri con tro
.................... void LCD_PutChar ( unsigned int cX );// Ham viet1kitu/1chuoi len LCD
.................... void LCD_PutCmd ( unsigned int cX) ;// Ham gui lenh len LCD
.................... void LCD_PulseEnable ( void );// Xung kich hoat
.................... void LCD_SetData ( unsigned int cX );// Dat du lieu len chan Data
.................... 
.................... //khoi tao LCD**********************************************
.................... void LCD_Init ()
....................     {
....................     LCD_SetData ( 0x00 );
*
0448:  MOVLB  1
044A:  CLRF   x2E
044C:  MOVLB  0
044E:  RCALL  03D6
....................     delay_ms(20);       /*Cho cho lcd khoi tao */
0450:  MOVLW  14
0452:  MOVLB  1
0454:  MOVWF  x2E
0456:  MOVLB  0
0458:  RCALL  0354
....................     output_low ( LCD_RS );// che do gui lenh
045A:  BCF    F93.1
045C:  BCF    F8A.1
....................     LCD_SetData ( 0x03 );   /* khoi tao che do 4 bit */
045E:  MOVLW  03
0460:  MOVLB  1
0462:  MOVWF  x2E
0464:  MOVLB  0
0466:  RCALL  03D6
....................     LCD_PulseEnable();
0468:  RCALL  040C
....................     LCD_PulseEnable();
046A:  RCALL  040C
....................     LCD_PulseEnable();
046C:  RCALL  040C
....................     LCD_SetData ( 0x02 );   /* tao giao dien 4 bit */
046E:  MOVLW  02
0470:  MOVLB  1
0472:  MOVWF  x2E
0474:  MOVLB  0
0476:  RCALL  03D6
....................     LCD_PulseEnable();      /* send dual nibbles hereafter, MSN first */
0478:  RCALL  040C
....................     LCD_PutCmd ( 0x2C );    /* function set (all lines, 5x7 characters) */
047A:  MOVLW  2C
047C:  MOVLB  1
047E:  MOVWF  x2D
0480:  MOVLB  0
0482:  RCALL  042A
....................     LCD_PutCmd ( 0x0C );    /* display ON, cursor off, no blink */
0484:  MOVLW  0C
0486:  MOVLB  1
0488:  MOVWF  x2D
048A:  MOVLB  0
048C:  RCALL  042A
....................     LCD_PutCmd ( 0x06 );    /* entry mode set, increment & scroll left */
048E:  MOVLW  06
0490:  MOVLB  1
0492:  MOVWF  x2D
0494:  MOVLB  0
0496:  RCALL  042A
....................     LCD_PutCmd ( 0x01 );    /* clear display */
0498:  MOVLW  01
049A:  MOVLB  1
049C:  MOVWF  x2D
049E:  MOVLB  0
04A0:  RCALL  042A
04A2:  RETURN 0
.................... 
....................     // Init for BarGraph
.................... 
....................     }
.................... 
.................... void LCD_SetPosition ( unsigned int cX )
....................     {
....................     /* this subroutine works specifically for 4-bit Port A */
....................     LCD_SetData ( swap ( cX ) | 0x08 );
....................     LCD_PulseEnable();
....................     LCD_SetData ( swap ( cX ) );
....................     LCD_PulseEnable();
....................     }
.................... 
.................... void LCD_PutChar ( unsigned int cX )
....................     {
....................     /* this subroutine works specifically for 4-bit Port A */
....................         output_high ( LCD_RS );
*
065C:  BCF    F93.1
065E:  BSF    F8A.1
....................         LCD_PutCmd( cX );
0660:  MOVFF  12C,12D
0664:  RCALL  042A
....................         output_low ( LCD_RS );
0666:  BCF    F93.1
0668:  BCF    F8A.1
066A:  RETURN 0
....................     }
.................... 
.................... void LCD_PutCmd ( unsigned int cX )
....................     {
....................     /* this subroutine works specifically for 4-bit Port A */
....................    
....................     LCD_SetData ( swap ( cX ) );     /* send high nibble */
*
042A:  MOVLB  1
042C:  SWAPF  x2D,F
042E:  MOVFF  12D,12E
0432:  MOVLB  0
0434:  RCALL  03D6
....................     LCD_PulseEnable();
0436:  RCALL  040C
....................     LCD_SetData ( swap ( cX ) );     /* send low nibble */
0438:  MOVLB  1
043A:  SWAPF  x2D,F
043C:  MOVFF  12D,12E
0440:  MOVLB  0
0442:  RCALL  03D6
....................     LCD_PulseEnable();
0444:  RCALL  040C
0446:  RETURN 0
....................     }
.................... 	
.................... void LCD_PulseEnable ( void )
....................     {
....................     output_high ( LCD_EN );
*
040C:  BCF    F93.0
040E:  BSF    F8A.0
....................     delay_us ( 3 );         // was 10
0410:  MOVLW  05
0412:  MOVWF  00
0414:  DECFSZ 00,F
0416:  BRA    0414
0418:  BRA    041A
....................     output_low ( LCD_EN );
041A:  BCF    F93.0
041C:  BCF    F8A.0
....................     delay_ms ( 3 );         // was 5
041E:  MOVLW  03
0420:  MOVLB  1
0422:  MOVWF  x2E
0424:  MOVLB  0
0426:  RCALL  0354
0428:  RETURN 0
....................     }
.................... 
.................... void LCD_SetData ( unsigned int cX )
....................     {
....................     output_bit ( LCD_D4, cX & 0x01 );
*
03D6:  MOVLB  1
03D8:  BTFSC  x2E.0
03DA:  BRA    03E0
03DC:  BCF    F8B.7
03DE:  BRA    03E2
03E0:  BSF    F8B.7
03E2:  BCF    F94.7
....................     output_bit ( LCD_D5, cX & 0x02 );
03E4:  BTFSC  x2E.1
03E6:  BRA    03EC
03E8:  BCF    F8B.6
03EA:  BRA    03EE
03EC:  BSF    F8B.6
03EE:  BCF    F94.6
....................     output_bit ( LCD_D6, cX & 0x04 );
03F0:  BTFSC  x2E.2
03F2:  BRA    03F8
03F4:  BCF    F8B.5
03F6:  BRA    03FA
03F8:  BSF    F8B.5
03FA:  BCF    F94.5
....................     output_bit ( LCD_D7, cX & 0x08 );
03FC:  BTFSC  x2E.3
03FE:  BRA    0404
0400:  BCF    F8B.4
0402:  BRA    0406
0404:  BSF    F8B.4
0406:  BCF    F94.4
0408:  MOVLB  0
040A:  RETURN 0
....................     }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //============================
.................... #define sw_mode PIN_A3
.................... #define sw_up PIN_A2
.................... #define sw_down PIN_A1
.................... #define sw_exit PIN_A0
.................... 
.................... #define val_mode() !input(sw_mode)
.................... #define val_up() !input(sw_up)
.................... #define val_down() !input(sw_down)
.................... #define val_exit() !input(sw_exit)
.................... 
.................... #define clock_reset PIN_A3 // TAO XUNG CHONG TREO
.................... 
.................... #define backligh_lcd PIN_A4
.................... #define backligh_on() output_high(backligh_lcd);
.................... #define backligh_off() output_low(backligh_lcd);
.................... 
.................... #define cb_mn PIN_C2
.................... #define cb_ac PIN_C3
.................... 
.................... #define status_mn() !input(cb_mn)
.................... #define status_ac() !input(cb_ac)
.................... 
.................... #define out_fire PIN_B2
.................... #define out_temp PIN_B3
.................... #define out_error PIN_B5
.................... #define out_delay PIN_B4
.................... #define out_mn PIN_B6
.................... #define out_ac PIN_B7
.................... 
.................... #define ree(x) read_eeprom(x);
.................... #define wee(x, y) write_eeprom(x, y);
.................... 
.................... #define tg_tri_hoan 1
.................... #define tg_chay_lien_tuc 2
.................... #define tg_tam_dung 3
.................... #define do_ac 4
.................... #define ac_bthg 5
.................... #define chay_mpd 6
.................... #define error 7
.................... 
.................... //===================
.................... #define clear_lcd() lcd_printf(0);
.................... #define yesno() lcd_printf(9);
.................... #define loading() lcd_printf(10);
.................... 
.................... #define sch_1_s_set() lcd_printf(11);
.................... 
.................... // luu tru trong rom
.................... 
.................... #define timer_tri_hoan_ee 0x00
.................... #define counter_restart_mpd_ee timer_tri_hoan_ee + 1
.................... #define timer_chay_lien_tuc_ee counter_restart_mpd_ee + 1
.................... #define timer_tam_dung_ee timer_chay_lien_tuc_ee + 1
.................... #define timer_ktra_AC_ee timer_tam_dung_ee + 1
.................... #define timer_ktra_mn_ee timer_ktra_AC_ee + 1
.................... 
.................... #define size_pass 5
.................... 
.................... // khai bao bien
.................... unsigned char val_number_defaul[11] = {"0123456789"};
.................... // con tro phuc vu cai dat
.................... char *sch_1 = 0, *sch_2 = 0, val_sch_1 = 0, val_sch_2 = 0;
.................... 
.................... char password[size_pass] = {"1111"};
.................... char str_temp[25] = "";
.................... char time_reset_password = 0;
.................... 
.................... char state_AC = 0;
.................... char mode = 9;
.................... char state_mn = 0;
.................... short refresh_menu = 0;
.................... 
.................... char timer_exit = 0;
.................... char timer_backlight = 240;
.................... 
.................... char val_timer_tri_hoan = 60, timer_tri_hoan = 60, timer_tri_hoan_md = 60;             // LONG DELAY 1
.................... char val_counter_restart_mpd = 1, counter_restart_mpd = 4, counter_restart_mpd_md = 4; // LONG SO LAN KHOI DONG LAI MPD
.................... char counter_restart_mpd_current = 4;
.................... char val_timer_chay_lien_tuc = 3, timer_chay_lien_tuc = 3, timer_chay_lien_tuc_md = 3; // LONG DELAY 2
.................... char val_timer_tam_dung = 60, timer_tam_dung = 60, timer_tam_dung_md = 60;             // LONG DELAY 3
.................... char val_timer_ktra_AC = 60, timer_ktra_AC = 60, timer_ktra_AC_md = 60;                // LONG KT AC TIMER
.................... char val_timer_ktra_mn = 30, timer_ktra_mn = 30, timer_ktra_mn_md = 30;                // LONG KT MN TIMER
.................... char val_timer_on_mpd = 20, timer_on_mpd = 20;
.................... char val_timer_off_mpd = 20, timer_off_mpd = 20;
.................... 
.................... char val_loading = 0;
.................... 
.................... char flag_error = 0; // LONG FLAG = 0 la ko loi, = 1 la LOI
.................... char flag_mn = 0;    // LONG FLAG = 0 la chay xong check_mn(), = 1 la dang chay
.................... 
.................... unsigned long counter_timer0 = 0, flag_timer_chay_lien_tuc_3600s = 3600;
.................... char flag_timer_tri_hoan_60s = 60, flag_timer_60s_password = 0, flag_timer_tam_dung_60s = 60;
.................... 
.................... char pwm_lcd = 0;
.................... char sum_out = 0, sum_out_old = 0, loop_not_display = 0;
.................... 
.................... //===============================
.................... void init_data(void);
.................... void check_AC(void);
.................... char check_mn(void);
.................... void default_data(void);
.................... void display(char code_print);
.................... char key_scan(void);
.................... void process_menu(void);
.................... void process_up(void);
.................... void process_down(void);
.................... void process_exit(void);
.................... void display_center(void);
.................... void lcd_printf(char code_printf);
.................... void reset_timer_data(void);
.................... void write_data(void);
.................... void read_data(void);
.................... 
.................... unsigned char read_eeprom(unsigned char addr);
.................... void write_eeprom(unsigned char addr, unsigned char value);
.................... 
.................... void disable_reset(void);
.................... 
.................... //===============================
.................... void main()
*
15F8:  CLRF   FF8
15FA:  BCF    FD0.7
15FC:  BSF    07.7
15FE:  CLRF   2B
1600:  CLRF   2A
1602:  CLRF   2D
1604:  CLRF   2C
1606:  CLRF   2E
1608:  CLRF   2F
160A:  CLRF   4E
160C:  CLRF   4F
160E:  MOVLW  09
1610:  MOVWF  50
1612:  CLRF   51
1614:  BCF    52.0
1616:  CLRF   53
1618:  MOVLW  F0
161A:  MOVWF  54
161C:  MOVLW  3C
161E:  MOVWF  55
1620:  MOVWF  56
1622:  MOVWF  57
1624:  MOVLW  01
1626:  MOVWF  58
1628:  MOVLW  04
162A:  MOVWF  59
162C:  MOVWF  5A
162E:  MOVWF  5B
1630:  MOVLW  03
1632:  MOVWF  5C
1634:  MOVWF  5D
1636:  MOVWF  5E
1638:  MOVLW  3C
163A:  MOVWF  5F
163C:  MOVWF  x60
163E:  MOVWF  x61
1640:  MOVWF  x62
1642:  MOVWF  x63
1644:  MOVWF  x64
1646:  MOVLW  1E
1648:  MOVWF  x65
164A:  MOVWF  x66
164C:  MOVWF  x67
164E:  MOVLW  14
1650:  MOVWF  x68
1652:  MOVWF  x69
1654:  MOVWF  x6A
1656:  MOVWF  x6B
1658:  CLRF   x6C
165A:  CLRF   x6D
165C:  CLRF   x6E
165E:  CLRF   x70
1660:  CLRF   x6F
1662:  MOVLW  0E
1664:  MOVWF  x72
1666:  MOVLW  10
1668:  MOVWF  x71
166A:  MOVLW  3C
166C:  MOVWF  x73
166E:  CLRF   x74
1670:  MOVWF  x75
1672:  CLRF   x76
1674:  CLRF   x77
1676:  CLRF   x78
1678:  CLRF   x79
167A:  CLRF   x7B
167C:  CLRF   x7A
167E:  MOVLW  00
1680:  MOVWF  F7E
1682:  BCF    FC1.4
1684:  BCF    FC1.5
1686:  MOVF   F7F,W
1688:  ANDLW  E0
168A:  MOVWF  F7F
168C:  BCF    F79.5
168E:  BCF    F79.4
1690:  CLRF   F7A
1692:  CLRF   F7B
1694:  CLRF   19
1696:  CLRF   1A
1698:  MOVLW  30
169A:  MOVWF  1F
169C:  MOVLW  31
169E:  MOVWF  20
16A0:  MOVLW  32
16A2:  MOVWF  21
16A4:  MOVLW  33
16A6:  MOVWF  22
16A8:  MOVLW  34
16AA:  MOVWF  23
16AC:  MOVLW  35
16AE:  MOVWF  24
16B0:  MOVLW  36
16B2:  MOVWF  25
16B4:  MOVLW  37
16B6:  MOVWF  26
16B8:  MOVLW  38
16BA:  MOVWF  27
16BC:  MOVLW  39
16BE:  MOVWF  28
16C0:  CLRF   29
16C2:  MOVLW  31
16C4:  MOVWF  30
16C6:  MOVWF  31
16C8:  MOVWF  32
16CA:  MOVWF  33
16CC:  CLRF   34
16CE:  CLRF   35
.................... {
....................    // chong treo xu li
....................    disable_reset();
16D0:  CALL   037E
....................    // KHOI DONG NGAT TIMER 0
....................    SETUP_TIMER_0(T0_INTERNAL | T0_DIV_4);
16D4:  MOVLW  81
16D6:  MOVWF  FD5
....................    enable_interrupts(INT_TIMER0);
16D8:  BSF    FF2.5
....................    enable_interrupts(GLOBAL);
16DA:  MOVLW  C0
16DC:  IORWF  FF2,F
....................    clear_interrupt(INT_TIMER0);
16DE:  BCF    FF2.2
....................    set_timer0(62536); //(24000000/128)/(65535-65160)=187500/375=500us
16E0:  MOVLW  F4
16E2:  MOVWF  FD7
16E4:  MOVLW  48
16E6:  MOVWF  FD6
16E8:  NOP   
....................    lcd_init();        // khoi dong mang hinh lcd
16EA:  CALL   0448
....................    backligh_on();
16EE:  BCF    F92.4
16F0:  BSF    F89.4
....................    read_data();
16F2:  GOTO   04A4
....................    init_data();
16F6:  GOTO   0542
....................    // CHUONG TRINH CHINH
....................    while (1)
....................    {
....................       disable_reset();
16FA:  CALL   037E
....................       restart_wdt();
16FE:  CLRWDT
....................       // DIEU HOA TRANG THAI: Tinh nang chinh - nhap menu
....................       switch (mode)
1700:  MOVF   50,W
1702:  ADDLW  F6
1704:  BTFSC  FD8.0
1706:  BRA    1808
1708:  ADDLW  0A
170A:  GOTO   1914
....................       {
....................       case 0: // TINH NANG CHINH
....................          check_AC();
170E:  GOTO   05E2
.................... 
....................          switch (state_AC)
1712:  MOVF   4F,W
1714:  ADDLW  F5
1716:  BTFSC  FD8.0
1718:  BRA    17F6
171A:  ADDLW  0B
171C:  GOTO   18E4
....................          {
....................          case 0: // Timer delay ktra ac
....................             break;
1720:  BRA    17F6
.................... 
....................          case 1: // co AC ->hien thi LCD
....................             reset_timer_data();
1722:  CALL   0628
....................             output_low(out_fire);
1726:  BCF    F93.2
1728:  BCF    F8A.2
....................             output_low(out_delay);
172A:  BCF    F93.4
172C:  BCF    F8A.4
....................             break;
172E:  BRA    17F6
....................          case 2: // mat AC: DELAY 1
....................             output_high(out_delay);
1730:  BCF    F93.4
1732:  BSF    F8A.4
....................             if (val_timer_tri_hoan <= 0)
1734:  MOVF   55,F
1736:  BNZ   173C
....................             {
....................                state_AC = 3;
1738:  MOVLW  03
173A:  MOVWF  4F
....................             }
....................             break;
173C:  BRA    17F6
....................          case 3: // mat AC: DO DIEN AP MPD
....................             if (val_counter_restart_mpd <= counter_restart_mpd_current)
173E:  MOVF   58,W
1740:  SUBWF  5B,W
1742:  BNC   179E
....................             {
....................                display(chay_mpd);
1744:  MOVLW  06
1746:  MOVLB  1
1748:  MOVWF  x28
174A:  MOVLB  0
174C:  CALL   0856
....................                switch (state_mn)
1750:  MOVF   51,W
1752:  BZ    175E
1754:  XORLW  01
1756:  BZ    1770
1758:  XORLW  03
175A:  BZ    178C
175C:  BRA    179C
....................                {
....................                case 0: // on remote start delay
....................                   output_high(out_fire);
175E:  BCF    F93.2
1760:  BSF    F8A.2
....................                   if (val_timer_on_mpd <= 0)
1762:  MOVF   x68,F
1764:  BNZ   176E
....................                   {
....................                      state_mn = 1;
1766:  MOVLW  01
1768:  MOVWF  51
....................                      val_timer_on_mpd = timer_on_mpd;
176A:  MOVFF  69,68
....................                   }
....................                   break;
176E:  BRA    179C
....................                case 1: // do mpd
....................                   char mn = check_mn();
1770:  CALL   0AD8
1774:  MOVFF  01,7C
....................                   if (mn == 1)
1778:  DECFSZ x7C,W
177A:  BRA    1782
....................                   {
....................                      state_AC = 4;
177C:  MOVLW  04
177E:  MOVWF  4F
....................                   }
1780:  BRA    178A
....................                   else if (mn == 0)
1782:  MOVF   x7C,F
1784:  BNZ   178A
....................                   {
....................                      state_mn = 2;
1786:  MOVLW  02
1788:  MOVWF  51
....................                   }
....................                   break;
178A:  BRA    179C
....................                case 2: // off remote start delay
....................                   output_low(out_fire);
178C:  BCF    F93.2
178E:  BCF    F8A.2
....................                   if (val_timer_off_mpd <= 0)
1790:  MOVF   x6A,F
1792:  BNZ   179C
....................                   {
....................                      state_mn = 0;
1794:  CLRF   51
....................                      val_timer_off_mpd = timer_off_mpd;
1796:  MOVFF  6B,6A
....................                      val_counter_restart_mpd++;
179A:  INCF   58,F
....................                   }
....................                   break;
....................                }
....................             }
179C:  BRA    17A8
....................             else if (val_counter_restart_mpd > counter_restart_mpd_current)
179E:  MOVF   58,W
17A0:  SUBWF  5B,W
17A2:  BC    17A8
....................             {
....................                state_AC = 10; // error
17A4:  MOVLW  0A
17A6:  MOVWF  4F
....................             }
....................             break;
17A8:  BRA    17F6
....................          case 4: // DELAY 2 + OFF REMOTE START
....................             char mn = check_mn();
17AA:  CALL   0AD8
17AE:  MOVFF  01,7D
....................             if (mn == 0)
17B2:  MOVF   x7D,F
17B4:  BNZ   17BC
....................             {
....................                state_AC = 10; // error
17B6:  MOVLW  0A
17B8:  MOVWF  4F
....................                break;
17BA:  BRA    17F6
....................             }
....................             // OFF REMOTE START
....................             if (val_timer_chay_lien_tuc <= 0)
17BC:  MOVF   5C,F
17BE:  BNZ   17D2
....................             {
....................                output_low(out_fire);
17C0:  BCF    F93.2
17C2:  BCF    F8A.2
....................                flag_error = 0;
17C4:  CLRF   x6D
....................                output_low(out_temp);
17C6:  BCF    F93.3
17C8:  BCF    F8A.3
....................                output_low(out_error);
17CA:  BCF    F93.5
17CC:  BCF    F8A.5
....................                state_AC = 5;
17CE:  MOVLW  05
17D0:  MOVWF  4F
....................             }
....................             break;
17D2:  BRA    17F6
....................          case 5: // DELAY 3
....................             if (val_timer_tam_dung <= 0)
17D4:  MOVF   5F,F
17D6:  BNZ   17E0
....................             {
....................                state_AC = 3;
17D8:  MOVLW  03
17DA:  MOVWF  4F
....................                reset_timer_data();
17DC:  CALL   0628
....................             }
....................             break;
17E0:  BRA    17F6
....................          case 10: // error
....................             flag_error = 1;
17E2:  MOVLW  01
17E4:  MOVWF  x6D
....................             output_low(out_fire);
17E6:  BCF    F93.2
17E8:  BCF    F8A.2
....................             output_high(out_temp);
17EA:  BCF    F93.3
17EC:  BSF    F8A.3
....................             output_high(out_error);
17EE:  BCF    F93.5
17F0:  BSF    F8A.5
....................             output_low(out_delay);
17F2:  BCF    F93.4
17F4:  BCF    F8A.4
....................             break;
....................          }
....................          break;
17F6:  BRA    1808
....................       case 1: // nhap mat khau
....................          break;
17F8:  BRA    1808
....................       case 2: // MENU TG TRI HOAN MPD
....................          break;
17FA:  BRA    1808
....................       case 3: // MENU TG CHAY LIEN TUC
....................          break;
17FC:  BRA    1808
....................       case 4: // MENU TG TAM DUNG MPD
....................          break;
17FE:  BRA    1808
....................       case 5: // MENU TG KTRA DA AC
....................          break;
1800:  BRA    1808
....................       case 6: // MENU TG KTRA DA MN
....................          break;
1802:  BRA    1808
....................       case 7: // MENU SO LAN KHOI DONG
....................          break;
1804:  BRA    1808
....................       case 8: // MENU cai dat mat dinh
....................          break;
1806:  BRA    1808
....................       case 9: // Loading screen
....................          // loading xong chay tinh nang chinh
....................          break;
....................       }
.................... 
....................       // kiem tra phim nhan
....................       output_float(sw_down);
1808:  BSF    F92.1
....................       switch (key_scan())
180A:  GOTO   0B0A
180E:  MOVLW  01
1810:  SUBWF  01,W
1812:  ADDLW  FC
1814:  BC    18A6
1816:  ADDLW  04
1818:  GOTO   1942
....................       {
....................       case 0x01: // nut menu duoc nhan
....................          lcd_init();
181C:  CALL   0448
....................          timer_exit = 30;
1820:  MOVLW  1E
1822:  MOVWF  53
....................          timer_backlight = 250;
1824:  MOVLW  FA
1826:  MOVWF  54
....................          process_menu();
1828:  GOTO   0CE2
....................          delay_ms(200);
182C:  MOVLW  C8
182E:  MOVLB  1
1830:  MOVWF  x2E
1832:  MOVLB  0
1834:  CALL   0354
....................          break;
1838:  BRA    18A6
.................... 
....................       case 0x02: // nut up duoc nhan
....................          timer_exit = 90;
183A:  MOVLW  5A
183C:  MOVWF  53
....................          timer_backlight = 250;
183E:  MOVLW  FA
1840:  MOVWF  54
....................          process_up();
1842:  GOTO   0E7C
....................          if (mode >= 2 && mode <= 7)
1846:  MOVF   50,W
1848:  SUBLW  01
184A:  BC    1856
184C:  MOVF   50,W
184E:  SUBLW  07
1850:  BNC   1856
....................             write_data();
1852:  CALL   0D7C
....................          delay_ms(200);
1856:  MOVLW  C8
1858:  MOVLB  1
185A:  MOVWF  x2E
185C:  MOVLB  0
185E:  CALL   0354
....................          break;
1862:  BRA    18A6
.................... 
....................       case 0x03: // nut down duoc nhan
....................          timer_exit = 90;
1864:  MOVLW  5A
1866:  MOVWF  53
....................          timer_backlight = 250;
1868:  MOVLW  FA
186A:  MOVWF  54
....................          process_down();
186C:  GOTO   0F66
....................          if (mode >= 2 && mode <= 7)
1870:  MOVF   50,W
1872:  SUBLW  01
1874:  BC    1880
1876:  MOVF   50,W
1878:  SUBLW  07
187A:  BNC   1880
....................             write_data();
187C:  CALL   0D7C
....................          delay_ms(200);
1880:  MOVLW  C8
1882:  MOVLB  1
1884:  MOVWF  x2E
1886:  MOVLB  0
1888:  CALL   0354
....................          break;
188C:  BRA    18A6
.................... 
....................       case 0x04: // nut exit duoc nhan
....................          timer_exit = 90;
188E:  MOVLW  5A
1890:  MOVWF  53
....................          timer_backlight = 250;
1892:  MOVLW  FA
1894:  MOVWF  54
....................          process_exit();
1896:  GOTO   1040
....................          delay_ms(200);
189A:  MOVLW  C8
189C:  MOVLB  1
189E:  MOVWF  x2E
18A0:  MOVLB  0
18A2:  CALL   0354
....................          break;
....................       }
.................... 
....................       // chuong trinh hien thi
....................       sum_out = 0;
18A6:  CLRF   x77
.................... 
....................       if (sum_out > sum_out_old)
18A8:  MOVF   x77,W
18AA:  SUBWF  x78,W
18AC:  BC    18B6
....................       {
....................          loop_not_display = 3;
18AE:  MOVLW  03
18B0:  MOVWF  x79
....................          timer_backlight = 250;
18B2:  MOVLW  FA
18B4:  MOVWF  54
....................       }
....................       sum_out_old = sum_out;
18B6:  MOVFF  77,78
.................... 
....................       disable_reset();
18BA:  CALL   037E
.................... 
....................       switch (loop_not_display)
18BE:  MOVF   x79,W
18C0:  XORLW  01
18C2:  BZ    18CA
18C4:  XORLW  01
18C6:  BZ    18D8
18C8:  BRA    18DC
....................       {
....................       case 1:
....................          lcd_init();
18CA:  CALL   0448
....................          loop_not_display--;
18CE:  DECF   x79,F
....................          if (mode != 0)
18D0:  MOVF   50,F
18D2:  BZ    18D6
....................             refresh_menu = 1;
18D4:  BSF    52.0
....................          break;
18D6:  BRA    18DC
....................       case 0:
....................          display_center();
18D8:  GOTO   10A0
....................          break;
....................       }
.................... 
....................       disable_reset();
18DC:  CALL   037E
18E0:  BRA    16FA
....................    }
.................... }
.................... 
18E2:  BRA    18E2
.................... //=========================
.................... void init_data(void)
.................... {
....................    // con tro phuc vu cai dat
....................    *sch_1 = 0, *sch_2 = 0, val_sch_1 = 0, val_sch_2 = 0;
*
0542:  MOVFF  2A,FE9
0546:  MOVFF  2B,FEA
054A:  CLRF   FEF
054C:  MOVLW  00
054E:  MOVFF  2C,FE9
0552:  MOVFF  2D,FEA
0556:  CLRF   FEF
0558:  MOVLW  00
055A:  CLRF   2E
055C:  CLRF   2F
....................    str_temp = "";
055E:  CLRF   FEA
0560:  MOVLW  35
0562:  MOVWF  FE9
0564:  MOVLW  00
0566:  RCALL  00AE
0568:  TBLRD*-
056A:  TBLRD*+
056C:  MOVF   FF5,W
056E:  MOVWF  FEE
0570:  IORLW  00
0572:  BNZ   056A
....................    time_reset_password = 0;
0574:  CLRF   4E
.................... 
....................    state_AC = 0;
0576:  CLRF   4F
....................    mode = 9;
0578:  MOVLW  09
057A:  MOVWF  50
....................    state_mn = 0;
057C:  CLRF   51
....................    refresh_menu = 0;
057E:  BCF    52.0
.................... 
....................    timer_exit = 0;
0580:  CLRF   53
....................    timer_backlight = 240;
0582:  MOVLW  F0
0584:  MOVWF  54
.................... 
....................    val_timer_tri_hoan = timer_tri_hoan, timer_tri_hoan_md = 60;                                                // LONG DELAY 1
0586:  MOVFF  56,55
058A:  MOVLW  3C
058C:  MOVWF  57
....................    val_counter_restart_mpd = 1, counter_restart_mpd_current = counter_restart_mpd, counter_restart_mpd_md = 4; // LONG SO LAN KHOI DONG LAI MPD
058E:  MOVLW  01
0590:  MOVWF  58
0592:  MOVFF  59,5B
0596:  MOVLW  04
0598:  MOVWF  5A
....................    val_timer_chay_lien_tuc = timer_chay_lien_tuc, timer_chay_lien_tuc_md = 3;                                  // LONG DELAY 2
059A:  MOVFF  5D,5C
059E:  MOVLW  03
05A0:  MOVWF  5E
....................    val_timer_tam_dung = timer_tam_dung, timer_tam_dung_md = 60;                                                // LONG DELAY 3
05A2:  MOVFF  60,5F
05A6:  MOVLW  3C
05A8:  MOVWF  x61
....................    val_timer_ktra_AC = timer_ktra_AC, timer_ktra_AC_md = 60;                                                   // LONG KT AC TIMER
05AA:  MOVFF  63,62
05AE:  MOVWF  x64
....................    flag_error = 0;                                                                                             // LONG FLAG = 0 la ko loi, = 1 la LOI
05B0:  CLRF   x6D
....................    flag_mn = 0;
05B2:  CLRF   x6E
....................    val_timer_ktra_mn = timer_ktra_mn, timer_ktra_mn_md = 30; // LONG KT MN TIMER
05B4:  MOVFF  66,65
05B8:  MOVLW  1E
05BA:  MOVWF  x67
....................    val_timer_on_mpd = 20, timer_on_mpd = 20;
05BC:  MOVLW  14
05BE:  MOVWF  x68
05C0:  MOVWF  x69
....................    val_timer_off_mpd = 20, timer_off_mpd = 20;
05C2:  MOVWF  x6A
05C4:  MOVWF  x6B
.................... 
....................    val_loading = 0;
05C6:  CLRF   x6C
.................... 
....................    counter_timer0 = 0, flag_timer_60s_password = 0;
05C8:  CLRF   x70
05CA:  CLRF   x6F
05CC:  CLRF   x74
....................    flag_timer_tri_hoan_60s = 0, flag_timer_chay_lien_tuc_3600s = 0, flag_timer_tam_dung_60s = 0;
05CE:  CLRF   x73
05D0:  CLRF   x72
05D2:  CLRF   x71
05D4:  CLRF   x75
.................... 
....................    pwm_lcd = 0;
05D6:  CLRF   x76
....................    sum_out = 0, sum_out_old = 0, loop_not_display = 0;
05D8:  CLRF   x77
05DA:  CLRF   x78
05DC:  CLRF   x79
05DE:  GOTO   16FA (RETURN)
.................... }
.................... char check_mn(void)
.................... {
....................    flag_mn = 1;
*
0AD8:  MOVLW  01
0ADA:  MOVWF  x6E
....................    if (status_mn())
0ADC:  BSF    F94.2
0ADE:  BTFSC  F82.2
0AE0:  BRA    0AEE
....................    {
....................       flag_mn = 0;
0AE2:  CLRF   x6E
....................       val_timer_ktra_mn = timer_ktra_mn;
0AE4:  MOVFF  66,65
....................       return 1; // do dc d.a mn
0AE8:  MOVLW  01
0AEA:  MOVWF  01
0AEC:  BRA    0B08
....................    }
....................    if (val_timer_ktra_mn <= 0)
0AEE:  MOVF   x65,F
0AF0:  BNZ   0B04
....................    {
....................       flag_mn = 0;
0AF2:  CLRF   x6E
....................       val_timer_ktra_mn = timer_ktra_mn;
0AF4:  MOVFF  66,65
....................       return status_mn(); // ket thuc delay do mn va return ket qua do
0AF8:  BSF    F94.2
0AFA:  MOVLW  00
0AFC:  BTFSS  F82.2
0AFE:  MOVLW  01
0B00:  MOVWF  01
0B02:  BRA    0B08
....................    }
....................    return 2; // dang chay delay do mn
0B04:  MOVLW  02
0B06:  MOVWF  01
0B08:  RETURN 0
.................... }
.................... void check_AC(void)
.................... {
....................    if (state_AC <= 1 && (!(status_AC())))
*
05E2:  MOVF   4F,W
05E4:  SUBLW  01
05E6:  BNC   0604
05E8:  BSF    F94.3
05EA:  BTFSS  F82.3
05EC:  BRA    0604
....................    {
....................       state_AC = 0; // chay trang thai dem do AC
05EE:  CLRF   4F
....................       if (val_timer_ktra_AC <= 0)
05F0:  MOVF   x62,F
05F2:  BNZ   0602
....................       {
....................          if (!(status_AC()))
05F4:  BSF    F94.3
05F6:  BTFSS  F82.3
05F8:  BRA    05FE
....................          {
....................             state_AC = 2;
05FA:  MOVLW  02
05FC:  MOVWF  4F
....................          }
....................          val_timer_ktra_AC = timer_ktra_AC;
05FE:  MOVFF  63,62
....................       }
....................    }
0602:  BRA    0624
....................    else if (state_AC != 1 && (status_AC()))
0604:  DECFSZ 4F,W
0606:  BRA    060A
0608:  BRA    0624
060A:  BSF    F94.3
060C:  BTFSC  F82.3
060E:  BRA    0624
....................    {
....................       state_AC = 0; // chay trang thai dem do AC
0610:  CLRF   4F
....................       if (val_timer_ktra_AC <= 0)
0612:  MOVF   x62,F
0614:  BNZ   0624
....................       {
....................          if (status_AC())
0616:  BSF    F94.3
0618:  BTFSC  F82.3
061A:  BRA    0620
....................          {
....................             state_AC = 1;
061C:  MOVLW  01
061E:  MOVWF  4F
....................          }
....................          val_timer_ktra_AC = timer_ktra_AC;
0620:  MOVFF  63,62
....................       }
....................    }
0624:  GOTO   1712 (RETURN)
.................... }
.................... 
.................... void display(char code_print)
.................... {
....................    switch (code_print)
*
0856:  MOVLB  1
0858:  MOVF   x28,W
085A:  ADDLW  F8
085C:  BTFSC  FD8.0
085E:  BRA    0AAA
0860:  ADDLW  08
0862:  MOVLB  0
0864:  GOTO   0AAE
....................    {
....................    case 0: // ko in
....................       break;
0868:  MOVLB  1
086A:  BRA    0AAA
....................    case 1: // delay 1
....................       LCD_PUTCMD(Line_1);
086C:  MOVLW  80
086E:  MOVLB  1
0870:  MOVWF  x2D
0872:  MOVLB  0
0874:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "TG TRI HOAN MPD");
0876:  MOVLW  C0
0878:  MOVWF  FF6
087A:  MOVLW  00
087C:  MOVWF  FF7
087E:  RCALL  066C
....................       clear_lcd();
0880:  MOVLB  1
0882:  CLRF   x29
0884:  MOVLB  0
0886:  RCALL  06B0
....................       LCD_PUTCMD(Line_2);
0888:  MOVLW  C0
088A:  MOVLB  1
088C:  MOVWF  x2D
088E:  MOVLB  0
0890:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "PHUT: %01u", val_timer_tri_hoan);
0892:  MOVLW  D0
0894:  MOVWF  FF6
0896:  MOVLW  00
0898:  MOVWF  FF7
089A:  MOVLW  06
089C:  MOVLB  1
089E:  MOVWF  x29
08A0:  MOVLB  0
08A2:  RCALL  0786
08A4:  MOVFF  55,129
08A8:  MOVLW  08
08AA:  MOVLB  1
08AC:  MOVWF  x2A
08AE:  MOVLB  0
08B0:  RCALL  07DA
....................       clear_lcd();
08B2:  MOVLB  1
08B4:  CLRF   x29
08B6:  MOVLB  0
08B8:  RCALL  06B0
....................       break;
08BA:  MOVLB  1
08BC:  BRA    0AAA
....................    case 2: // delay 2
....................       LCD_PUTCMD(Line_1);
08BE:  MOVLW  80
08C0:  MOVLB  1
08C2:  MOVWF  x2D
08C4:  MOVLB  0
08C6:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "TG CHAY LIEN TUC");
08C8:  MOVLW  DC
08CA:  MOVWF  FF6
08CC:  MOVLW  00
08CE:  MOVWF  FF7
08D0:  RCALL  066C
....................       clear_lcd();
08D2:  MOVLB  1
08D4:  CLRF   x29
08D6:  MOVLB  0
08D8:  RCALL  06B0
....................       LCD_PUTCMD(Line_2);
08DA:  MOVLW  C0
08DC:  MOVLB  1
08DE:  MOVWF  x2D
08E0:  MOVLB  0
08E2:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "GIO: %01u", val_timer_chay_lien_tuc);
08E4:  MOVLW  EE
08E6:  MOVWF  FF6
08E8:  MOVLW  00
08EA:  MOVWF  FF7
08EC:  MOVLW  05
08EE:  MOVLB  1
08F0:  MOVWF  x29
08F2:  MOVLB  0
08F4:  RCALL  0786
08F6:  MOVFF  5C,129
08FA:  MOVLW  08
08FC:  MOVLB  1
08FE:  MOVWF  x2A
0900:  MOVLB  0
0902:  RCALL  07DA
....................       clear_lcd();
0904:  MOVLB  1
0906:  CLRF   x29
0908:  MOVLB  0
090A:  RCALL  06B0
....................       break;
090C:  MOVLB  1
090E:  BRA    0AAA
....................    case 3: // delay 3
....................       LCD_PUTCMD(Line_1);
0910:  MOVLW  80
0912:  MOVLB  1
0914:  MOVWF  x2D
0916:  MOVLB  0
0918:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "TG TAM DUNG MPD");
091A:  MOVLW  F8
091C:  MOVWF  FF6
091E:  MOVLW  00
0920:  MOVWF  FF7
0922:  RCALL  066C
....................       clear_lcd();
0924:  MOVLB  1
0926:  CLRF   x29
0928:  MOVLB  0
092A:  RCALL  06B0
....................       LCD_PUTCMD(Line_2);
092C:  MOVLW  C0
092E:  MOVLB  1
0930:  MOVWF  x2D
0932:  MOVLB  0
0934:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "PHUT: %01u", val_timer_tam_dung);
0936:  MOVLW  08
0938:  MOVWF  FF6
093A:  MOVLW  01
093C:  MOVWF  FF7
093E:  MOVLW  06
0940:  MOVLB  1
0942:  MOVWF  x29
0944:  MOVLB  0
0946:  RCALL  0786
0948:  MOVFF  5F,129
094C:  MOVLW  08
094E:  MOVLB  1
0950:  MOVWF  x2A
0952:  MOVLB  0
0954:  RCALL  07DA
....................       clear_lcd();
0956:  MOVLB  1
0958:  CLRF   x29
095A:  MOVLB  0
095C:  RCALL  06B0
....................       break;
095E:  MOVLB  1
0960:  BRA    0AAA
....................    case 4: // Do AC
....................       LCD_PUTCMD(Line_1);
0962:  MOVLW  80
0964:  MOVLB  1
0966:  MOVWF  x2D
0968:  MOVLB  0
096A:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "KIEM TRA AC");
096C:  MOVLW  14
096E:  MOVWF  FF6
0970:  MOVLW  01
0972:  MOVWF  FF7
0974:  RCALL  066C
....................       clear_lcd()
0976:  MOVLB  1
0978:  CLRF   x29
097A:  MOVLB  0
097C:  RCALL  06B0
....................           LCD_PUTCMD(Line_2);
097E:  MOVLW  C0
0980:  MOVLB  1
0982:  MOVWF  x2D
0984:  MOVLB  0
0986:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "GIAY: %01u", val_timer_ktra_AC);
0988:  MOVLW  20
098A:  MOVWF  FF6
098C:  MOVLW  01
098E:  MOVWF  FF7
0990:  MOVLW  06
0992:  MOVLB  1
0994:  MOVWF  x29
0996:  MOVLB  0
0998:  RCALL  0786
099A:  MOVFF  62,129
099E:  MOVLW  08
09A0:  MOVLB  1
09A2:  MOVWF  x2A
09A4:  MOVLB  0
09A6:  RCALL  07DA
....................       clear_lcd();
09A8:  MOVLB  1
09AA:  CLRF   x29
09AC:  MOVLB  0
09AE:  RCALL  06B0
....................       break;
09B0:  MOVLB  1
09B2:  BRA    0AAA
....................    case 5: // AC BINH THUONG
....................       LCD_PUTCMD(Line_1);
09B4:  MOVLW  80
09B6:  MOVLB  1
09B8:  MOVWF  x2D
09BA:  MOVLB  0
09BC:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "D.AP AC BTHUONG");
09BE:  MOVLW  2C
09C0:  MOVWF  FF6
09C2:  MOVLW  01
09C4:  MOVWF  FF7
09C6:  RCALL  066C
....................       clear_lcd();
09C8:  MOVLB  1
09CA:  CLRF   x29
09CC:  MOVLB  0
09CE:  RCALL  06B0
....................       if (flag_error)
09D0:  MOVF   x6D,F
09D2:  BZ    0A04
....................       {
....................          LCD_PUTCMD(Line_2);
09D4:  MOVLW  C0
09D6:  MOVLB  1
09D8:  MOVWF  x2D
09DA:  MOVLB  0
09DC:  RCALL  042A
....................          clear_lcd();
09DE:  MOVLB  1
09E0:  CLRF   x29
09E2:  MOVLB  0
09E4:  RCALL  06B0
....................          LCD_PUTCMD(Line_2);
09E6:  MOVLW  C0
09E8:  MOVLB  1
09EA:  MOVWF  x2D
09EC:  MOVLB  0
09EE:  RCALL  042A
....................          PRINTF(LCD_PUTCHAR, "MPD LOI");
09F0:  MOVLW  3C
09F2:  MOVWF  FF6
09F4:  MOVLW  01
09F6:  MOVWF  FF7
09F8:  RCALL  066C
....................          clear_lcd();
09FA:  MOVLB  1
09FC:  CLRF   x29
09FE:  MOVLB  0
0A00:  RCALL  06B0
....................       }
0A02:  BRA    0A20
....................       else
....................       {
....................          LCD_PUTCMD(Line_2);
0A04:  MOVLW  C0
0A06:  MOVLB  1
0A08:  MOVWF  x2D
0A0A:  MOVLB  0
0A0C:  RCALL  042A
....................          PRINTF(LCD_PUTCHAR, "MPD TOT");
0A0E:  MOVLW  44
0A10:  MOVWF  FF6
0A12:  MOVLW  01
0A14:  MOVWF  FF7
0A16:  RCALL  066C
....................          clear_lcd();
0A18:  MOVLB  1
0A1A:  CLRF   x29
0A1C:  MOVLB  0
0A1E:  RCALL  06B0
....................       }
....................       break;
0A20:  MOVLB  1
0A22:  BRA    0AAA
....................    case 6: // CHAY MPD
....................       LCD_PUTCMD(Line_1);
0A24:  MOVLW  80
0A26:  MOVLB  1
0A28:  MOVWF  x2D
0A2A:  MOVLB  0
0A2C:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "CHAY MPD");
0A2E:  MOVLW  4C
0A30:  MOVWF  FF6
0A32:  MOVLW  01
0A34:  MOVWF  FF7
0A36:  RCALL  066C
....................       clear_lcd();
0A38:  MOVLB  1
0A3A:  CLRF   x29
0A3C:  MOVLB  0
0A3E:  RCALL  06B0
....................       LCD_PUTCMD(Line_2);
0A40:  MOVLW  C0
0A42:  MOVLB  1
0A44:  MOVWF  x2D
0A46:  MOVLB  0
0A48:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "LAN: %01u", val_counter_restart_mpd);
0A4A:  MOVLW  56
0A4C:  MOVWF  FF6
0A4E:  MOVLW  01
0A50:  MOVWF  FF7
0A52:  MOVLW  05
0A54:  MOVLB  1
0A56:  MOVWF  x29
0A58:  MOVLB  0
0A5A:  RCALL  0786
0A5C:  MOVFF  58,129
0A60:  MOVLW  08
0A62:  MOVLB  1
0A64:  MOVWF  x2A
0A66:  MOVLB  0
0A68:  RCALL  07DA
....................       clear_lcd();
0A6A:  MOVLB  1
0A6C:  CLRF   x29
0A6E:  MOVLB  0
0A70:  RCALL  06B0
....................       break;
0A72:  MOVLB  1
0A74:  BRA    0AAA
....................    case 7: // error
....................       LCD_PUTCMD(Line_1);
0A76:  MOVLW  80
0A78:  MOVLB  1
0A7A:  MOVWF  x2D
0A7C:  MOVLB  0
0A7E:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "MPD LOI");
0A80:  MOVLW  60
0A82:  MOVWF  FF6
0A84:  MOVLW  01
0A86:  MOVWF  FF7
0A88:  RCALL  066C
....................       clear_lcd();
0A8A:  MOVLB  1
0A8C:  CLRF   x29
0A8E:  MOVLB  0
0A90:  RCALL  06B0
....................       LCD_PUTCMD(Line_2);
0A92:  MOVLW  C0
0A94:  MOVLB  1
0A96:  MOVWF  x2D
0A98:  MOVLB  0
0A9A:  RCALL  042A
....................       clear_lcd();
0A9C:  MOVLB  1
0A9E:  CLRF   x29
0AA0:  MOVLB  0
0AA2:  RCALL  06B0
....................       break;
0AA4:  MOVLB  1
0AA6:  BRA    0AAA
0AA8:  MOVLB  1
....................    }
0AAA:  MOVLB  0
0AAC:  RETURN 0
.................... }
.................... 
.................... void default_data(void)
.................... {
....................    timer_tri_hoan = timer_tri_hoan_md;           // LONG DELAY 1
*
0D60:  MOVFF  57,56
....................    counter_restart_mpd = counter_restart_mpd_md; // LONG SO LAN KHOI DONG LAI MPD
0D64:  MOVFF  5A,59
....................    timer_chay_lien_tuc = timer_chay_lien_tuc_md; // LONG DELAY 2
0D68:  MOVFF  5E,5D
....................    timer_tam_dung = timer_tam_dung_md;           // LONG DELAY 3
0D6C:  MOVFF  61,60
....................    timer_ktra_AC = timer_ktra_AC_md;             // LONG KT AC TIMER
0D70:  MOVFF  64,63
....................    timer_ktra_mn = timer_ktra_mn_md;             // LONG KT MN TIMER
0D74:  MOVFF  67,66
0D78:  GOTO   0F32 (RETURN)
.................... }
.................... void display_center(void)
.................... {
.................... 
....................    unsigned char menu_main[10][17] = {{""},
....................                                       {"MAT KHAU !"},
....................                                       {"TG TRI HOAN MPD"},
....................                                       {"TG CHAY LIEN TUC"},
....................                                       {"TG TAM DUNG MPD"},
....................                                       {"TG KTRA D.AP AC"},
....................                                       {"TG KTRA D.AP MPD"},
....................                                       {"SO LAN KHOI DONG"},
....................                                       {"CAI DAT MAC DINH"},
....................                                       {""}};
*
10A0:  CLRF   x7E
10A2:  CLRF   x7F
10A4:  CLRF   x80
10A6:  CLRF   x81
10A8:  CLRF   x82
10AA:  CLRF   x83
10AC:  CLRF   x84
10AE:  CLRF   x85
10B0:  CLRF   x86
10B2:  CLRF   x87
10B4:  CLRF   x88
10B6:  CLRF   x89
10B8:  CLRF   x8A
10BA:  CLRF   x8B
10BC:  CLRF   x8C
10BE:  CLRF   x8D
10C0:  CLRF   x8E
10C2:  MOVLW  4D
10C4:  MOVWF  x8F
10C6:  MOVLW  41
10C8:  MOVWF  x90
10CA:  MOVLW  54
10CC:  MOVWF  x91
10CE:  MOVLW  20
10D0:  MOVWF  x92
10D2:  MOVLW  4B
10D4:  MOVWF  x93
10D6:  MOVLW  48
10D8:  MOVWF  x94
10DA:  MOVLW  41
10DC:  MOVWF  x95
10DE:  MOVLW  55
10E0:  MOVWF  x96
10E2:  MOVLW  20
10E4:  MOVWF  x97
10E6:  MOVLW  21
10E8:  MOVWF  x98
10EA:  CLRF   x99
10EC:  CLRF   x9A
10EE:  CLRF   x9B
10F0:  CLRF   x9C
10F2:  CLRF   x9D
10F4:  CLRF   x9E
10F6:  CLRF   x9F
10F8:  MOVLW  54
10FA:  MOVWF  xA0
10FC:  MOVLW  47
10FE:  MOVWF  xA1
1100:  MOVLW  20
1102:  MOVWF  xA2
1104:  MOVLW  54
1106:  MOVWF  xA3
1108:  MOVLW  52
110A:  MOVWF  xA4
110C:  MOVLW  49
110E:  MOVWF  xA5
1110:  MOVLW  20
1112:  MOVWF  xA6
1114:  MOVLW  48
1116:  MOVWF  xA7
1118:  MOVLW  4F
111A:  MOVWF  xA8
111C:  MOVLW  41
111E:  MOVWF  xA9
1120:  MOVLW  4E
1122:  MOVWF  xAA
1124:  MOVLW  20
1126:  MOVWF  xAB
1128:  MOVLW  4D
112A:  MOVWF  xAC
112C:  MOVLW  50
112E:  MOVWF  xAD
1130:  MOVLW  44
1132:  MOVWF  xAE
1134:  CLRF   xAF
1136:  CLRF   xB0
1138:  MOVLW  54
113A:  MOVWF  xB1
113C:  MOVLW  47
113E:  MOVWF  xB2
1140:  MOVLW  20
1142:  MOVWF  xB3
1144:  MOVLW  43
1146:  MOVWF  xB4
1148:  MOVLW  48
114A:  MOVWF  xB5
114C:  MOVLW  41
114E:  MOVWF  xB6
1150:  MOVLW  59
1152:  MOVWF  xB7
1154:  MOVLW  20
1156:  MOVWF  xB8
1158:  MOVLW  4C
115A:  MOVWF  xB9
115C:  MOVLW  49
115E:  MOVWF  xBA
1160:  MOVLW  45
1162:  MOVWF  xBB
1164:  MOVLW  4E
1166:  MOVWF  xBC
1168:  MOVLW  20
116A:  MOVWF  xBD
116C:  MOVLW  54
116E:  MOVWF  xBE
1170:  MOVLW  55
1172:  MOVWF  xBF
1174:  MOVLW  43
1176:  MOVWF  xC0
1178:  CLRF   xC1
117A:  MOVLW  54
117C:  MOVWF  xC2
117E:  MOVLW  47
1180:  MOVWF  xC3
1182:  MOVLW  20
1184:  MOVWF  xC4
1186:  MOVLW  54
1188:  MOVWF  xC5
118A:  MOVLW  41
118C:  MOVWF  xC6
118E:  MOVLW  4D
1190:  MOVWF  xC7
1192:  MOVLW  20
1194:  MOVWF  xC8
1196:  MOVLW  44
1198:  MOVWF  xC9
119A:  MOVLW  55
119C:  MOVWF  xCA
119E:  MOVLW  4E
11A0:  MOVWF  xCB
11A2:  MOVLW  47
11A4:  MOVWF  xCC
11A6:  MOVLW  20
11A8:  MOVWF  xCD
11AA:  MOVLW  4D
11AC:  MOVWF  xCE
11AE:  MOVLW  50
11B0:  MOVWF  xCF
11B2:  MOVLW  44
11B4:  MOVWF  xD0
11B6:  CLRF   xD1
11B8:  CLRF   xD2
11BA:  MOVLW  54
11BC:  MOVWF  xD3
11BE:  MOVLW  47
11C0:  MOVWF  xD4
11C2:  MOVLW  20
11C4:  MOVWF  xD5
11C6:  MOVLW  4B
11C8:  MOVWF  xD6
11CA:  MOVLW  54
11CC:  MOVWF  xD7
11CE:  MOVLW  52
11D0:  MOVWF  xD8
11D2:  MOVLW  41
11D4:  MOVWF  xD9
11D6:  MOVLW  20
11D8:  MOVWF  xDA
11DA:  MOVLW  44
11DC:  MOVWF  xDB
11DE:  MOVLW  2E
11E0:  MOVWF  xDC
11E2:  MOVLW  41
11E4:  MOVWF  xDD
11E6:  MOVLW  50
11E8:  MOVWF  xDE
11EA:  MOVLW  20
11EC:  MOVWF  xDF
11EE:  MOVLW  41
11F0:  MOVWF  xE0
11F2:  MOVLW  43
11F4:  MOVWF  xE1
11F6:  CLRF   xE2
11F8:  CLRF   xE3
11FA:  MOVLW  54
11FC:  MOVWF  xE4
11FE:  MOVLW  47
1200:  MOVWF  xE5
1202:  MOVLW  20
1204:  MOVWF  xE6
1206:  MOVLW  4B
1208:  MOVWF  xE7
120A:  MOVLW  54
120C:  MOVWF  xE8
120E:  MOVLW  52
1210:  MOVWF  xE9
1212:  MOVLW  41
1214:  MOVWF  xEA
1216:  MOVLW  20
1218:  MOVWF  xEB
121A:  MOVLW  44
121C:  MOVWF  xEC
121E:  MOVLW  2E
1220:  MOVWF  xED
1222:  MOVLW  41
1224:  MOVWF  xEE
1226:  MOVLW  50
1228:  MOVWF  xEF
122A:  MOVLW  20
122C:  MOVWF  xF0
122E:  MOVLW  4D
1230:  MOVWF  xF1
1232:  MOVLW  50
1234:  MOVWF  xF2
1236:  MOVLW  44
1238:  MOVWF  xF3
123A:  CLRF   xF4
123C:  MOVLW  53
123E:  MOVWF  xF5
1240:  MOVLW  4F
1242:  MOVWF  xF6
1244:  MOVLW  20
1246:  MOVWF  xF7
1248:  MOVLW  4C
124A:  MOVWF  xF8
124C:  MOVLW  41
124E:  MOVWF  xF9
1250:  MOVLW  4E
1252:  MOVWF  xFA
1254:  MOVLW  20
1256:  MOVWF  xFB
1258:  MOVLW  4B
125A:  MOVWF  xFC
125C:  MOVLW  48
125E:  MOVWF  xFD
1260:  MOVLW  4F
1262:  MOVWF  xFE
1264:  MOVLW  49
1266:  MOVWF  xFF
1268:  MOVLW  20
126A:  MOVLB  1
126C:  MOVWF  x00
126E:  MOVLW  44
1270:  MOVWF  x01
1272:  MOVLW  4F
1274:  MOVWF  x02
1276:  MOVLW  4E
1278:  MOVWF  x03
127A:  MOVLW  47
127C:  MOVWF  x04
127E:  CLRF   x05
1280:  MOVLW  43
1282:  MOVWF  x06
1284:  MOVLW  41
1286:  MOVWF  x07
1288:  MOVLW  49
128A:  MOVWF  x08
128C:  MOVLW  20
128E:  MOVWF  x09
1290:  MOVLW  44
1292:  MOVWF  x0A
1294:  MOVLW  41
1296:  MOVWF  x0B
1298:  MOVLW  54
129A:  MOVWF  x0C
129C:  MOVLW  20
129E:  MOVWF  x0D
12A0:  MOVLW  4D
12A2:  MOVWF  x0E
12A4:  MOVLW  41
12A6:  MOVWF  x0F
12A8:  MOVLW  43
12AA:  MOVWF  x10
12AC:  MOVLW  20
12AE:  MOVWF  x11
12B0:  MOVLW  44
12B2:  MOVWF  x12
12B4:  MOVLW  49
12B6:  MOVWF  x13
12B8:  MOVLW  4E
12BA:  MOVWF  x14
12BC:  MOVLW  48
12BE:  MOVWF  x15
12C0:  CLRF   x16
12C2:  CLRF   x17
.................... 
....................    if (refresh_menu)
12C4:  BTFSS  52.0
12C6:  BRA    1304
....................    {
....................       LCD_PUTCMD(Line_1); // Dua hien thi chu dau dong hang` duoi
12C8:  MOVLW  80
12CA:  MOVWF  x2D
12CC:  MOVLB  0
12CE:  CALL   042A
....................       PRINTF(LCD_PUTCHAR, "%s", menu_main[mode]);
12D2:  MOVF   50,W
12D4:  MULLW  11
12D6:  MOVF   FF3,W
12D8:  CLRF   03
12DA:  ADDLW  7E
12DC:  MOVWF  01
12DE:  MOVLW  00
12E0:  ADDWFC 03,F
12E2:  MOVFF  01,128
12E6:  MOVFF  03,129
12EA:  MOVFF  03,FEA
12EE:  MOVFF  01,FE9
12F2:  MOVLB  0
12F4:  CALL   068C
....................       clear_lcd();
12F8:  MOVLB  1
12FA:  CLRF   x29
12FC:  MOVLB  0
12FE:  CALL   06B0
1302:  MOVLB  1
....................    }
....................    LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
1304:  MOVLW  C0
1306:  MOVWF  x2D
1308:  MOVLB  0
130A:  CALL   042A
.................... 
....................    switch (mode)
130E:  MOVF   50,W
1310:  ADDLW  F6
1312:  BTFSC  FD8.0
1314:  BRA    1594
1316:  ADDLW  0A
1318:  GOTO   15CA
....................    {
....................    case 0: // LCD TINH NANG CHINH
....................       switch (state_AC)
131C:  MOVF   4F,W
131E:  ADDLW  F5
1320:  BC    137C
1322:  ADDLW  0B
1324:  GOTO   159A
....................       {
....................       case 0:
....................          display(do_ac);
1328:  MOVLW  04
132A:  MOVLB  1
132C:  MOVWF  x28
132E:  MOVLB  0
1330:  CALL   0856
....................          break;
1334:  BRA    137C
....................       case 1:
....................          display(ac_bthg);
1336:  MOVLW  05
1338:  MOVLB  1
133A:  MOVWF  x28
133C:  MOVLB  0
133E:  CALL   0856
....................          break;
1342:  BRA    137C
....................       case 2:
....................          display(tg_tri_hoan);
1344:  MOVLW  01
1346:  MOVLB  1
1348:  MOVWF  x28
134A:  MOVLB  0
134C:  CALL   0856
....................          break;
1350:  BRA    137C
....................       case 3:
....................          break;
1352:  BRA    137C
....................       case 4:
....................          display(tg_chay_lien_tuc);
1354:  MOVLW  02
1356:  MOVLB  1
1358:  MOVWF  x28
135A:  MOVLB  0
135C:  CALL   0856
....................          break;
1360:  BRA    137C
....................       case 5:
....................          display(tg_tam_dung);
1362:  MOVLW  03
1364:  MOVLB  1
1366:  MOVWF  x28
1368:  MOVLB  0
136A:  CALL   0856
....................          break;
136E:  BRA    137C
....................       case 10:
....................          display(error);
1370:  MOVLW  07
1372:  MOVLB  1
1374:  MOVWF  x28
1376:  MOVLB  0
1378:  CALL   0856
....................          break;
....................       }
....................       break;
137C:  BRA    1594
....................    case 1:                // nhap mat khau
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
137E:  MOVLW  C0
1380:  MOVLB  1
1382:  MOVWF  x2D
1384:  MOVLB  0
1386:  CALL   042A
....................       sch_1 = str_temp;
138A:  CLRF   2B
138C:  MOVLW  35
138E:  MOVWF  2A
....................       sch_1_s_set();
1390:  MOVLW  0B
1392:  MOVLB  1
1394:  MOVWF  x29
1396:  MOVLB  0
1398:  CALL   06B0
....................       break;
139C:  BRA    1594
.................... 
....................    case 2:                // TG TRI HOAN MPD
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
139E:  MOVLW  C0
13A0:  MOVLB  1
13A2:  MOVWF  x2D
13A4:  MOVLB  0
13A6:  CALL   042A
....................       PRINTF(LCD_PUTCHAR, "PHUT: <%01u>", timer_tri_hoan);
13AA:  MOVLW  68
13AC:  MOVWF  FF6
13AE:  MOVLW  01
13B0:  MOVWF  FF7
13B2:  MOVLW  07
13B4:  MOVLB  1
13B6:  MOVWF  x29
13B8:  MOVLB  0
13BA:  CALL   0786
13BE:  MOVFF  56,129
13C2:  MOVLW  08
13C4:  MOVLB  1
13C6:  MOVWF  x2A
13C8:  MOVLB  0
13CA:  CALL   07DA
13CE:  MOVLW  3E
13D0:  MOVLB  1
13D2:  MOVWF  x2C
13D4:  MOVLB  0
13D6:  CALL   065C
....................       clear_lcd();
13DA:  MOVLB  1
13DC:  CLRF   x29
13DE:  MOVLB  0
13E0:  CALL   06B0
....................       break;
13E4:  BRA    1594
.................... 
....................    case 3:                // TG CHAY LIEN TUC
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
13E6:  MOVLW  C0
13E8:  MOVLB  1
13EA:  MOVWF  x2D
13EC:  MOVLB  0
13EE:  CALL   042A
....................       PRINTF(LCD_PUTCHAR, "GIO: <%01u>", timer_chay_lien_tuc);
13F2:  MOVLW  76
13F4:  MOVWF  FF6
13F6:  MOVLW  01
13F8:  MOVWF  FF7
13FA:  MOVLW  06
13FC:  MOVLB  1
13FE:  MOVWF  x29
1400:  MOVLB  0
1402:  CALL   0786
1406:  MOVFF  5D,129
140A:  MOVLW  08
140C:  MOVLB  1
140E:  MOVWF  x2A
1410:  MOVLB  0
1412:  CALL   07DA
1416:  MOVLW  3E
1418:  MOVLB  1
141A:  MOVWF  x2C
141C:  MOVLB  0
141E:  CALL   065C
....................       clear_lcd();
1422:  MOVLB  1
1424:  CLRF   x29
1426:  MOVLB  0
1428:  CALL   06B0
....................       break;
142C:  BRA    1594
.................... 
....................    case 4:                // TG TAM DUNG MPD
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
142E:  MOVLW  C0
1430:  MOVLB  1
1432:  MOVWF  x2D
1434:  MOVLB  0
1436:  CALL   042A
....................       PRINTF(LCD_PUTCHAR, "PHUT: <%01u>", timer_tam_dung);
143A:  MOVLW  82
143C:  MOVWF  FF6
143E:  MOVLW  01
1440:  MOVWF  FF7
1442:  MOVLW  07
1444:  MOVLB  1
1446:  MOVWF  x29
1448:  MOVLB  0
144A:  CALL   0786
144E:  MOVFF  60,129
1452:  MOVLW  08
1454:  MOVLB  1
1456:  MOVWF  x2A
1458:  MOVLB  0
145A:  CALL   07DA
145E:  MOVLW  3E
1460:  MOVLB  1
1462:  MOVWF  x2C
1464:  MOVLB  0
1466:  CALL   065C
....................       clear_lcd();
146A:  MOVLB  1
146C:  CLRF   x29
146E:  MOVLB  0
1470:  CALL   06B0
....................       break;
1474:  BRA    1594
....................    case 5:                // TG KTRA DA AC
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
1476:  MOVLW  C0
1478:  MOVLB  1
147A:  MOVWF  x2D
147C:  MOVLB  0
147E:  CALL   042A
....................       PRINTF(LCD_PUTCHAR, "GIAY: <%01u>", timer_ktra_AC);
1482:  MOVLW  90
1484:  MOVWF  FF6
1486:  MOVLW  01
1488:  MOVWF  FF7
148A:  MOVLW  07
148C:  MOVLB  1
148E:  MOVWF  x29
1490:  MOVLB  0
1492:  CALL   0786
1496:  MOVFF  63,129
149A:  MOVLW  08
149C:  MOVLB  1
149E:  MOVWF  x2A
14A0:  MOVLB  0
14A2:  CALL   07DA
14A6:  MOVLW  3E
14A8:  MOVLB  1
14AA:  MOVWF  x2C
14AC:  MOVLB  0
14AE:  CALL   065C
....................       clear_lcd();
14B2:  MOVLB  1
14B4:  CLRF   x29
14B6:  MOVLB  0
14B8:  CALL   06B0
....................       break;
14BC:  BRA    1594
....................    case 6:                // TG KTRA DA MN
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
14BE:  MOVLW  C0
14C0:  MOVLB  1
14C2:  MOVWF  x2D
14C4:  MOVLB  0
14C6:  CALL   042A
....................       PRINTF(LCD_PUTCHAR, "GIAY: <%01u>", timer_ktra_mn);
14CA:  MOVLW  9E
14CC:  MOVWF  FF6
14CE:  MOVLW  01
14D0:  MOVWF  FF7
14D2:  MOVLW  07
14D4:  MOVLB  1
14D6:  MOVWF  x29
14D8:  MOVLB  0
14DA:  CALL   0786
14DE:  MOVFF  66,129
14E2:  MOVLW  08
14E4:  MOVLB  1
14E6:  MOVWF  x2A
14E8:  MOVLB  0
14EA:  CALL   07DA
14EE:  MOVLW  3E
14F0:  MOVLB  1
14F2:  MOVWF  x2C
14F4:  MOVLB  0
14F6:  CALL   065C
....................       clear_lcd();
14FA:  MOVLB  1
14FC:  CLRF   x29
14FE:  MOVLB  0
1500:  CALL   06B0
....................       break;
1504:  BRA    1594
....................    case 7:                // SO LAN KHOI DONG
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
1506:  MOVLW  C0
1508:  MOVLB  1
150A:  MOVWF  x2D
150C:  MOVLB  0
150E:  CALL   042A
....................       PRINTF(LCD_PUTCHAR, "LAN: <%01u>", counter_restart_mpd);
1512:  MOVLW  AC
1514:  MOVWF  FF6
1516:  MOVLW  01
1518:  MOVWF  FF7
151A:  MOVLW  06
151C:  MOVLB  1
151E:  MOVWF  x29
1520:  MOVLB  0
1522:  CALL   0786
1526:  MOVFF  59,129
152A:  MOVLW  08
152C:  MOVLB  1
152E:  MOVWF  x2A
1530:  MOVLB  0
1532:  CALL   07DA
1536:  MOVLW  3E
1538:  MOVLB  1
153A:  MOVWF  x2C
153C:  MOVLB  0
153E:  CALL   065C
....................       clear_lcd();
1542:  MOVLB  1
1544:  CLRF   x29
1546:  MOVLB  0
1548:  CALL   06B0
....................       break;
154C:  BRA    1594
....................    case 8: // cai dat mat dinh
....................       yesno();
154E:  MOVLW  09
1550:  MOVLB  1
1552:  MOVWF  x29
1554:  MOVLB  0
1556:  CALL   06B0
....................       break;
155A:  BRA    1594
....................    case 9:
....................       LCD_PUTCMD(Line_1);
155C:  MOVLW  80
155E:  MOVLB  1
1560:  MOVWF  x2D
1562:  MOVLB  0
1564:  CALL   042A
....................       loading();
1568:  MOVLW  0A
156A:  MOVLB  1
156C:  MOVWF  x29
156E:  MOVLB  0
1570:  CALL   06B0
....................       clear_lcd();
1574:  MOVLB  1
1576:  CLRF   x29
1578:  MOVLB  0
157A:  CALL   06B0
....................       LCD_PUTCMD(Line_2);
157E:  MOVLW  C0
1580:  MOVLB  1
1582:  MOVWF  x2D
1584:  MOVLB  0
1586:  CALL   042A
....................       clear_lcd();
158A:  MOVLB  1
158C:  CLRF   x29
158E:  MOVLB  0
1590:  CALL   06B0
....................       break;
....................    }
....................    refresh_menu = 0; // cap nhat du lieu mang hinh xong
1594:  BCF    52.0
1596:  GOTO   18DC (RETURN)
.................... }
.................... 
.................... //=========================
.................... void reset_timer_data(void)
.................... {
....................    val_timer_tri_hoan = timer_tri_hoan;
*
0628:  MOVFF  56,55
....................    val_counter_restart_mpd = 1;
062C:  MOVLW  01
062E:  MOVWF  58
....................    counter_restart_mpd_current = counter_restart_mpd;
0630:  MOVFF  59,5B
....................    val_timer_chay_lien_tuc = timer_chay_lien_tuc;
0634:  MOVFF  5D,5C
....................    val_timer_tam_dung = timer_tam_dung;
0638:  MOVFF  60,5F
....................    val_timer_on_mpd = timer_on_mpd;
063C:  MOVFF  69,68
....................    val_timer_off_mpd = timer_off_mpd;
0640:  MOVFF  6B,6A
....................    val_timer_ktra_mn = timer_ktra_mn;
0644:  MOVFF  66,65
....................    state_mn = 0;
0648:  CLRF   51
....................    flag_timer_tri_hoan_60s = 60, flag_timer_chay_lien_tuc_3600s = 3600, flag_timer_tam_dung_60s = 60;
064A:  MOVLW  3C
064C:  MOVWF  x73
064E:  MOVLW  0E
0650:  MOVWF  x72
0652:  MOVLW  10
0654:  MOVWF  x71
0656:  MOVLW  3C
0658:  MOVWF  x75
065A:  RETURN 0
.................... }
.................... 
.................... void lcd_printf(char code_printf)
.................... {
....................    switch (code_printf)
*
06B0:  MOVLB  1
06B2:  MOVF   x29,W
06B4:  XORLW  00
06B6:  MOVLB  0
06B8:  BZ    06C8
06BA:  XORLW  09
06BC:  BZ    06D4
06BE:  XORLW  03
06C0:  BZ    06E0
06C2:  XORLW  01
06C4:  BZ    074A
06C6:  BRA    075E
....................    {
....................    case 0:
....................       PRINTF(LCD_PUTCHAR, "                 ");
06C8:  MOVLW  B8
06CA:  MOVWF  FF6
06CC:  MOVLW  01
06CE:  MOVWF  FF7
06D0:  RCALL  066C
....................       break;
06D2:  BRA    075E
.................... 
....................    case 9:
....................       PRINTF(LCD_PUTCHAR, "  <YES || NO>");
06D4:  MOVLW  CA
06D6:  MOVWF  FF6
06D8:  MOVLW  01
06DA:  MOVWF  FF7
06DC:  RCALL  066C
....................       break;
06DE:  BRA    075E
.................... 
....................    case 10:
.................... 
....................       if (++val_loading > 5)
06E0:  INCF   x6C,F
06E2:  MOVF   x6C,W
06E4:  SUBLW  05
06E6:  BC    06EC
....................       {
....................          val_loading = 0;
06E8:  CLRF   x6C
....................          mode = 0;
06EA:  CLRF   50
....................       }
....................       PRINTF(LCD_PUTCHAR, "Loading ");
06EC:  MOVLW  D8
06EE:  MOVWF  FF6
06F0:  MOVLW  01
06F2:  MOVWF  FF7
06F4:  RCALL  066C
....................       switch (val_loading)
06F6:  MOVF   x6C,W
06F8:  ADDLW  FA
06FA:  BC    0748
06FC:  ADDLW  06
06FE:  GOTO   0760
....................       {
....................       case 0:
....................          PRINTF(LCD_PUTCHAR, ".  ");
0702:  MOVLW  E2
0704:  MOVWF  FF6
0706:  MOVLW  01
0708:  MOVWF  FF7
070A:  RCALL  066C
....................          break;
070C:  BRA    0748
.................... 
....................       case 1:
....................          PRINTF(LCD_PUTCHAR, ".. ");
070E:  MOVLW  E6
0710:  MOVWF  FF6
0712:  MOVLW  01
0714:  MOVWF  FF7
0716:  RCALL  066C
....................          break;
0718:  BRA    0748
.................... 
....................       case 2:
....................          PRINTF(LCD_PUTCHAR, "...");
071A:  MOVLW  EA
071C:  MOVWF  FF6
071E:  MOVLW  01
0720:  MOVWF  FF7
0722:  RCALL  066C
....................          break;
0724:  BRA    0748
.................... 
....................       case 3:
....................          PRINTF(LCD_PUTCHAR, " ..");
0726:  MOVLW  EE
0728:  MOVWF  FF6
072A:  MOVLW  01
072C:  MOVWF  FF7
072E:  RCALL  066C
....................          break;
0730:  BRA    0748
.................... 
....................       case 4:
....................          PRINTF(LCD_PUTCHAR, "  .");
0732:  MOVLW  F2
0734:  MOVWF  FF6
0736:  MOVLW  01
0738:  MOVWF  FF7
073A:  RCALL  066C
....................          break;
073C:  BRA    0748
.................... 
....................       case 5:
....................          PRINTF(LCD_PUTCHAR, "   ");
073E:  MOVLW  F6
0740:  MOVWF  FF6
0742:  MOVLW  01
0744:  MOVWF  FF7
0746:  RCALL  066C
....................          break;
....................       }
....................       break;
0748:  BRA    075E
.................... 
....................    case 11:
....................       PRINTF(LCD_PUTCHAR, "%s<", sch_1);
074A:  MOVFF  2B,FEA
074E:  MOVFF  2A,FE9
0752:  RCALL  068C
0754:  MOVLW  3C
0756:  MOVLB  1
0758:  MOVWF  x2C
075A:  MOVLB  0
075C:  RCALL  065C
....................       break;
....................    }
075E:  RETURN 0
.................... }
.................... //=======================================
.................... char key_scan(void)
*
0B0A:  CLRF   x7F
0B0C:  MOVLW  C8
0B0E:  MOVWF  x7E
.................... {
....................    unsigned long bounce = 200;
.................... 
....................    if (val_mode() == 1)
0B10:  BSF    F92.3
0B12:  BTFSC  F80.3
0B14:  BRA    0B60
....................    {
....................       while (bounce--)
0B16:  MOVFF  7F,03
0B1A:  MOVF   x7E,W
0B1C:  BTFSC  FD8.2
0B1E:  DECF   x7F,F
0B20:  DECF   x7E,F
0B22:  IORWF  03,W
0B24:  BZ    0B34
....................       {
....................          if (val_mode() == 0)
0B26:  BSF    F92.3
0B28:  BTFSS  F80.3
0B2A:  BRA    0B32
....................             return 0x00;
0B2C:  MOVLW  00
0B2E:  MOVWF  01
0B30:  BRA    0C34
0B32:  BRA    0B16
....................       }
....................       bounce = 1024;
0B34:  MOVLW  04
0B36:  MOVWF  x7F
0B38:  CLRF   x7E
....................       while (bounce--)
0B3A:  MOVFF  7F,03
0B3E:  MOVF   x7E,W
0B40:  BTFSC  FD8.2
0B42:  DECF   x7F,F
0B44:  DECF   x7E,F
0B46:  IORWF  03,W
0B48:  BZ    0B58
....................       {
....................          if (val_mode() == 0)
0B4A:  BSF    F92.3
0B4C:  BTFSS  F80.3
0B4E:  BRA    0B56
....................             return 0x01;
0B50:  MOVLW  01
0B52:  MOVWF  01
0B54:  BRA    0C34
0B56:  BRA    0B3A
....................       }
....................       return 0x01;
0B58:  MOVLW  01
0B5A:  MOVWF  01
0B5C:  BRA    0C34
....................    }
0B5E:  BRA    0C30
.................... 
....................    else if (val_up() == 1)
0B60:  BSF    F92.2
0B62:  BTFSC  F80.2
0B64:  BRA    0BB0
....................    {
....................       while (bounce--)
0B66:  MOVFF  7F,03
0B6A:  MOVF   x7E,W
0B6C:  BTFSC  FD8.2
0B6E:  DECF   x7F,F
0B70:  DECF   x7E,F
0B72:  IORWF  03,W
0B74:  BZ    0B84
....................       {
....................          if (val_up() == 0)
0B76:  BSF    F92.2
0B78:  BTFSS  F80.2
0B7A:  BRA    0B82
....................             return 0x00;
0B7C:  MOVLW  00
0B7E:  MOVWF  01
0B80:  BRA    0C34
0B82:  BRA    0B66
....................       }
....................       bounce = 256;
0B84:  MOVLW  01
0B86:  MOVWF  x7F
0B88:  CLRF   x7E
....................       while (bounce--)
0B8A:  MOVFF  7F,03
0B8E:  MOVF   x7E,W
0B90:  BTFSC  FD8.2
0B92:  DECF   x7F,F
0B94:  DECF   x7E,F
0B96:  IORWF  03,W
0B98:  BZ    0BA8
....................       {
....................          if (val_up() == 0)
0B9A:  BSF    F92.2
0B9C:  BTFSS  F80.2
0B9E:  BRA    0BA6
....................             return 0x02;
0BA0:  MOVLW  02
0BA2:  MOVWF  01
0BA4:  BRA    0C34
0BA6:  BRA    0B8A
....................       }
....................       return 0x02;
0BA8:  MOVLW  02
0BAA:  MOVWF  01
0BAC:  BRA    0C34
....................    }
0BAE:  BRA    0C30
.................... 
....................    else if (val_down() == 1)
0BB0:  BSF    F92.1
0BB2:  BTFSC  F80.1
0BB4:  BRA    0C00
....................    {
....................       while (bounce--)
0BB6:  MOVFF  7F,03
0BBA:  MOVF   x7E,W
0BBC:  BTFSC  FD8.2
0BBE:  DECF   x7F,F
0BC0:  DECF   x7E,F
0BC2:  IORWF  03,W
0BC4:  BZ    0BD4
....................       {
....................          if (val_down() == 0)
0BC6:  BSF    F92.1
0BC8:  BTFSS  F80.1
0BCA:  BRA    0BD2
....................             return 0x00;
0BCC:  MOVLW  00
0BCE:  MOVWF  01
0BD0:  BRA    0C34
0BD2:  BRA    0BB6
....................       }
....................       bounce = 256;
0BD4:  MOVLW  01
0BD6:  MOVWF  x7F
0BD8:  CLRF   x7E
....................       while (bounce--)
0BDA:  MOVFF  7F,03
0BDE:  MOVF   x7E,W
0BE0:  BTFSC  FD8.2
0BE2:  DECF   x7F,F
0BE4:  DECF   x7E,F
0BE6:  IORWF  03,W
0BE8:  BZ    0BF8
....................       {
....................          if (val_down() == 0)
0BEA:  BSF    F92.1
0BEC:  BTFSS  F80.1
0BEE:  BRA    0BF6
....................             return 0x03;
0BF0:  MOVLW  03
0BF2:  MOVWF  01
0BF4:  BRA    0C34
0BF6:  BRA    0BDA
....................       }
....................       return 0x03;
0BF8:  MOVLW  03
0BFA:  MOVWF  01
0BFC:  BRA    0C34
....................    }
0BFE:  BRA    0C30
.................... 
....................    else if (val_exit() == 1)
0C00:  BSF    F92.0
0C02:  BTFSC  F80.0
0C04:  BRA    0C30
....................    {
....................       while (bounce--)
0C06:  MOVFF  7F,03
0C0A:  MOVF   x7E,W
0C0C:  BTFSC  FD8.2
0C0E:  DECF   x7F,F
0C10:  DECF   x7E,F
0C12:  IORWF  03,W
0C14:  BZ    0C24
....................       {
....................          if (val_exit() == 0)
0C16:  BSF    F92.0
0C18:  BTFSS  F80.0
0C1A:  BRA    0C22
....................             return 0x00;
0C1C:  MOVLW  00
0C1E:  MOVWF  01
0C20:  BRA    0C34
0C22:  BRA    0C06
....................       }
....................       while (val_exit() == 0)
0C24:  BSF    F92.0
0C26:  BTFSC  F80.0
0C28:  BRA    0C24
....................          ;
....................       return 0x04;
0C2A:  MOVLW  04
0C2C:  MOVWF  01
0C2E:  BRA    0C34
....................    }
....................    return 0x00;
0C30:  MOVLW  00
0C32:  MOVWF  01
0C34:  GOTO   180E (RETURN)
.................... }
.................... 
.................... //=========================
.................... void process_menu(void)
.................... {
....................    refresh_menu = 1;
*
0CE2:  BSF    52.0
....................    loop_not_display = 1;
0CE4:  MOVLW  01
0CE6:  MOVWF  x79
....................    switch (mode)
0CE8:  MOVF   50,W
0CEA:  XORLW  01
0CEC:  BZ    0CF0
0CEE:  BRA    0D44
....................    {
....................    case 1:
....................       if (strlen(str_temp) == strlen(password))
0CF0:  CLRF   x81
0CF2:  MOVLW  35
0CF4:  MOVWF  x80
0CF6:  RCALL  0C38
0CF8:  MOVFF  02,7F
0CFC:  MOVFF  01,7E
0D00:  CLRF   x81
0D02:  MOVLW  30
0D04:  MOVWF  x80
0D06:  RCALL  0C38
0D08:  MOVFF  02,03
0D0C:  MOVF   01,W
0D0E:  SUBWF  x7E,W
0D10:  BNZ   0D30
0D12:  MOVF   03,W
0D14:  SUBWF  x7F,W
0D16:  BNZ   0D30
....................       {
....................          if (strcmp(password, str_temp) == 0)
0D18:  CLRF   x7F
0D1A:  MOVLW  30
0D1C:  MOVWF  x7E
0D1E:  CLRF   x81
0D20:  MOVLW  35
0D22:  MOVWF  x80
0D24:  BRA    0C6C
0D26:  MOVF   01,F
0D28:  BNZ   0D30
....................          {
....................             mode++;
0D2A:  INCF   50,F
....................             time_reset_password = 20; // 4   phut
0D2C:  MOVLW  14
0D2E:  MOVWF  4E
....................          }
....................       }
....................       val_sch_1 = 0;
0D30:  CLRF   2E
....................       sch_1 = str_temp;
0D32:  CLRF   2B
0D34:  MOVLW  35
0D36:  MOVWF  2A
....................       *sch_1 = 0;
0D38:  MOVFF  2A,FE9
0D3C:  MOVFF  2B,FEA
0D40:  CLRF   FEF
....................       break;
0D42:  BRA    0D5C
.................... 
....................    default:
....................       if (++mode > 8)
0D44:  INCF   50,F
0D46:  MOVF   50,W
0D48:  SUBLW  08
0D4A:  BC    0D50
....................          mode = 9; // ve loading screen
0D4C:  MOVLW  09
0D4E:  MOVWF  50
....................       if (time_reset_password != 0 && mode == 1)
0D50:  MOVF   4E,F
0D52:  BZ    0D5C
0D54:  DECFSZ 50,W
0D56:  BRA    0D5C
....................          mode = 2;
0D58:  MOVLW  02
0D5A:  MOVWF  50
....................       break;
....................    }
0D5C:  GOTO   182C (RETURN)
.................... }
.................... 
.................... //=========================
.................... void process_up(void)
.................... {
....................    switch (mode)
*
0E7C:  MOVF   50,W
0E7E:  ADDLW  F7
0E80:  BC    0F36
0E82:  ADDLW  09
0E84:  GOTO   0F3A
....................    {
....................    case 0: // mang hinh chinh
....................       break;
0E88:  BRA    0F36
.................... 
....................    case 1: // nhap mat khau
....................       sch_2 = val_number_defaul;
0E8A:  CLRF   2D
0E8C:  MOVLW  1F
0E8E:  MOVWF  2C
....................       if (++val_sch_2 > 10)
0E90:  INCF   2F,F
0E92:  MOVF   2F,W
0E94:  SUBLW  0A
0E96:  BC    0E9A
....................          val_sch_2 = 0;
0E98:  CLRF   2F
....................       sch_2 = sch_2 + val_sch_2;
0E9A:  MOVF   2F,W
0E9C:  ADDWF  2C,F
0E9E:  MOVLW  00
0EA0:  ADDWFC 2D,F
....................       sch_1 = sch_1 + val_sch_1;
0EA2:  MOVF   2E,W
0EA4:  ADDWF  2A,F
0EA6:  MOVLW  00
0EA8:  ADDWFC 2B,F
....................       *sch_1++ = *sch_2;
0EAA:  MOVFF  2B,7F
0EAE:  MOVF   2A,W
0EB0:  INCF   2A,F
0EB2:  BTFSC  FD8.2
0EB4:  INCF   2B,F
0EB6:  MOVFF  2C,FE9
0EBA:  MOVFF  2D,FEA
0EBE:  MOVFF  FEF,80
0EC2:  MOVFF  7F,FEA
0EC6:  MOVWF  FE9
0EC8:  MOVFF  80,FEF
....................       *sch_1 = 0;
0ECC:  MOVFF  2A,FE9
0ED0:  MOVFF  2B,FEA
0ED4:  CLRF   FEF
....................       break;
0ED6:  BRA    0F36
.................... 
....................    case 2: // TG TRI HOAN
....................       if (++timer_tri_hoan > 254)
0ED8:  INCF   56,F
0EDA:  MOVF   56,W
0EDC:  SUBLW  FE
0EDE:  BC    0EE4
....................       {
....................          timer_tri_hoan = 1;
0EE0:  MOVLW  01
0EE2:  MOVWF  56
....................       }
....................       break;
0EE4:  BRA    0F36
....................    case 3: // TG CHAY LIEN TUC
....................       if (++timer_chay_lien_tuc > 24)
0EE6:  INCF   5D,F
0EE8:  MOVF   5D,W
0EEA:  SUBLW  18
0EEC:  BC    0EF2
....................       {
....................          timer_chay_lien_tuc = 1;
0EEE:  MOVLW  01
0EF0:  MOVWF  5D
....................       }
....................       break;
0EF2:  BRA    0F36
.................... 
....................    case 4: // TG TAM DUNG MPD
....................       if (++timer_tam_dung > 254)
0EF4:  INCF   x60,F
0EF6:  MOVF   x60,W
0EF8:  SUBLW  FE
0EFA:  BC    0F00
....................       {
....................          timer_tam_dung = 1;
0EFC:  MOVLW  01
0EFE:  MOVWF  x60
....................       }
....................       break;
0F00:  BRA    0F36
.................... 
....................    case 5: // TG KTRA DA AC
....................       if (++timer_ktra_AC > 240)
0F02:  INCF   x63,F
0F04:  MOVF   x63,W
0F06:  SUBLW  F0
0F08:  BC    0F0E
....................       {
....................          timer_ktra_AC = 10;
0F0A:  MOVLW  0A
0F0C:  MOVWF  x63
....................       }
....................       break;
0F0E:  BRA    0F36
.................... 
....................    case 6: // TG KTRA DA MN
....................       if (++timer_ktra_mn > 240)
0F10:  INCF   x66,F
0F12:  MOVF   x66,W
0F14:  SUBLW  F0
0F16:  BC    0F1C
....................       {
....................          timer_ktra_mn = 10;
0F18:  MOVLW  0A
0F1A:  MOVWF  x66
....................       }
....................       break;
0F1C:  BRA    0F36
.................... 
....................    case 7: // SO LAN KHOI DONG
....................       if (++counter_restart_mpd > 4)
0F1E:  INCF   59,F
0F20:  MOVF   59,W
0F22:  SUBLW  04
0F24:  BC    0F2A
....................       {
....................          counter_restart_mpd = 2;
0F26:  MOVLW  02
0F28:  MOVWF  59
....................       }
....................       break;
0F2A:  BRA    0F36
....................    case 8:      // cai dat mat dinh
....................       mode = 9; // ve loading screen
0F2C:  MOVLW  09
0F2E:  MOVWF  50
....................       default_data();
0F30:  BRA    0D60
....................       write_data();
0F32:  RCALL  0D7C
....................       reset_cpu();
0F34:  RESET
....................       break;
....................    }
0F36:  GOTO   1846 (RETURN)
.................... }
.................... 
.................... //=========================
.................... void process_down(void)
.................... {
....................    switch (mode)
*
0F66:  MOVF   50,W
0F68:  ADDLW  F7
0F6A:  BC    1010
0F6C:  ADDLW  09
0F6E:  GOTO   1014
....................    {
....................    case 0: // mang hinh chinh
....................       break;
0F72:  BRA    1010
.................... 
....................    case 1: // nhap mat khau
....................       sch_2 = val_number_defaul;
0F74:  CLRF   2D
0F76:  MOVLW  1F
0F78:  MOVWF  2C
....................       if (--val_sch_2 > 10)
0F7A:  DECF   2F,F
0F7C:  MOVF   2F,W
0F7E:  SUBLW  0A
0F80:  BC    0F86
....................          val_sch_2 = 10;
0F82:  MOVLW  0A
0F84:  MOVWF  2F
....................       sch_2 = sch_2 + val_sch_2;
0F86:  MOVF   2F,W
0F88:  ADDWF  2C,F
0F8A:  MOVLW  00
0F8C:  ADDWFC 2D,F
....................       sch_1 = sch_1 + val_sch_1;
0F8E:  MOVF   2E,W
0F90:  ADDWF  2A,F
0F92:  MOVLW  00
0F94:  ADDWFC 2B,F
....................       *sch_1++ = *sch_2;
0F96:  MOVFF  2B,7F
0F9A:  MOVF   2A,W
0F9C:  INCF   2A,F
0F9E:  BTFSC  FD8.2
0FA0:  INCF   2B,F
0FA2:  MOVFF  2C,FE9
0FA6:  MOVFF  2D,FEA
0FAA:  MOVFF  FEF,80
0FAE:  MOVFF  7F,FEA
0FB2:  MOVWF  FE9
0FB4:  MOVFF  80,FEF
....................       *sch_1 = 0;
0FB8:  MOVFF  2A,FE9
0FBC:  MOVFF  2B,FEA
0FC0:  CLRF   FEF
....................       break;
0FC2:  BRA    1010
.................... 
....................    case 2: // TG TRI HOAN
....................       if (--timer_tri_hoan < 1)
0FC4:  DECFSZ 56,F
0FC6:  BRA    0FCC
....................       {
....................          timer_tri_hoan = 254;
0FC8:  MOVLW  FE
0FCA:  MOVWF  56
....................       }
....................       break;
0FCC:  BRA    1010
.................... 
....................    case 3: // TG CHAY LIEN TUC
....................       if (--timer_chay_lien_tuc < 1)
0FCE:  DECFSZ 5D,F
0FD0:  BRA    0FD6
....................       {
....................          timer_chay_lien_tuc = 24;
0FD2:  MOVLW  18
0FD4:  MOVWF  5D
....................       }
....................       break;
0FD6:  BRA    1010
.................... 
....................    case 4: // TG TAM DUNG MPD
....................       if (--timer_tam_dung < 1)
0FD8:  DECFSZ x60,F
0FDA:  BRA    0FE0
....................       {
....................          timer_tam_dung = 254;
0FDC:  MOVLW  FE
0FDE:  MOVWF  x60
....................       }
....................       break;
0FE0:  BRA    1010
.................... 
....................    case 5: // TG KTRA DA AC
....................       if (--timer_ktra_AC < 10)
0FE2:  DECF   x63,F
0FE4:  MOVF   x63,W
0FE6:  SUBLW  09
0FE8:  BNC   0FEE
....................       {
....................          timer_ktra_AC = 240;
0FEA:  MOVLW  F0
0FEC:  MOVWF  x63
....................       }
....................       break;
0FEE:  BRA    1010
.................... 
....................    case 6: // TG KTRA DA MN
....................       if (--timer_ktra_mn < 10)
0FF0:  DECF   x66,F
0FF2:  MOVF   x66,W
0FF4:  SUBLW  09
0FF6:  BNC   0FFC
....................       {
....................          timer_ktra_mn = 240;
0FF8:  MOVLW  F0
0FFA:  MOVWF  x66
....................       }
....................       break;
0FFC:  BRA    1010
.................... 
....................    case 7: // SO LAN KHOI DONG
....................       if (--counter_restart_mpd < 2)
0FFE:  DECF   59,F
1000:  MOVF   59,W
1002:  SUBLW  01
1004:  BNC   100A
....................       {
....................          counter_restart_mpd = 4;
1006:  MOVLW  04
1008:  MOVWF  59
....................       }
....................       break;
100A:  BRA    1010
....................    case 8:      // cai dat mat dinh
....................       mode = 9; // ve loading screen
100C:  MOVLW  09
100E:  MOVWF  50
....................       break;
....................    }
1010:  GOTO   1870 (RETURN)
.................... }
.................... 
.................... //=========================
.................... void process_exit(void)
.................... {
.................... 
....................    char val_null;
....................    val_sch_2 = 0;
*
1040:  CLRF   2F
....................    loop_not_display = 1;
1042:  MOVLW  01
1044:  MOVWF  x79
....................    switch (mode)
1046:  MOVF   50,W
1048:  BZ    1050
104A:  XORLW  01
104C:  BZ    1054
104E:  BRA    109C
....................    {
....................    case 0: // mang hinh chinh
....................       time_reset_password = 0;
1050:  CLRF   4E
....................       break;
1052:  BRA    109C
.................... 
....................    case 1: // nhap mat khau
....................       sch_1 = sch_1 + val_sch_1;
1054:  MOVF   2E,W
1056:  ADDWF  2A,F
1058:  MOVLW  00
105A:  ADDWFC 2B,F
....................       val_null = *sch_1;
105C:  MOVFF  2A,FE9
1060:  MOVFF  2B,FEA
1064:  MOVFF  FEF,7E
....................       if (val_null != 0 && val_null != 0XFF)
1068:  MOVF   x7E,F
106A:  BZ    109C
106C:  INCFSZ x7E,W
106E:  BRA    1072
1070:  BRA    109C
....................       {
....................          if (++val_sch_1 > 16)
1072:  INCF   2E,F
1074:  MOVF   2E,W
1076:  SUBLW  10
1078:  BC    107C
....................             val_sch_1 = 0;
107A:  CLRF   2E
....................          sch_1++;
107C:  INCF   2A,F
107E:  BTFSC  FD8.2
1080:  INCF   2B,F
....................          *sch_1++ = 0XFF;
1082:  MOVFF  2B,FEA
1086:  MOVF   2A,W
1088:  INCF   2A,F
108A:  BTFSC  FD8.2
108C:  INCF   2B,F
108E:  MOVWF  FE9
1090:  SETF   FEF
....................          *sch_1 = 0;
1092:  MOVFF  2A,FE9
1096:  MOVFF  2B,FEA
109A:  CLRF   FEF
....................       }
....................       break;
....................    }
109C:  GOTO   189A (RETURN)
.................... }
.................... 
.................... void write_data(void)
.................... {
....................    wee(timer_tri_hoan_ee, timer_tri_hoan);
*
0D7C:  MOVF   FF2,W
0D7E:  MOVWF  00
0D80:  BCF    FF2.7
0D82:  CLRF   FAA
0D84:  CLRF   FA9
0D86:  MOVFF  56,FA8
0D8A:  BCF    FA6.6
0D8C:  BCF    FA6.7
0D8E:  BSF    FA6.2
0D90:  MOVLB  F
0D92:  MOVLW  55
0D94:  MOVWF  FA7
0D96:  MOVLW  AA
0D98:  MOVWF  FA7
0D9A:  BSF    FA6.1
0D9C:  BTFSC  FA6.1
0D9E:  BRA    0D9C
0DA0:  BCF    FA6.2
0DA2:  MOVF   00,W
0DA4:  IORWF  FF2,F
....................    wee(timer_chay_lien_tuc_ee, timer_chay_lien_tuc);
0DA6:  MOVFF  FF2,00
0DAA:  BCF    FF2.7
0DAC:  CLRF   FAA
0DAE:  MOVLW  02
0DB0:  MOVWF  FA9
0DB2:  MOVFF  5D,FA8
0DB6:  BCF    FA6.6
0DB8:  BCF    FA6.7
0DBA:  BSF    FA6.2
0DBC:  MOVLW  55
0DBE:  MOVWF  FA7
0DC0:  MOVLW  AA
0DC2:  MOVWF  FA7
0DC4:  BSF    FA6.1
0DC6:  BTFSC  FA6.1
0DC8:  BRA    0DC6
0DCA:  BCF    FA6.2
0DCC:  MOVF   00,W
0DCE:  IORWF  FF2,F
....................    wee(timer_tam_dung_ee, timer_tam_dung);
0DD0:  MOVFF  FF2,00
0DD4:  BCF    FF2.7
0DD6:  CLRF   FAA
0DD8:  MOVLW  03
0DDA:  MOVWF  FA9
0DDC:  MOVFF  60,FA8
0DE0:  BCF    FA6.6
0DE2:  BCF    FA6.7
0DE4:  BSF    FA6.2
0DE6:  MOVLW  55
0DE8:  MOVWF  FA7
0DEA:  MOVLW  AA
0DEC:  MOVWF  FA7
0DEE:  BSF    FA6.1
0DF0:  BTFSC  FA6.1
0DF2:  BRA    0DF0
0DF4:  BCF    FA6.2
0DF6:  MOVF   00,W
0DF8:  IORWF  FF2,F
....................    wee(timer_ktra_mn_ee, timer_ktra_mn);
0DFA:  MOVFF  FF2,00
0DFE:  BCF    FF2.7
0E00:  CLRF   FAA
0E02:  MOVLW  05
0E04:  MOVWF  FA9
0E06:  MOVFF  66,FA8
0E0A:  BCF    FA6.6
0E0C:  BCF    FA6.7
0E0E:  BSF    FA6.2
0E10:  MOVLW  55
0E12:  MOVWF  FA7
0E14:  MOVLW  AA
0E16:  MOVWF  FA7
0E18:  BSF    FA6.1
0E1A:  BTFSC  FA6.1
0E1C:  BRA    0E1A
0E1E:  BCF    FA6.2
0E20:  MOVF   00,W
0E22:  IORWF  FF2,F
....................    wee(timer_ktra_AC_ee, timer_ktra_AC);
0E24:  MOVFF  FF2,00
0E28:  BCF    FF2.7
0E2A:  CLRF   FAA
0E2C:  MOVLW  04
0E2E:  MOVWF  FA9
0E30:  MOVFF  63,FA8
0E34:  BCF    FA6.6
0E36:  BCF    FA6.7
0E38:  BSF    FA6.2
0E3A:  MOVLW  55
0E3C:  MOVWF  FA7
0E3E:  MOVLW  AA
0E40:  MOVWF  FA7
0E42:  BSF    FA6.1
0E44:  BTFSC  FA6.1
0E46:  BRA    0E44
0E48:  BCF    FA6.2
0E4A:  MOVF   00,W
0E4C:  IORWF  FF2,F
....................    wee(counter_restart_mpd_ee, counter_restart_mpd);
0E4E:  MOVFF  FF2,00
0E52:  BCF    FF2.7
0E54:  CLRF   FAA
0E56:  MOVLW  01
0E58:  MOVWF  FA9
0E5A:  MOVFF  59,FA8
0E5E:  BCF    FA6.6
0E60:  BCF    FA6.7
0E62:  BSF    FA6.2
0E64:  MOVLW  55
0E66:  MOVWF  FA7
0E68:  MOVLW  AA
0E6A:  MOVWF  FA7
0E6C:  BSF    FA6.1
0E6E:  BTFSC  FA6.1
0E70:  BRA    0E6E
0E72:  BCF    FA6.2
0E74:  MOVF   00,W
0E76:  IORWF  FF2,F
0E78:  MOVLB  0
0E7A:  RETURN 0
.................... }
.................... 
.................... //=========================
.................... void read_data(void)
.................... {
....................    timer_tri_hoan = ree(timer_tri_hoan_ee);
*
04A4:  MOVFF  FF2,7E
04A8:  BCF    FF2.7
04AA:  CLRF   FAA
04AC:  CLRF   FA9
04AE:  BCF    FA6.6
04B0:  BCF    FA6.7
04B2:  BSF    FA6.0
04B4:  MOVF   FA8,W
04B6:  BTFSC  x7E.7
04B8:  BSF    FF2.7
04BA:  MOVWF  56
....................    timer_chay_lien_tuc = ree(timer_chay_lien_tuc_ee);
04BC:  MOVFF  FF2,7E
04C0:  BCF    FF2.7
04C2:  CLRF   FAA
04C4:  MOVLW  02
04C6:  MOVWF  FA9
04C8:  BCF    FA6.6
04CA:  BCF    FA6.7
04CC:  BSF    FA6.0
04CE:  MOVF   FA8,W
04D0:  BTFSC  x7E.7
04D2:  BSF    FF2.7
04D4:  MOVWF  5D
....................    timer_tam_dung = ree(timer_tam_dung_ee);
04D6:  MOVFF  FF2,7E
04DA:  BCF    FF2.7
04DC:  CLRF   FAA
04DE:  MOVLW  03
04E0:  MOVWF  FA9
04E2:  BCF    FA6.6
04E4:  BCF    FA6.7
04E6:  BSF    FA6.0
04E8:  MOVF   FA8,W
04EA:  BTFSC  x7E.7
04EC:  BSF    FF2.7
04EE:  MOVWF  x60
....................    timer_ktra_mn = ree(timer_ktra_mn_ee);
04F0:  MOVFF  FF2,7E
04F4:  BCF    FF2.7
04F6:  CLRF   FAA
04F8:  MOVLW  05
04FA:  MOVWF  FA9
04FC:  BCF    FA6.6
04FE:  BCF    FA6.7
0500:  BSF    FA6.0
0502:  MOVF   FA8,W
0504:  BTFSC  x7E.7
0506:  BSF    FF2.7
0508:  MOVWF  x66
....................    timer_ktra_AC = ree(timer_ktra_AC_ee);
050A:  MOVFF  FF2,7E
050E:  BCF    FF2.7
0510:  CLRF   FAA
0512:  MOVLW  04
0514:  MOVWF  FA9
0516:  BCF    FA6.6
0518:  BCF    FA6.7
051A:  BSF    FA6.0
051C:  MOVF   FA8,W
051E:  BTFSC  x7E.7
0520:  BSF    FF2.7
0522:  MOVWF  x63
....................    counter_restart_mpd = ree(counter_restart_mpd_ee);
0524:  MOVFF  FF2,7E
0528:  BCF    FF2.7
052A:  CLRF   FAA
052C:  MOVLW  01
052E:  MOVWF  FA9
0530:  BCF    FA6.6
0532:  BCF    FA6.7
0534:  BSF    FA6.0
0536:  MOVF   FA8,W
0538:  BTFSC  x7E.7
053A:  BSF    FF2.7
053C:  MOVWF  59
053E:  GOTO   16F6 (RETURN)
.................... }
.................... 
.................... void disable_reset(void)
.................... {
....................    output_high(clock_reset);
*
037E:  BCF    F92.3
0380:  BSF    F89.3
....................    delay_ms(1);
0382:  MOVLW  01
0384:  MOVLB  1
0386:  MOVWF  x2E
0388:  MOVLB  0
038A:  RCALL  0354
....................    output_low(clock_reset);
038C:  BCF    F92.3
038E:  BCF    F89.3
....................    delay_ms(1);
0390:  MOVLW  01
0392:  MOVLB  1
0394:  MOVWF  x2E
0396:  MOVLB  0
0398:  RCALL  0354
....................    output_high(clock_reset);
039A:  BCF    F92.3
039C:  BSF    F89.3
....................    delay_ms(1);
039E:  MOVLW  01
03A0:  MOVLB  1
03A2:  MOVWF  x2E
03A4:  MOVLB  0
03A6:  RCALL  0354
....................    output_low(clock_reset);
03A8:  BCF    F92.3
03AA:  BCF    F89.3
....................    delay_ms(1);
03AC:  MOVLW  01
03AE:  MOVLB  1
03B0:  MOVWF  x2E
03B2:  MOVLB  0
03B4:  RCALL  0354
....................    output_high(clock_reset);
03B6:  BCF    F92.3
03B8:  BSF    F89.3
....................    delay_ms(1);
03BA:  MOVLW  01
03BC:  MOVLB  1
03BE:  MOVWF  x2E
03C0:  MOVLB  0
03C2:  RCALL  0354
....................    output_low(clock_reset);
03C4:  BCF    F92.3
03C6:  BCF    F89.3
....................    delay_ms(1);
03C8:  MOVLW  01
03CA:  MOVLB  1
03CC:  MOVWF  x2E
03CE:  MOVLB  0
03D0:  RCALL  0354
....................    output_float(clock_reset);
03D2:  BSF    F92.3
03D4:  RETURN 0
.................... }
.................... 
.................... #int_timer0
.................... void interrupt_timer0()
.................... {
....................    clear_interrupt(INT_TIMER0);
*
01FA:  BCF    FF2.2
....................    set_timer0(62536); // 500us => 65536 - (0.0005/(4/24000000))
01FC:  MOVLW  F4
01FE:  MOVWF  FD7
0200:  MOVLW  48
0202:  MOVWF  FD6
0204:  NOP   
.................... 
....................    if (mode == 0 && state_AC == 1) // DIMMER LCD
0206:  MOVF   50,F
0208:  BNZ   023A
020A:  DECFSZ 4F,W
020C:  BRA    023A
....................    {
....................       switch (pwm_lcd)
020E:  MOVF   x76,W
0210:  BZ    021C
0212:  XORLW  01
0214:  BZ    0222
0216:  XORLW  06
0218:  BZ    022E
021A:  BRA    0238
....................       {
....................       case 0:
....................          backligh_on();
021C:  BCF    F92.4
021E:  BSF    F89.4
....................          break;
0220:  BRA    0238
.................... 
....................       case 1:
....................          if (timer_backlight < 30)
0222:  MOVF   54,W
0224:  SUBLW  1D
0226:  BNC   022C
....................             backligh_off();
0228:  BCF    F92.4
022A:  BCF    F89.4
....................          break;
022C:  BRA    0238
.................... 
....................       case 7:
....................          if (timer_backlight < 120)
022E:  MOVF   54,W
0230:  SUBLW  77
0232:  BNC   0238
....................             backligh_off();
0234:  BCF    F92.4
0236:  BCF    F89.4
....................          break;
....................       }
....................    }
0238:  BRA    023E
....................    else
....................    {
....................       backligh_on();
023A:  BCF    F92.4
023C:  BSF    F89.4
....................    }
....................    if (++pwm_lcd > 10)
023E:  INCF   x76,F
0240:  MOVF   x76,W
0242:  SUBLW  0A
0244:  BC    0248
....................       pwm_lcd = 0;
0246:  CLRF   x76
.................... 
....................    if (++counter_timer0 > 500)
0248:  INCF   x6F,F
024A:  BTFSC  FD8.2
024C:  INCF   x70,F
024E:  MOVF   x70,W
0250:  SUBLW  00
0252:  BTFSC  FD8.0
0254:  BRA    0326
0256:  XORLW  FF
0258:  BNZ   0262
025A:  MOVF   x6F,W
025C:  SUBLW  F4
025E:  BTFSC  FD8.0
0260:  BRA    0326
....................    { // timer 1s
....................       counter_timer0 = 0;
0262:  CLRF   x70
0264:  CLRF   x6F
....................       DISABLE_INTERRUPTS(INT_TIMER0);
0266:  BCF    FF2.5
.................... 
....................       switch (mode)
0268:  MOVF   50,W
026A:  BZ    026E
026C:  BRA    02FE
....................       {
....................       case 0: // TINH NANG CHINH
....................          if (flag_mn == 1 && val_timer_ktra_mn > 0)
026E:  DECFSZ x6E,W
0270:  BRA    0278
0272:  MOVF   x65,F
0274:  BZ    0278
....................          {
....................             val_timer_ktra_mn--;
0276:  DECF   x65,F
....................          }
....................          switch (state_AC)
0278:  MOVF   4F,W
027A:  ADDLW  FA
027C:  BC    02FC
027E:  ADDLW  06
0280:  GOTO   032E
....................          {
....................          case 0: // TIMER DEM DO AC
....................             if (val_timer_ktra_AC > 0)
0284:  MOVF   x62,F
0286:  BZ    028A
....................                val_timer_ktra_AC--;
0288:  DECF   x62,F
....................             break;
028A:  BRA    02FC
....................          case 1:
....................             break;
028C:  BRA    02FC
....................          case 2: // TIMER TRI HOAN
....................             if (--flag_timer_tri_hoan_60s > 59)
028E:  DECF   x73,F
0290:  MOVF   x73,W
0292:  SUBLW  3B
0294:  BC    02A0
....................             {
....................                flag_timer_tri_hoan_60s = 59;
0296:  MOVLW  3B
0298:  MOVWF  x73
....................                if (val_timer_tri_hoan > 0)
029A:  MOVF   55,F
029C:  BZ    02A0
....................                   val_timer_tri_hoan--;
029E:  DECF   55,F
....................             }
....................             break;
02A0:  BRA    02FC
....................          case 3:
....................             switch (state_mn)
02A2:  MOVF   51,W
02A4:  BZ    02B0
02A6:  XORLW  01
02A8:  BZ    02B8
02AA:  XORLW  03
02AC:  BZ    02BA
02AE:  BRA    02C0
....................             {
....................             case 0:
....................                if (val_timer_on_mpd > 0)
02B0:  MOVF   x68,F
02B2:  BZ    02B6
....................                {
....................                   val_timer_on_mpd--;
02B4:  DECF   x68,F
....................                }
....................                break;
02B6:  BRA    02C0
....................             case 1:
....................                break;
02B8:  BRA    02C0
....................             case 2:
....................                if (val_timer_off_mpd > 0)
02BA:  MOVF   x6A,F
02BC:  BZ    02C0
....................                {
....................                   val_timer_off_mpd--;
02BE:  DECF   x6A,F
....................                }
....................                break;
....................             }
....................             break;
02C0:  BRA    02FC
....................          case 4:
....................             if (--flag_timer_chay_lien_tuc_3600s > 3599)
02C2:  MOVF   x71,W
02C4:  BTFSC  FD8.2
02C6:  DECF   x72,F
02C8:  DECF   x71,F
02CA:  MOVF   x72,W
02CC:  SUBLW  0D
02CE:  BC    02E8
02D0:  XORLW  FF
02D2:  BNZ   02DA
02D4:  MOVF   x71,W
02D6:  SUBLW  0F
02D8:  BC    02E8
....................             {
....................                flag_timer_chay_lien_tuc_3600s = 3599;
02DA:  MOVLW  0E
02DC:  MOVWF  x72
02DE:  MOVLW  0F
02E0:  MOVWF  x71
....................                if (val_timer_chay_lien_tuc > 0)
02E2:  MOVF   5C,F
02E4:  BZ    02E8
....................                   val_timer_chay_lien_tuc--;
02E6:  DECF   5C,F
....................             }
....................             break;
02E8:  BRA    02FC
....................          case 5:
....................             if (--flag_timer_tam_dung_60s > 59)
02EA:  DECF   x75,F
02EC:  MOVF   x75,W
02EE:  SUBLW  3B
02F0:  BC    02FC
....................             {
....................                flag_timer_tam_dung_60s = 59;
02F2:  MOVLW  3B
02F4:  MOVWF  x75
....................                if (val_timer_tam_dung > 0)
02F6:  MOVF   5F,F
02F8:  BZ    02FC
....................                   val_timer_tam_dung--;
02FA:  DECF   5F,F
....................             }
....................             break;
....................          }
....................          break;
02FC:  BRA    02FE
....................       }
....................       // TRO VE MANG HINH CHINH KHI KHONG NHAN NUT
....................       if (timer_exit != 0)
02FE:  MOVF   53,F
0300:  BZ    0304
....................          timer_exit--;
0302:  DECF   53,F
....................       if (timer_exit == 0)
0304:  MOVF   53,F
0306:  BNZ   030A
....................       {
....................          mode = 0; // ve loading screen
0308:  CLRF   50
....................       }
.................... 
....................       // DEN LCD
....................       if (timer_backlight != 0)
030A:  MOVF   54,F
030C:  BZ    0310
....................          timer_backlight--;
030E:  DECF   54,F
.................... 
....................       // timer 1 phut
....................       if (--flag_timer_60s_password > 59)
0310:  DECF   x74,F
0312:  MOVF   x74,W
0314:  SUBLW  3B
0316:  BC    0326
....................       {
....................          flag_timer_60s_password = 59;
0318:  MOVLW  3B
031A:  MOVWF  x74
....................          loop_not_display = 1;
031C:  MOVLW  01
031E:  MOVWF  x79
....................          if (time_reset_password != 0)
0320:  MOVF   4E,F
0322:  BZ    0326
....................             time_reset_password--;
0324:  DECF   4E,F
.................... 
....................          // nhan nut up mot luc reset ve mat dinh
....................       }
....................    }
....................    enable_interrupts(INT_TIMER0);
0326:  BSF    FF2.5
0328:  BCF    FF2.2
032A:  GOTO   0060
.................... }

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1C09   NOPUT NOBROWNOUT BORV27 NOWDT WDT16384
   Word  3: 8F00   CCP2C1 PBADEN LPT1OSC HFOFST MCLR
   Word  4: 0000   NOSTVREN NOLVP NOXINST DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
