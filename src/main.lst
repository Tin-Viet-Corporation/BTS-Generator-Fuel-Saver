CCS PCH C Compiler, Version 5.109, 43599               20-Thg2-23 21:36

               Filename:   D:\Tin Viet Telecom Corp\BTS-Generator-Fuel-Saver\src\main.lst

               ROM used:   6500 bytes (10%)
                           Largest free fragment is 58200
               RAM used:   126 (3%) at main() level
                           303 (8%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 30

*
0000:  GOTO   15FC
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   01FE
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include "C:\Program Files (x86)\PICC\Devices\18f26k20.h"
.................... //////////// Standard Header file for the PIC18F26K20 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F26K20
00AE:  CLRF   FF7
00B0:  ADDLW  BE
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  RETURN 0
00BE:  DATA 00,00
00C0:  DATA 54,47
00C2:  DATA 20,54
00C4:  DATA 52,49
00C6:  DATA 20,48
00C8:  DATA 4F,41
00CA:  DATA 4E,20
00CC:  DATA 4D,50
00CE:  DATA 44,00
00D0:  DATA 50,48
00D2:  DATA 55,54
00D4:  DATA 20,4C
00D6:  DATA 6F,6E
00D8:  DATA 67,3A
00DA:  DATA 20,25
00DC:  DATA 30,31
00DE:  DATA 75,00
00E0:  DATA 54,47
00E2:  DATA 20,43
00E4:  DATA 48,41
00E6:  DATA 59,20
00E8:  DATA 4C,49
00EA:  DATA 45,4E
00EC:  DATA 20,54
00EE:  DATA 55,43
00F0:  DATA 00,00
00F2:  DATA 47,49
00F4:  DATA 4F,3A
00F6:  DATA 20,25
00F8:  DATA 30,31
00FA:  DATA 75,00
00FC:  DATA 54,47
00FE:  DATA 20,54
0100:  DATA 41,4D
0102:  DATA 20,44
0104:  DATA 55,4E
0106:  DATA 47,20
0108:  DATA 4D,50
010A:  DATA 44,00
010C:  DATA 50,48
010E:  DATA 55,54
0110:  DATA 3A,20
0112:  DATA 25,30
0114:  DATA 31,75
0116:  DATA 00,00
0118:  DATA 4B,49
011A:  DATA 45,4D
011C:  DATA 20,54
011E:  DATA 52,41
0120:  DATA 20,41
0122:  DATA 43,00
0124:  DATA 47,49
0126:  DATA 41,59
0128:  DATA 3A,20
012A:  DATA 25,30
012C:  DATA 31,75
012E:  DATA 00,00
0130:  DATA 44,2E
0132:  DATA 41,50
0134:  DATA 20,41
0136:  DATA 43,20
0138:  DATA 42,54
013A:  DATA 48,55
013C:  DATA 4F,4E
013E:  DATA 47,00
0140:  DATA 4D,50
0142:  DATA 44,20
0144:  DATA 4C,4F
0146:  DATA 49,00
0148:  DATA 4D,50
014A:  DATA 44,20
014C:  DATA 54,4F
014E:  DATA 54,00
0150:  DATA 43,48
0152:  DATA 41,59
0154:  DATA 20,4D
0156:  DATA 50,44
0158:  DATA 00,00
015A:  DATA 4C,41
015C:  DATA 4E,3A
015E:  DATA 20,25
0160:  DATA 30,31
0162:  DATA 75,00
0164:  DATA 4D,50
0166:  DATA 44,20
0168:  DATA 4C,4F
016A:  DATA 49,00
016C:  DATA 50,48
016E:  DATA 55,54
0170:  DATA 3A,20
0172:  DATA 3C,25
0174:  DATA 30,31
0176:  DATA 75,3E
0178:  DATA 00,00
017A:  DATA 47,49
017C:  DATA 4F,3A
017E:  DATA 20,3C
0180:  DATA 25,30
0182:  DATA 31,75
0184:  DATA 3E,00
0186:  DATA 50,48
0188:  DATA 55,54
018A:  DATA 3A,20
018C:  DATA 3C,25
018E:  DATA 30,31
0190:  DATA 75,3E
0192:  DATA 00,00
0194:  DATA 47,49
0196:  DATA 41,59
0198:  DATA 3A,20
019A:  DATA 3C,25
019C:  DATA 30,31
019E:  DATA 75,3E
01A0:  DATA 00,00
01A2:  DATA 47,49
01A4:  DATA 41,59
01A6:  DATA 3A,20
01A8:  DATA 3C,25
01AA:  DATA 30,31
01AC:  DATA 75,3E
01AE:  DATA 00,00
01B0:  DATA 4C,41
01B2:  DATA 4E,3A
01B4:  DATA 20,3C
01B6:  DATA 25,30
01B8:  DATA 31,75
01BA:  DATA 3E,00
01BC:  DATA 20,20
01BE:  DATA 20,20
01C0:  DATA 20,20
01C2:  DATA 20,20
01C4:  DATA 20,20
01C6:  DATA 20,20
01C8:  DATA 20,20
01CA:  DATA 20,20
01CC:  DATA 20,00
01CE:  DATA 20,20
01D0:  DATA 3C,59
01D2:  DATA 45,53
01D4:  DATA 20,7C
01D6:  DATA 7C,20
01D8:  DATA 4E,4F
01DA:  DATA 3E,00
01DC:  DATA 4C,6F
01DE:  DATA 61,64
01E0:  DATA 69,6E
01E2:  DATA 67,20
01E4:  DATA 00,00
01E6:  DATA 2E,20
01E8:  DATA 20,00
01EA:  DATA 2E,2E
01EC:  DATA 20,00
01EE:  DATA 2E,2E
01F0:  DATA 2E,00
01F2:  DATA 20,2E
01F4:  DATA 2E,00
01F6:  DATA 20,20
01F8:  DATA 2E,00
01FA:  DATA 20,20
01FC:  DATA 20,00
*
0332:  ADDWF  FE8,W
0334:  CLRF   FF7
0336:  RLCF   FF7,F
0338:  ADDLW  4D
033A:  MOVWF  FF6
033C:  MOVLW  03
033E:  ADDWFC FF7,F
0340:  TBLRD*-
0342:  MOVF   FF5,W
0344:  MOVWF  FFA
0346:  TBLRD*
0348:  MOVF   FF5,W
034A:  MOVWF  FF9
034C:  DATA 88,02
034E:  DATA 90,02
0350:  DATA 92,02
0352:  DATA A6,02
0354:  DATA C6,02
0356:  DATA EE,02
*
0670:  TBLRD*+
0672:  MOVF   FF5,F
0674:  BZ    068E
0676:  MOVFF  FF6,12A
067A:  MOVFF  FF7,12B
067E:  MOVFF  FF5,12C
0682:  RCALL  0660
0684:  MOVFF  12A,FF6
0688:  MOVFF  12B,FF7
068C:  BRA    0670
068E:  RETURN 0
0690:  MOVF   FEF,F
0692:  BZ    06B2
0694:  MOVFF  FEA,12B
0698:  MOVFF  FE9,12A
069C:  MOVFF  FEF,12C
06A0:  RCALL  0660
06A2:  MOVFF  12B,FEA
06A6:  MOVFF  12A,FE9
06AA:  INCF   FE9,F
06AC:  BTFSC  FD8.2
06AE:  INCF   FEA,F
06B0:  BRA    0690
06B2:  RETURN 0
*
0764:  ADDWF  FE8,W
0766:  CLRF   FF7
0768:  RLCF   FF7,F
076A:  ADDLW  7F
076C:  MOVWF  FF6
076E:  MOVLW  07
0770:  ADDWFC FF7,F
0772:  TBLRD*-
0774:  MOVF   FF5,W
0776:  MOVWF  FFA
0778:  TBLRD*
077A:  MOVF   FF5,W
077C:  MOVWF  FF9
077E:  DATA 06,07
0780:  DATA 12,07
0782:  DATA 1E,07
0784:  DATA 2A,07
0786:  DATA 36,07
0788:  DATA 42,07
078A:  TBLRD*+
078C:  MOVFF  FF6,12A
0790:  MOVFF  FF7,12B
0794:  MOVFF  FF5,12C
0798:  RCALL  0660
079A:  MOVFF  12A,FF6
079E:  MOVFF  12B,FF7
07A2:  MOVLB  1
07A4:  DECFSZ x29,F
07A6:  BRA    07AA
07A8:  BRA    07AE
07AA:  MOVLB  0
07AC:  BRA    078A
07AE:  MOVLB  0
07B0:  RETURN 0
07B2:  MOVLB  1
07B4:  MOVF   x2C,W
07B6:  CLRF   01
07B8:  SUBWF  x2B,W
07BA:  BC    07C2
07BC:  MOVFF  12B,00
07C0:  BRA    07DA
07C2:  CLRF   00
07C4:  MOVLW  08
07C6:  MOVWF  x2D
07C8:  RLCF   x2B,F
07CA:  RLCF   00,F
07CC:  MOVF   x2C,W
07CE:  SUBWF  00,W
07D0:  BTFSC  FD8.0
07D2:  MOVWF  00
07D4:  RLCF   01,F
07D6:  DECFSZ x2D,F
07D8:  BRA    07C8
07DA:  MOVLB  0
07DC:  RETURN 0
07DE:  MOVF   01,W
07E0:  MOVFF  129,12B
07E4:  MOVLW  64
07E6:  MOVLB  1
07E8:  MOVWF  x2C
07EA:  MOVLB  0
07EC:  RCALL  07B2
07EE:  MOVFF  00,129
07F2:  MOVF   01,W
07F4:  MOVLW  30
07F6:  BNZ   0808
07F8:  MOVLB  1
07FA:  BTFSS  x2A.1
07FC:  BRA    081C
07FE:  BTFSC  x2A.3
0800:  BRA    081C
0802:  BTFSC  x2A.4
0804:  MOVLW  20
0806:  BRA    0810
0808:  MOVLB  1
080A:  BCF    x2A.3
080C:  BCF    x2A.4
080E:  BSF    x2A.0
0810:  ADDWF  01,F
0812:  MOVFF  01,12C
0816:  MOVLB  0
0818:  RCALL  0660
081A:  MOVLB  1
081C:  MOVFF  129,12B
0820:  MOVLW  0A
0822:  MOVWF  x2C
0824:  MOVLB  0
0826:  RCALL  07B2
0828:  MOVFF  00,129
082C:  MOVF   01,W
082E:  MOVLW  30
0830:  BNZ   0842
0832:  MOVLB  1
0834:  BTFSC  x2A.3
0836:  BRA    084C
0838:  BTFSS  x2A.0
083A:  BRA    084C
083C:  BTFSC  x2A.4
083E:  MOVLW  20
0840:  MOVLB  0
0842:  ADDWF  01,F
0844:  MOVFF  01,12C
0848:  RCALL  0660
084A:  MOVLB  1
084C:  MOVLW  30
084E:  ADDWF  x29,F
0850:  MOVFF  129,12C
0854:  MOVLB  0
0856:  RCALL  0660
0858:  RETURN 0
*
0AB2:  ADDWF  FE8,W
0AB4:  CLRF   FF7
0AB6:  RLCF   FF7,F
0AB8:  ADDLW  CD
0ABA:  MOVWF  FF6
0ABC:  MOVLW  0A
0ABE:  ADDWFC FF7,F
0AC0:  TBLRD*-
0AC2:  MOVF   FF5,W
0AC4:  MOVWF  FFA
0AC6:  TBLRD*
0AC8:  MOVF   FF5,W
0ACA:  MOVWF  FF9
0ACC:  DATA 6C,08
0ACE:  DATA 70,08
0AD0:  DATA C2,08
0AD2:  DATA 14,09
0AD4:  DATA 66,09
0AD6:  DATA B8,09
0AD8:  DATA 28,0A
0ADA:  DATA 7A,0A
*
0F3E:  ADDWF  FE8,W
0F40:  CLRF   FF7
0F42:  RLCF   FF7,F
0F44:  ADDLW  59
0F46:  MOVWF  FF6
0F48:  MOVLW  0F
0F4A:  ADDWFC FF7,F
0F4C:  TBLRD*-
0F4E:  MOVF   FF5,W
0F50:  MOVWF  FFA
0F52:  TBLRD*
0F54:  MOVF   FF5,W
0F56:  MOVWF  FF9
0F58:  DATA 8C,0E
0F5A:  DATA 8E,0E
0F5C:  DATA DC,0E
0F5E:  DATA EA,0E
0F60:  DATA F8,0E
0F62:  DATA 06,0F
0F64:  DATA 14,0F
0F66:  DATA 22,0F
0F68:  DATA 30,0F
*
1018:  ADDWF  FE8,W
101A:  CLRF   FF7
101C:  RLCF   FF7,F
101E:  ADDLW  33
1020:  MOVWF  FF6
1022:  MOVLW  10
1024:  ADDWFC FF7,F
1026:  TBLRD*-
1028:  MOVF   FF5,W
102A:  MOVWF  FFA
102C:  TBLRD*
102E:  MOVF   FF5,W
1030:  MOVWF  FF9
1032:  DATA 76,0F
1034:  DATA 78,0F
1036:  DATA C8,0F
1038:  DATA D2,0F
103A:  DATA DC,0F
103C:  DATA E6,0F
103E:  DATA F4,0F
1040:  DATA 02,10
1042:  DATA 10,10
*
159E:  ADDWF  FE8,W
15A0:  CLRF   FF7
15A2:  RLCF   FF7,F
15A4:  ADDLW  B9
15A6:  MOVWF  FF6
15A8:  MOVLW  15
15AA:  ADDWFC FF7,F
15AC:  TBLRD*-
15AE:  MOVF   FF5,W
15B0:  MOVWF  FFA
15B2:  TBLRD*
15B4:  MOVF   FF5,W
15B6:  MOVWF  FF9
15B8:  DATA 2C,13
15BA:  DATA 3A,13
15BC:  DATA 48,13
15BE:  DATA 56,13
15C0:  DATA 58,13
15C2:  DATA 66,13
15C4:  DATA 80,13
15C6:  DATA 80,13
15C8:  DATA 80,13
15CA:  DATA 80,13
15CC:  DATA 74,13
15CE:  ADDWF  FE8,W
15D0:  CLRF   FF7
15D2:  RLCF   FF7,F
15D4:  ADDLW  E9
15D6:  MOVWF  FF6
15D8:  MOVLW  15
15DA:  ADDWFC FF7,F
15DC:  TBLRD*-
15DE:  MOVF   FF5,W
15E0:  MOVWF  FFA
15E2:  TBLRD*
15E4:  MOVF   FF5,W
15E6:  MOVWF  FF9
15E8:  DATA 20,13
15EA:  DATA 82,13
15EC:  DATA A2,13
15EE:  DATA EA,13
15F0:  DATA 32,14
15F2:  DATA 7A,14
15F4:  DATA C2,14
15F6:  DATA 0A,15
15F8:  DATA 52,15
15FA:  DATA 60,15
*
18E8:  ADDWF  FE8,W
18EA:  CLRF   FF7
18EC:  RLCF   FF7,F
18EE:  ADDLW  03
18F0:  MOVWF  FF6
18F2:  MOVLW  19
18F4:  ADDWFC FF7,F
18F6:  TBLRD*-
18F8:  MOVF   FF5,W
18FA:  MOVWF  FFA
18FC:  TBLRD*
18FE:  MOVF   FF5,W
1900:  MOVWF  FF9
1902:  DATA 24,17
1904:  DATA 26,17
1906:  DATA 34,17
1908:  DATA 42,17
190A:  DATA AE,17
190C:  DATA D8,17
190E:  DATA FA,17
1910:  DATA FA,17
1912:  DATA FA,17
1914:  DATA FA,17
1916:  DATA E6,17
1918:  ADDWF  FE8,W
191A:  CLRF   FF7
191C:  RLCF   FF7,F
191E:  ADDLW  33
1920:  MOVWF  FF6
1922:  MOVLW  19
1924:  ADDWFC FF7,F
1926:  TBLRD*-
1928:  MOVF   FF5,W
192A:  MOVWF  FFA
192C:  TBLRD*
192E:  MOVF   FF5,W
1930:  MOVWF  FF9
1932:  DATA 12,17
1934:  DATA FC,17
1936:  DATA FE,17
1938:  DATA 00,18
193A:  DATA 02,18
193C:  DATA 04,18
193E:  DATA 06,18
1940:  DATA 08,18
1942:  DATA 0A,18
1944:  DATA 0C,18
1946:  ADDWF  FE8,W
1948:  CLRF   FF7
194A:  RLCF   FF7,F
194C:  ADDLW  61
194E:  MOVWF  FF6
1950:  MOVLW  19
1952:  ADDWFC FF7,F
1954:  TBLRD*-
1956:  MOVF   FF5,W
1958:  MOVWF  FFA
195A:  TBLRD*
195C:  MOVF   FF5,W
195E:  MOVWF  FF9
1960:  DATA 20,18
1962:  DATA 3E,18
1964:  DATA 68,18
1966:  DATA 92,18
.................... 
.................... #list
.................... 
.................... #device adc = 10
.................... #fuses hs, nolvp, protect, MCLR, NOPUT, BORV27
.................... #include "C:\Program Files (x86)\PICC\Drivers\stdlib.h"
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
0C70:  MOVFF  7E,FE9
0C74:  MOVFF  7F,FEA
0C78:  MOVFF  FEF,82
0C7C:  MOVFF  81,03
0C80:  MOVFF  80,FE9
0C84:  MOVFF  81,FEA
0C88:  MOVF   FEF,W
0C8A:  SUBWF  x82,W
0C8C:  BNZ   0CB8
....................       if (*s1 == '\0')
0C8E:  MOVFF  7F,03
0C92:  MOVFF  7E,FE9
0C96:  MOVFF  03,FEA
0C9A:  MOVF   FEF,F
0C9C:  BNZ   0CA4
....................          return(0);
0C9E:  MOVLW  00
0CA0:  MOVWF  01
0CA2:  BRA    0CE2
0CA4:  MOVFF  7F,03
0CA8:  MOVF   x7E,W
0CAA:  INCF   x7E,F
0CAC:  BTFSC  FD8.2
0CAE:  INCF   x7F,F
0CB0:  INCF   x80,F
0CB2:  BTFSC  FD8.2
0CB4:  INCF   x81,F
0CB6:  BRA    0C70
....................    return((*s1 < *s2) ? -1: 1);
0CB8:  MOVFF  7F,03
0CBC:  MOVFF  7E,FE9
0CC0:  MOVFF  7F,FEA
0CC4:  MOVFF  FEF,82
0CC8:  MOVFF  81,03
0CCC:  MOVFF  80,FE9
0CD0:  MOVFF  81,FEA
0CD4:  MOVF   FEF,W
0CD6:  SUBWF  x82,W
0CD8:  BC    0CDE
0CDA:  MOVLW  FF
0CDC:  BRA    0CE0
0CDE:  MOVLW  01
0CE0:  MOVWF  01
0CE2:  GOTO   0D2A (RETURN)
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
0C3C:  MOVFF  81,83
0C40:  MOVFF  80,82
0C44:  MOVFF  83,03
0C48:  MOVFF  82,FE9
0C4C:  MOVFF  83,FEA
0C50:  MOVF   FEF,F
0C52:  BZ    0C5C
0C54:  INCF   x82,F
0C56:  BTFSC  FD8.2
0C58:  INCF   x83,F
0C5A:  BRA    0C44
....................    return(sc - s);
0C5C:  MOVF   x80,W
0C5E:  SUBWF  x82,W
0C60:  MOVWF  00
0C62:  MOVF   x81,W
0C64:  SUBWFB x83,W
0C66:  MOVWF  03
0C68:  MOVFF  00,01
0C6C:  MOVWF  02
0C6E:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #fuses WDT16384
.................... #use delay(clock = 24000000)
*
0358:  MOVLW  01
035A:  MOVWF  FEA
035C:  MOVLW  2E
035E:  MOVWF  FE9
0360:  MOVF   FEF,W
0362:  BZ    0380
0364:  MOVLW  07
0366:  MOVWF  01
0368:  CLRF   00
036A:  DECFSZ 00,F
036C:  BRA    036A
036E:  DECFSZ 01,F
0370:  BRA    0368
0372:  MOVLW  C7
0374:  MOVWF  00
0376:  DECFSZ 00,F
0378:  BRA    0376
037A:  NOP   
037C:  DECFSZ FEF,F
037E:  BRA    0364
0380:  RETURN 0
.................... #include "lcd_lib_4bit.c"
.................... //#include <stddef.h>
.................... #include "C:\Program Files (x86)\PICC\Drivers\stddef.h"
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... #define LCD_RS          PIN_B1
.................... #define LCD_EN          PIN_B0
.................... #define LCD_D4          PIN_C7
.................... #define LCD_D5          PIN_C6
.................... #define LCD_D6          PIN_C5
.................... #define LCD_D7          PIN_C4
.................... #define Line_1          0x80
.................... #define Line_2          0xC0
.................... #define Clear_Scr       0x01
.................... 
.................... void LCD_Init ();// ham khoi tao LCD
.................... void LCD_SetPosition ( unsigned int cX );//Thiet lap vi tri con tro
.................... void LCD_PutChar ( unsigned int cX );// Ham viet1kitu/1chuoi len LCD
.................... void LCD_PutCmd ( unsigned int cX) ;// Ham gui lenh len LCD
.................... void LCD_PulseEnable ( void );// Xung kich hoat
.................... void LCD_SetData ( unsigned int cX );// Dat du lieu len chan Data
.................... 
.................... //khoi tao LCD**********************************************
.................... void LCD_Init ()
....................     {
....................     LCD_SetData ( 0x00 );
*
044C:  MOVLB  1
044E:  CLRF   x2E
0450:  MOVLB  0
0452:  RCALL  03DA
....................     delay_ms(20);       /*Cho cho lcd khoi tao */
0454:  MOVLW  14
0456:  MOVLB  1
0458:  MOVWF  x2E
045A:  MOVLB  0
045C:  RCALL  0358
....................     output_low ( LCD_RS );// che do gui lenh
045E:  BCF    F93.1
0460:  BCF    F8A.1
....................     LCD_SetData ( 0x03 );   /* khoi tao che do 4 bit */
0462:  MOVLW  03
0464:  MOVLB  1
0466:  MOVWF  x2E
0468:  MOVLB  0
046A:  RCALL  03DA
....................     LCD_PulseEnable();
046C:  RCALL  0410
....................     LCD_PulseEnable();
046E:  RCALL  0410
....................     LCD_PulseEnable();
0470:  RCALL  0410
....................     LCD_SetData ( 0x02 );   /* tao giao dien 4 bit */
0472:  MOVLW  02
0474:  MOVLB  1
0476:  MOVWF  x2E
0478:  MOVLB  0
047A:  RCALL  03DA
....................     LCD_PulseEnable();      /* send dual nibbles hereafter, MSN first */
047C:  RCALL  0410
....................     LCD_PutCmd ( 0x2C );    /* function set (all lines, 5x7 characters) */
047E:  MOVLW  2C
0480:  MOVLB  1
0482:  MOVWF  x2D
0484:  MOVLB  0
0486:  RCALL  042E
....................     LCD_PutCmd ( 0x0C );    /* display ON, cursor off, no blink */
0488:  MOVLW  0C
048A:  MOVLB  1
048C:  MOVWF  x2D
048E:  MOVLB  0
0490:  RCALL  042E
....................     LCD_PutCmd ( 0x06 );    /* entry mode set, increment & scroll left */
0492:  MOVLW  06
0494:  MOVLB  1
0496:  MOVWF  x2D
0498:  MOVLB  0
049A:  RCALL  042E
....................     LCD_PutCmd ( 0x01 );    /* clear display */
049C:  MOVLW  01
049E:  MOVLB  1
04A0:  MOVWF  x2D
04A2:  MOVLB  0
04A4:  RCALL  042E
04A6:  RETURN 0
.................... 
....................     // Init for BarGraph
.................... 
....................     }
.................... 
.................... void LCD_SetPosition ( unsigned int cX )
....................     {
....................     /* this subroutine works specifically for 4-bit Port A */
....................     LCD_SetData ( swap ( cX ) | 0x08 );
....................     LCD_PulseEnable();
....................     LCD_SetData ( swap ( cX ) );
....................     LCD_PulseEnable();
....................     }
.................... 
.................... void LCD_PutChar ( unsigned int cX )
....................     {
....................     /* this subroutine works specifically for 4-bit Port A */
....................         output_high ( LCD_RS );
*
0660:  BCF    F93.1
0662:  BSF    F8A.1
....................         LCD_PutCmd( cX );
0664:  MOVFF  12C,12D
0668:  RCALL  042E
....................         output_low ( LCD_RS );
066A:  BCF    F93.1
066C:  BCF    F8A.1
066E:  RETURN 0
....................     }
.................... 
.................... void LCD_PutCmd ( unsigned int cX )
....................     {
....................     /* this subroutine works specifically for 4-bit Port A */
....................    
....................     LCD_SetData ( swap ( cX ) );     /* send high nibble */
*
042E:  MOVLB  1
0430:  SWAPF  x2D,F
0432:  MOVFF  12D,12E
0436:  MOVLB  0
0438:  RCALL  03DA
....................     LCD_PulseEnable();
043A:  RCALL  0410
....................     LCD_SetData ( swap ( cX ) );     /* send low nibble */
043C:  MOVLB  1
043E:  SWAPF  x2D,F
0440:  MOVFF  12D,12E
0444:  MOVLB  0
0446:  RCALL  03DA
....................     LCD_PulseEnable();
0448:  RCALL  0410
044A:  RETURN 0
....................     }
.................... 	
.................... void LCD_PulseEnable ( void )
....................     {
....................     output_high ( LCD_EN );
*
0410:  BCF    F93.0
0412:  BSF    F8A.0
....................     delay_us ( 3 );         // was 10
0414:  MOVLW  05
0416:  MOVWF  00
0418:  DECFSZ 00,F
041A:  BRA    0418
041C:  BRA    041E
....................     output_low ( LCD_EN );
041E:  BCF    F93.0
0420:  BCF    F8A.0
....................     delay_ms ( 3 );         // was 5
0422:  MOVLW  03
0424:  MOVLB  1
0426:  MOVWF  x2E
0428:  MOVLB  0
042A:  RCALL  0358
042C:  RETURN 0
....................     }
.................... 
.................... void LCD_SetData ( unsigned int cX )
....................     {
....................     output_bit ( LCD_D4, cX & 0x01 );
*
03DA:  MOVLB  1
03DC:  BTFSC  x2E.0
03DE:  BRA    03E4
03E0:  BCF    F8B.7
03E2:  BRA    03E6
03E4:  BSF    F8B.7
03E6:  BCF    F94.7
....................     output_bit ( LCD_D5, cX & 0x02 );
03E8:  BTFSC  x2E.1
03EA:  BRA    03F0
03EC:  BCF    F8B.6
03EE:  BRA    03F2
03F0:  BSF    F8B.6
03F2:  BCF    F94.6
....................     output_bit ( LCD_D6, cX & 0x04 );
03F4:  BTFSC  x2E.2
03F6:  BRA    03FC
03F8:  BCF    F8B.5
03FA:  BRA    03FE
03FC:  BSF    F8B.5
03FE:  BCF    F94.5
....................     output_bit ( LCD_D7, cX & 0x08 );
0400:  BTFSC  x2E.3
0402:  BRA    0408
0404:  BCF    F8B.4
0406:  BRA    040A
0408:  BSF    F8B.4
040A:  BCF    F94.4
040C:  MOVLB  0
040E:  RETURN 0
....................     }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //============================
.................... #define sw_mode PIN_A3
.................... #define sw_up PIN_A2
.................... #define sw_down PIN_A1
.................... #define sw_exit PIN_A0
.................... 
.................... #define val_mode() !input(sw_mode)
.................... #define val_up() !input(sw_up)
.................... #define val_down() !input(sw_down)
.................... #define val_exit() !input(sw_exit)
.................... 
.................... #define clock_reset PIN_A3 // TAO XUNG CHONG TREO
.................... 
.................... #define backligh_lcd PIN_A4
.................... #define backligh_on() output_high(backligh_lcd);
.................... #define backligh_off() output_low(backligh_lcd);
.................... 
.................... #define cb_mn PIN_C2
.................... #define cb_ac PIN_C3
.................... 
.................... #define status_mn() !input(cb_mn)
.................... #define status_ac() !input(cb_ac)
.................... 
.................... #define out_fire PIN_B2
.................... #define out_temp PIN_B3
.................... #define out_error PIN_B5
.................... #define out_delay PIN_B4
.................... #define out_mn PIN_B6
.................... #define out_ac PIN_B7
.................... 
.................... #define ree(x) read_eeprom(x);
.................... #define wee(x, y) write_eeprom(x, y);
.................... 
.................... #define tg_tri_hoan 1
.................... #define tg_chay_lien_tuc 2
.................... #define tg_tam_dung 3
.................... #define do_ac 4
.................... #define ac_bthg 5
.................... #define chay_mpd 6
.................... #define error 7
.................... 
.................... //===================
.................... #define clear_lcd() lcd_printf(0);
.................... #define yesno() lcd_printf(9);
.................... #define loading() lcd_printf(10);
.................... 
.................... #define sch_1_s_set() lcd_printf(11);
.................... 
.................... // luu tru trong rom
.................... 
.................... #define timer_tri_hoan_ee 0x00
.................... #define counter_restart_mpd_ee timer_tri_hoan_ee + 1
.................... #define timer_chay_lien_tuc_ee counter_restart_mpd_ee + 1
.................... #define timer_tam_dung_ee timer_chay_lien_tuc_ee + 1
.................... #define timer_ktra_AC_ee timer_tam_dung_ee + 1
.................... #define timer_ktra_mn_ee timer_ktra_AC_ee + 1
.................... 
.................... #define size_pass 5
.................... 
.................... // khai bao bien
.................... unsigned char val_number_defaul[11] = {"0123456789"};
.................... // con tro phuc vu cai dat
.................... char *sch_1 = 0, *sch_2 = 0, val_sch_1 = 0, val_sch_2 = 0;
.................... 
.................... char password[size_pass] = {"1111"};
.................... char str_temp[25] = "";
.................... char time_reset_password = 0;
.................... 
.................... char state_AC = 0;
.................... char mode = 9;
.................... char state_mn = 0;
.................... short refresh_menu = 0;
.................... 
.................... char timer_exit = 0;
.................... char timer_backlight = 240;
.................... 
.................... char val_timer_tri_hoan = 60, timer_tri_hoan = 60, timer_tri_hoan_md = 60;             // LONG DELAY 1
.................... char val_counter_restart_mpd = 1, counter_restart_mpd = 4, counter_restart_mpd_md = 4; // LONG SO LAN KHOI DONG LAI MPD
.................... char counter_restart_mpd_current = 4;
.................... char val_timer_chay_lien_tuc = 3, timer_chay_lien_tuc = 3, timer_chay_lien_tuc_md = 3; // LONG DELAY 2
.................... char val_timer_tam_dung = 60, timer_tam_dung = 60, timer_tam_dung_md = 60;             // LONG DELAY 3
.................... char val_timer_ktra_AC = 60, timer_ktra_AC = 60, timer_ktra_AC_md = 60;                // LONG KT AC TIMER
.................... char val_timer_ktra_mn = 30, timer_ktra_mn = 30, timer_ktra_mn_md = 30;                // LONG KT MN TIMER
.................... char val_timer_on_mpd = 20, timer_on_mpd = 20;
.................... char val_timer_off_mpd = 20, timer_off_mpd = 20;
.................... 
.................... char val_loading = 0;
.................... 
.................... char flag_error = 0; // LONG FLAG = 0 la ko loi, = 1 la LOI
.................... char flag_mn = 0;    // LONG FLAG = 0 la chay xong check_mn(), = 1 la dang chay
.................... 
.................... unsigned long counter_timer0 = 0, flag_timer_chay_lien_tuc_3600s = 3600;
.................... char flag_timer_tri_hoan_60s = 60, flag_timer_60s_password = 0, flag_timer_tam_dung_60s = 60;
.................... 
.................... char pwm_lcd = 0;
.................... char sum_out = 0, sum_out_old = 0, loop_not_display = 0;
.................... 
.................... //===============================
.................... void init_data(void);
.................... void check_AC(void);
.................... char check_mn(void);
.................... void default_data(void);
.................... void display(char code_print);
.................... char key_scan(void);
.................... void process_menu(void);
.................... void process_up(void);
.................... void process_down(void);
.................... void process_exit(void);
.................... void display_center(void);
.................... void lcd_printf(char code_printf);
.................... void reset_timer_data(void);
.................... void write_data(void);
.................... void read_data(void);
.................... 
.................... unsigned char read_eeprom(unsigned char addr);
.................... void write_eeprom(unsigned char addr, unsigned char value);
.................... 
.................... void disable_reset(void);
.................... 
.................... //===============================
.................... void main()
*
15FC:  CLRF   FF8
15FE:  BCF    FD0.7
1600:  BSF    07.7
1602:  CLRF   2B
1604:  CLRF   2A
1606:  CLRF   2D
1608:  CLRF   2C
160A:  CLRF   2E
160C:  CLRF   2F
160E:  CLRF   4E
1610:  CLRF   4F
1612:  MOVLW  09
1614:  MOVWF  50
1616:  CLRF   51
1618:  BCF    52.0
161A:  CLRF   53
161C:  MOVLW  F0
161E:  MOVWF  54
1620:  MOVLW  3C
1622:  MOVWF  55
1624:  MOVWF  56
1626:  MOVWF  57
1628:  MOVLW  01
162A:  MOVWF  58
162C:  MOVLW  04
162E:  MOVWF  59
1630:  MOVWF  5A
1632:  MOVWF  5B
1634:  MOVLW  03
1636:  MOVWF  5C
1638:  MOVWF  5D
163A:  MOVWF  5E
163C:  MOVLW  3C
163E:  MOVWF  5F
1640:  MOVWF  x60
1642:  MOVWF  x61
1644:  MOVWF  x62
1646:  MOVWF  x63
1648:  MOVWF  x64
164A:  MOVLW  1E
164C:  MOVWF  x65
164E:  MOVWF  x66
1650:  MOVWF  x67
1652:  MOVLW  14
1654:  MOVWF  x68
1656:  MOVWF  x69
1658:  MOVWF  x6A
165A:  MOVWF  x6B
165C:  CLRF   x6C
165E:  CLRF   x6D
1660:  CLRF   x6E
1662:  CLRF   x70
1664:  CLRF   x6F
1666:  MOVLW  0E
1668:  MOVWF  x72
166A:  MOVLW  10
166C:  MOVWF  x71
166E:  MOVLW  3C
1670:  MOVWF  x73
1672:  CLRF   x74
1674:  MOVWF  x75
1676:  CLRF   x76
1678:  CLRF   x77
167A:  CLRF   x78
167C:  CLRF   x79
167E:  CLRF   x7B
1680:  CLRF   x7A
1682:  MOVLW  00
1684:  MOVWF  F7E
1686:  BCF    FC1.4
1688:  BCF    FC1.5
168A:  MOVF   F7F,W
168C:  ANDLW  E0
168E:  MOVWF  F7F
1690:  BCF    F79.5
1692:  BCF    F79.4
1694:  CLRF   F7A
1696:  CLRF   F7B
1698:  CLRF   19
169A:  CLRF   1A
169C:  MOVLW  30
169E:  MOVWF  1F
16A0:  MOVLW  31
16A2:  MOVWF  20
16A4:  MOVLW  32
16A6:  MOVWF  21
16A8:  MOVLW  33
16AA:  MOVWF  22
16AC:  MOVLW  34
16AE:  MOVWF  23
16B0:  MOVLW  35
16B2:  MOVWF  24
16B4:  MOVLW  36
16B6:  MOVWF  25
16B8:  MOVLW  37
16BA:  MOVWF  26
16BC:  MOVLW  38
16BE:  MOVWF  27
16C0:  MOVLW  39
16C2:  MOVWF  28
16C4:  CLRF   29
16C6:  MOVLW  31
16C8:  MOVWF  30
16CA:  MOVWF  31
16CC:  MOVWF  32
16CE:  MOVWF  33
16D0:  CLRF   34
16D2:  CLRF   35
.................... {
....................    // chong treo xu li
....................    disable_reset();
16D4:  CALL   0382
....................    // KHOI DONG NGAT TIMER 0
....................    SETUP_TIMER_0(T0_INTERNAL | T0_DIV_4);
16D8:  MOVLW  81
16DA:  MOVWF  FD5
....................    enable_interrupts(INT_TIMER0);
16DC:  BSF    FF2.5
....................    enable_interrupts(GLOBAL);
16DE:  MOVLW  C0
16E0:  IORWF  FF2,F
....................    clear_interrupt(INT_TIMER0);
16E2:  BCF    FF2.2
....................    set_timer0(62536); //(24000000/128)/(65535-65160)=187500/375=500us
16E4:  MOVLW  F4
16E6:  MOVWF  FD7
16E8:  MOVLW  48
16EA:  MOVWF  FD6
16EC:  NOP   
....................    lcd_init();        // khoi dong mang hinh lcd
16EE:  CALL   044C
....................    backligh_on();
16F2:  BCF    F92.4
16F4:  BSF    F89.4
....................    read_data();
16F6:  GOTO   04A8
....................    init_data();
16FA:  GOTO   0546
....................    // CHUONG TRINH CHINH
....................    while (1)
....................    {
....................       disable_reset();
16FE:  CALL   0382
....................       restart_wdt();
1702:  CLRWDT
....................       // DIEU HOA TRANG THAI: Tinh nang chinh - nhap menu
....................       switch (mode)
1704:  MOVF   50,W
1706:  ADDLW  F6
1708:  BTFSC  FD8.0
170A:  BRA    180C
170C:  ADDLW  0A
170E:  GOTO   1918
....................       {
....................       case 0: // TINH NANG CHINH
....................          check_AC();
1712:  GOTO   05E6
.................... 
....................          switch (state_AC)
1716:  MOVF   4F,W
1718:  ADDLW  F5
171A:  BTFSC  FD8.0
171C:  BRA    17FA
171E:  ADDLW  0B
1720:  GOTO   18E8
....................          {
....................          case 0: // Timer delay ktra ac
....................             break;
1724:  BRA    17FA
.................... 
....................          case 1: // co AC ->hien thi LCD
....................             reset_timer_data();
1726:  CALL   062C
....................             output_low(out_fire);
172A:  BCF    F93.2
172C:  BCF    F8A.2
....................             output_low(out_delay);
172E:  BCF    F93.4
1730:  BCF    F8A.4
....................             break;
1732:  BRA    17FA
....................          case 2: // mat AC: DELAY 1
....................             output_high(out_delay);
1734:  BCF    F93.4
1736:  BSF    F8A.4
....................             if (val_timer_tri_hoan <= 0)
1738:  MOVF   55,F
173A:  BNZ   1740
....................             {
....................                state_AC = 3;
173C:  MOVLW  03
173E:  MOVWF  4F
....................             }
....................             break;
1740:  BRA    17FA
....................          case 3: // mat AC: DO DIEN AP MPD
....................             if (val_counter_restart_mpd <= counter_restart_mpd_current)
1742:  MOVF   58,W
1744:  SUBWF  5B,W
1746:  BNC   17A2
....................             {
....................                display(chay_mpd);
1748:  MOVLW  06
174A:  MOVLB  1
174C:  MOVWF  x28
174E:  MOVLB  0
1750:  CALL   085A
....................                switch (state_mn)
1754:  MOVF   51,W
1756:  BZ    1762
1758:  XORLW  01
175A:  BZ    1774
175C:  XORLW  03
175E:  BZ    1790
1760:  BRA    17A0
....................                {
....................                case 0: // on remote start delay
....................                   output_high(out_fire);
1762:  BCF    F93.2
1764:  BSF    F8A.2
....................                   if (val_timer_on_mpd <= 0)
1766:  MOVF   x68,F
1768:  BNZ   1772
....................                   {
....................                      state_mn = 1;
176A:  MOVLW  01
176C:  MOVWF  51
....................                      val_timer_on_mpd = timer_on_mpd;
176E:  MOVFF  69,68
....................                   }
....................                   break;
1772:  BRA    17A0
....................                case 1: // do mpd
....................                   char mn = check_mn();
1774:  CALL   0ADC
1778:  MOVFF  01,7C
....................                   if (mn == 1)
177C:  DECFSZ x7C,W
177E:  BRA    1786
....................                   {
....................                      state_AC = 4;
1780:  MOVLW  04
1782:  MOVWF  4F
....................                   }
1784:  BRA    178E
....................                   else if (mn == 0)
1786:  MOVF   x7C,F
1788:  BNZ   178E
....................                   {
....................                      state_mn = 2;
178A:  MOVLW  02
178C:  MOVWF  51
....................                   }
....................                   break;
178E:  BRA    17A0
....................                case 2: // off remote start delay
....................                   output_low(out_fire);
1790:  BCF    F93.2
1792:  BCF    F8A.2
....................                   if (val_timer_off_mpd <= 0)
1794:  MOVF   x6A,F
1796:  BNZ   17A0
....................                   {
....................                      state_mn = 0;
1798:  CLRF   51
....................                      val_timer_off_mpd = timer_off_mpd;
179A:  MOVFF  6B,6A
....................                      val_counter_restart_mpd++;
179E:  INCF   58,F
....................                   }
....................                   break;
....................                }
....................             }
17A0:  BRA    17AC
....................             else if (val_counter_restart_mpd > counter_restart_mpd_current)
17A2:  MOVF   58,W
17A4:  SUBWF  5B,W
17A6:  BC    17AC
....................             {
....................                state_AC = 10; // error
17A8:  MOVLW  0A
17AA:  MOVWF  4F
....................             }
....................             break;
17AC:  BRA    17FA
....................          case 4: // DELAY 2 + OFF REMOTE START
....................             char mn = check_mn();
17AE:  CALL   0ADC
17B2:  MOVFF  01,7D
....................             if (mn == 0)
17B6:  MOVF   x7D,F
17B8:  BNZ   17C0
....................             {
....................                state_AC = 10; // error
17BA:  MOVLW  0A
17BC:  MOVWF  4F
....................                break;
17BE:  BRA    17FA
....................             }
....................             // OFF REMOTE START
....................             if (val_timer_chay_lien_tuc <= 0)
17C0:  MOVF   5C,F
17C2:  BNZ   17D6
....................             {
....................                output_low(out_fire);
17C4:  BCF    F93.2
17C6:  BCF    F8A.2
....................                flag_error = 0;
17C8:  CLRF   x6D
....................                output_low(out_temp);
17CA:  BCF    F93.3
17CC:  BCF    F8A.3
....................                output_low(out_error);
17CE:  BCF    F93.5
17D0:  BCF    F8A.5
....................                state_AC = 5;
17D2:  MOVLW  05
17D4:  MOVWF  4F
....................             }
....................             break;
17D6:  BRA    17FA
....................          case 5: // DELAY 3
....................             if (val_timer_tam_dung <= 0)
17D8:  MOVF   5F,F
17DA:  BNZ   17E4
....................             {
....................                state_AC = 3;
17DC:  MOVLW  03
17DE:  MOVWF  4F
....................                reset_timer_data();
17E0:  CALL   062C
....................             }
....................             break;
17E4:  BRA    17FA
....................          case 10: // error
....................             flag_error = 1;
17E6:  MOVLW  01
17E8:  MOVWF  x6D
....................             output_low(out_fire);
17EA:  BCF    F93.2
17EC:  BCF    F8A.2
....................             output_high(out_temp);
17EE:  BCF    F93.3
17F0:  BSF    F8A.3
....................             output_high(out_error);
17F2:  BCF    F93.5
17F4:  BSF    F8A.5
....................             output_low(out_delay);
17F6:  BCF    F93.4
17F8:  BCF    F8A.4
....................             break;
....................          }
....................          break;
17FA:  BRA    180C
....................       case 1: // nhap mat khau
....................          break;
17FC:  BRA    180C
....................       case 2: // MENU TG TRI HOAN MPD
....................          break;
17FE:  BRA    180C
....................       case 3: // MENU TG CHAY LIEN TUC
....................          break;
1800:  BRA    180C
....................       case 4: // MENU TG TAM DUNG MPD
....................          break;
1802:  BRA    180C
....................       case 5: // MENU TG KTRA DA AC
....................          break;
1804:  BRA    180C
....................       case 6: // MENU TG KTRA DA MN
....................          break;
1806:  BRA    180C
....................       case 7: // MENU SO LAN KHOI DONG
....................          break;
1808:  BRA    180C
....................       case 8: // MENU cai dat mat dinh
....................          break;
180A:  BRA    180C
....................       case 9: // Loading screen
....................          // loading xong chay tinh nang chinh
....................          break;
....................       }
.................... 
....................       // kiem tra phim nhan
....................       output_float(sw_down);
180C:  BSF    F92.1
....................       switch (key_scan())
180E:  GOTO   0B0E
1812:  MOVLW  01
1814:  SUBWF  01,W
1816:  ADDLW  FC
1818:  BC    18AA
181A:  ADDLW  04
181C:  GOTO   1946
....................       {
....................       case 0x01: // nut menu duoc nhan
....................          lcd_init();
1820:  CALL   044C
....................          timer_exit = 30;
1824:  MOVLW  1E
1826:  MOVWF  53
....................          timer_backlight = 250;
1828:  MOVLW  FA
182A:  MOVWF  54
....................          process_menu();
182C:  GOTO   0CE6
....................          delay_ms(200);
1830:  MOVLW  C8
1832:  MOVLB  1
1834:  MOVWF  x2E
1836:  MOVLB  0
1838:  CALL   0358
....................          break;
183C:  BRA    18AA
.................... 
....................       case 0x02: // nut up duoc nhan
....................          timer_exit = 90;
183E:  MOVLW  5A
1840:  MOVWF  53
....................          timer_backlight = 250;
1842:  MOVLW  FA
1844:  MOVWF  54
....................          process_up();
1846:  GOTO   0E80
....................          if (mode >= 2 && mode <= 7)
184A:  MOVF   50,W
184C:  SUBLW  01
184E:  BC    185A
1850:  MOVF   50,W
1852:  SUBLW  07
1854:  BNC   185A
....................             write_data();
1856:  CALL   0D80
....................          delay_ms(200);
185A:  MOVLW  C8
185C:  MOVLB  1
185E:  MOVWF  x2E
1860:  MOVLB  0
1862:  CALL   0358
....................          break;
1866:  BRA    18AA
.................... 
....................       case 0x03: // nut down duoc nhan
....................          timer_exit = 90;
1868:  MOVLW  5A
186A:  MOVWF  53
....................          timer_backlight = 250;
186C:  MOVLW  FA
186E:  MOVWF  54
....................          process_down();
1870:  GOTO   0F6A
....................          if (mode >= 2 && mode <= 7)
1874:  MOVF   50,W
1876:  SUBLW  01
1878:  BC    1884
187A:  MOVF   50,W
187C:  SUBLW  07
187E:  BNC   1884
....................             write_data();
1880:  CALL   0D80
....................          delay_ms(200);
1884:  MOVLW  C8
1886:  MOVLB  1
1888:  MOVWF  x2E
188A:  MOVLB  0
188C:  CALL   0358
....................          break;
1890:  BRA    18AA
.................... 
....................       case 0x04: // nut exit duoc nhan
....................          timer_exit = 90;
1892:  MOVLW  5A
1894:  MOVWF  53
....................          timer_backlight = 250;
1896:  MOVLW  FA
1898:  MOVWF  54
....................          process_exit();
189A:  GOTO   1044
....................          delay_ms(200);
189E:  MOVLW  C8
18A0:  MOVLB  1
18A2:  MOVWF  x2E
18A4:  MOVLB  0
18A6:  CALL   0358
....................          break;
....................       }
.................... 
....................       // chuong trinh hien thi
....................       sum_out = 0;
18AA:  CLRF   x77
.................... 
....................       if (sum_out > sum_out_old)
18AC:  MOVF   x77,W
18AE:  SUBWF  x78,W
18B0:  BC    18BA
....................       {
....................          loop_not_display = 3;
18B2:  MOVLW  03
18B4:  MOVWF  x79
....................          timer_backlight = 250;
18B6:  MOVLW  FA
18B8:  MOVWF  54
....................       }
....................       sum_out_old = sum_out;
18BA:  MOVFF  77,78
.................... 
....................       disable_reset();
18BE:  CALL   0382
.................... 
....................       switch (loop_not_display)
18C2:  MOVF   x79,W
18C4:  XORLW  01
18C6:  BZ    18CE
18C8:  XORLW  01
18CA:  BZ    18DC
18CC:  BRA    18E0
....................       {
....................       case 1:
....................          lcd_init();
18CE:  CALL   044C
....................          loop_not_display--;
18D2:  DECF   x79,F
....................          if (mode != 0)
18D4:  MOVF   50,F
18D6:  BZ    18DA
....................             refresh_menu = 1;
18D8:  BSF    52.0
....................          break;
18DA:  BRA    18E0
....................       case 0:
....................          display_center();
18DC:  GOTO   10A4
....................          break;
....................       }
.................... 
....................       disable_reset();
18E0:  CALL   0382
18E4:  BRA    16FE
....................    }
.................... }
.................... 
18E6:  BRA    18E6
.................... //=========================
.................... void init_data(void)
.................... {
....................    // con tro phuc vu cai dat
....................    *sch_1 = 0, *sch_2 = 0, val_sch_1 = 0, val_sch_2 = 0;
*
0546:  MOVFF  2A,FE9
054A:  MOVFF  2B,FEA
054E:  CLRF   FEF
0550:  MOVLW  00
0552:  MOVFF  2C,FE9
0556:  MOVFF  2D,FEA
055A:  CLRF   FEF
055C:  MOVLW  00
055E:  CLRF   2E
0560:  CLRF   2F
....................    str_temp = "";
0562:  CLRF   FEA
0564:  MOVLW  35
0566:  MOVWF  FE9
0568:  MOVLW  00
056A:  RCALL  00AE
056C:  TBLRD*-
056E:  TBLRD*+
0570:  MOVF   FF5,W
0572:  MOVWF  FEE
0574:  IORLW  00
0576:  BNZ   056E
....................    time_reset_password = 0;
0578:  CLRF   4E
.................... 
....................    state_AC = 0;
057A:  CLRF   4F
....................    mode = 9;
057C:  MOVLW  09
057E:  MOVWF  50
....................    state_mn = 0;
0580:  CLRF   51
....................    refresh_menu = 0;
0582:  BCF    52.0
.................... 
....................    timer_exit = 0;
0584:  CLRF   53
....................    timer_backlight = 240;
0586:  MOVLW  F0
0588:  MOVWF  54
.................... 
....................    val_timer_tri_hoan = timer_tri_hoan, timer_tri_hoan_md = 60;                                                // LONG DELAY 1
058A:  MOVFF  56,55
058E:  MOVLW  3C
0590:  MOVWF  57
....................    val_counter_restart_mpd = 1, counter_restart_mpd_current = counter_restart_mpd, counter_restart_mpd_md = 4; // LONG SO LAN KHOI DONG LAI MPD
0592:  MOVLW  01
0594:  MOVWF  58
0596:  MOVFF  59,5B
059A:  MOVLW  04
059C:  MOVWF  5A
....................    val_timer_chay_lien_tuc = timer_chay_lien_tuc, timer_chay_lien_tuc_md = 3;                                  // LONG DELAY 2
059E:  MOVFF  5D,5C
05A2:  MOVLW  03
05A4:  MOVWF  5E
....................    val_timer_tam_dung = timer_tam_dung, timer_tam_dung_md = 60;                                                // LONG DELAY 3
05A6:  MOVFF  60,5F
05AA:  MOVLW  3C
05AC:  MOVWF  x61
....................    val_timer_ktra_AC = timer_ktra_AC, timer_ktra_AC_md = 60;                                                   // LONG KT AC TIMER
05AE:  MOVFF  63,62
05B2:  MOVWF  x64
....................    flag_error = 0;                                                                                             // LONG FLAG = 0 la ko loi, = 1 la LOI
05B4:  CLRF   x6D
....................    flag_mn = 0;
05B6:  CLRF   x6E
....................    val_timer_ktra_mn = timer_ktra_mn, timer_ktra_mn_md = 30; // LONG KT MN TIMER
05B8:  MOVFF  66,65
05BC:  MOVLW  1E
05BE:  MOVWF  x67
....................    val_timer_on_mpd = 20, timer_on_mpd = 20;
05C0:  MOVLW  14
05C2:  MOVWF  x68
05C4:  MOVWF  x69
....................    val_timer_off_mpd = 20, timer_off_mpd = 20;
05C6:  MOVWF  x6A
05C8:  MOVWF  x6B
.................... 
....................    val_loading = 0;
05CA:  CLRF   x6C
.................... 
....................    counter_timer0 = 0, flag_timer_60s_password = 0;
05CC:  CLRF   x70
05CE:  CLRF   x6F
05D0:  CLRF   x74
....................    flag_timer_tri_hoan_60s = 0, flag_timer_chay_lien_tuc_3600s = 0, flag_timer_tam_dung_60s = 0;
05D2:  CLRF   x73
05D4:  CLRF   x72
05D6:  CLRF   x71
05D8:  CLRF   x75
.................... 
....................    pwm_lcd = 0;
05DA:  CLRF   x76
....................    sum_out = 0, sum_out_old = 0, loop_not_display = 0;
05DC:  CLRF   x77
05DE:  CLRF   x78
05E0:  CLRF   x79
05E2:  GOTO   16FE (RETURN)
.................... }
.................... char check_mn(void)
.................... {
....................    flag_mn = 1;
*
0ADC:  MOVLW  01
0ADE:  MOVWF  x6E
....................    if (status_mn())
0AE0:  BSF    F94.2
0AE2:  BTFSC  F82.2
0AE4:  BRA    0AF2
....................    {
....................       flag_mn = 0;
0AE6:  CLRF   x6E
....................       val_timer_ktra_mn = timer_ktra_mn;
0AE8:  MOVFF  66,65
....................       return 1; // do dc d.a mn
0AEC:  MOVLW  01
0AEE:  MOVWF  01
0AF0:  BRA    0B0C
....................    }
....................    if (val_timer_ktra_mn <= 0)
0AF2:  MOVF   x65,F
0AF4:  BNZ   0B08
....................    {
....................       flag_mn = 0;
0AF6:  CLRF   x6E
....................       val_timer_ktra_mn = timer_ktra_mn;
0AF8:  MOVFF  66,65
....................       return status_mn(); // ket thuc delay do mn va return ket qua do
0AFC:  BSF    F94.2
0AFE:  MOVLW  00
0B00:  BTFSS  F82.2
0B02:  MOVLW  01
0B04:  MOVWF  01
0B06:  BRA    0B0C
....................    }
....................    return 2; // dang chay delay do mn
0B08:  MOVLW  02
0B0A:  MOVWF  01
0B0C:  RETURN 0
.................... }
.................... void check_AC(void)
.................... {
....................    if (state_AC <= 1 && (!(status_AC())))
*
05E6:  MOVF   4F,W
05E8:  SUBLW  01
05EA:  BNC   0608
05EC:  BSF    F94.3
05EE:  BTFSS  F82.3
05F0:  BRA    0608
....................    {
....................       state_AC = 0; // chay trang thai dem do AC
05F2:  CLRF   4F
....................       if (val_timer_ktra_AC <= 0)
05F4:  MOVF   x62,F
05F6:  BNZ   0606
....................       {
....................          if (!(status_AC()))
05F8:  BSF    F94.3
05FA:  BTFSS  F82.3
05FC:  BRA    0602
....................          {
....................             state_AC = 2;
05FE:  MOVLW  02
0600:  MOVWF  4F
....................          }
....................          val_timer_ktra_AC = timer_ktra_AC;
0602:  MOVFF  63,62
....................       }
....................    }
0606:  BRA    0628
....................    else if (state_AC != 1 && (status_AC()))
0608:  DECFSZ 4F,W
060A:  BRA    060E
060C:  BRA    0628
060E:  BSF    F94.3
0610:  BTFSC  F82.3
0612:  BRA    0628
....................    {
....................       state_AC = 0; // chay trang thai dem do AC
0614:  CLRF   4F
....................       if (val_timer_ktra_AC <= 0)
0616:  MOVF   x62,F
0618:  BNZ   0628
....................       {
....................          if (status_AC())
061A:  BSF    F94.3
061C:  BTFSC  F82.3
061E:  BRA    0624
....................          {
....................             state_AC = 1;
0620:  MOVLW  01
0622:  MOVWF  4F
....................          }
....................          val_timer_ktra_AC = timer_ktra_AC;
0624:  MOVFF  63,62
....................       }
....................    }
0628:  GOTO   1716 (RETURN)
.................... }
.................... 
.................... void display(char code_print)
.................... {
....................    switch (code_print)
*
085A:  MOVLB  1
085C:  MOVF   x28,W
085E:  ADDLW  F8
0860:  BTFSC  FD8.0
0862:  BRA    0AAE
0864:  ADDLW  08
0866:  MOVLB  0
0868:  GOTO   0AB2
....................    {
....................    case 0: // ko in
....................       break;
086C:  MOVLB  1
086E:  BRA    0AAE
....................    case 1: // delay 1
....................       LCD_PUTCMD(Line_1);
0870:  MOVLW  80
0872:  MOVLB  1
0874:  MOVWF  x2D
0876:  MOVLB  0
0878:  RCALL  042E
....................       PRINTF(LCD_PUTCHAR, "TG TRI HOAN MPD");
087A:  MOVLW  C0
087C:  MOVWF  FF6
087E:  MOVLW  00
0880:  MOVWF  FF7
0882:  RCALL  0670
....................       clear_lcd();
0884:  MOVLB  1
0886:  CLRF   x29
0888:  MOVLB  0
088A:  RCALL  06B4
....................       LCD_PUTCMD(Line_2);
088C:  MOVLW  C0
088E:  MOVLB  1
0890:  MOVWF  x2D
0892:  MOVLB  0
0894:  RCALL  042E
....................       PRINTF(LCD_PUTCHAR, "PHUT Long: %01u", val_timer_tri_hoan);
0896:  MOVLW  D0
0898:  MOVWF  FF6
089A:  MOVLW  00
089C:  MOVWF  FF7
089E:  MOVLW  0B
08A0:  MOVLB  1
08A2:  MOVWF  x29
08A4:  MOVLB  0
08A6:  RCALL  078A
08A8:  MOVFF  55,129
08AC:  MOVLW  08
08AE:  MOVLB  1
08B0:  MOVWF  x2A
08B2:  MOVLB  0
08B4:  RCALL  07DE
....................       clear_lcd();
08B6:  MOVLB  1
08B8:  CLRF   x29
08BA:  MOVLB  0
08BC:  RCALL  06B4
....................       break;
08BE:  MOVLB  1
08C0:  BRA    0AAE
....................    case 2: // delay 2
....................       LCD_PUTCMD(Line_1);
08C2:  MOVLW  80
08C4:  MOVLB  1
08C6:  MOVWF  x2D
08C8:  MOVLB  0
08CA:  RCALL  042E
....................       PRINTF(LCD_PUTCHAR, "TG CHAY LIEN TUC");
08CC:  MOVLW  E0
08CE:  MOVWF  FF6
08D0:  MOVLW  00
08D2:  MOVWF  FF7
08D4:  RCALL  0670
....................       clear_lcd();
08D6:  MOVLB  1
08D8:  CLRF   x29
08DA:  MOVLB  0
08DC:  RCALL  06B4
....................       LCD_PUTCMD(Line_2);
08DE:  MOVLW  C0
08E0:  MOVLB  1
08E2:  MOVWF  x2D
08E4:  MOVLB  0
08E6:  RCALL  042E
....................       PRINTF(LCD_PUTCHAR, "GIO: %01u", val_timer_chay_lien_tuc);
08E8:  MOVLW  F2
08EA:  MOVWF  FF6
08EC:  MOVLW  00
08EE:  MOVWF  FF7
08F0:  MOVLW  05
08F2:  MOVLB  1
08F4:  MOVWF  x29
08F6:  MOVLB  0
08F8:  RCALL  078A
08FA:  MOVFF  5C,129
08FE:  MOVLW  08
0900:  MOVLB  1
0902:  MOVWF  x2A
0904:  MOVLB  0
0906:  RCALL  07DE
....................       clear_lcd();
0908:  MOVLB  1
090A:  CLRF   x29
090C:  MOVLB  0
090E:  RCALL  06B4
....................       break;
0910:  MOVLB  1
0912:  BRA    0AAE
....................    case 3: // delay 3
....................       LCD_PUTCMD(Line_1);
0914:  MOVLW  80
0916:  MOVLB  1
0918:  MOVWF  x2D
091A:  MOVLB  0
091C:  RCALL  042E
....................       PRINTF(LCD_PUTCHAR, "TG TAM DUNG MPD");
091E:  MOVLW  FC
0920:  MOVWF  FF6
0922:  MOVLW  00
0924:  MOVWF  FF7
0926:  RCALL  0670
....................       clear_lcd();
0928:  MOVLB  1
092A:  CLRF   x29
092C:  MOVLB  0
092E:  RCALL  06B4
....................       LCD_PUTCMD(Line_2);
0930:  MOVLW  C0
0932:  MOVLB  1
0934:  MOVWF  x2D
0936:  MOVLB  0
0938:  RCALL  042E
....................       PRINTF(LCD_PUTCHAR, "PHUT: %01u", val_timer_tam_dung);
093A:  MOVLW  0C
093C:  MOVWF  FF6
093E:  MOVLW  01
0940:  MOVWF  FF7
0942:  MOVLW  06
0944:  MOVLB  1
0946:  MOVWF  x29
0948:  MOVLB  0
094A:  RCALL  078A
094C:  MOVFF  5F,129
0950:  MOVLW  08
0952:  MOVLB  1
0954:  MOVWF  x2A
0956:  MOVLB  0
0958:  RCALL  07DE
....................       clear_lcd();
095A:  MOVLB  1
095C:  CLRF   x29
095E:  MOVLB  0
0960:  RCALL  06B4
....................       break;
0962:  MOVLB  1
0964:  BRA    0AAE
....................    case 4: // Do AC
....................       LCD_PUTCMD(Line_1);
0966:  MOVLW  80
0968:  MOVLB  1
096A:  MOVWF  x2D
096C:  MOVLB  0
096E:  RCALL  042E
....................       PRINTF(LCD_PUTCHAR, "KIEM TRA AC");
0970:  MOVLW  18
0972:  MOVWF  FF6
0974:  MOVLW  01
0976:  MOVWF  FF7
0978:  RCALL  0670
....................       clear_lcd()
097A:  MOVLB  1
097C:  CLRF   x29
097E:  MOVLB  0
0980:  RCALL  06B4
....................           LCD_PUTCMD(Line_2);
0982:  MOVLW  C0
0984:  MOVLB  1
0986:  MOVWF  x2D
0988:  MOVLB  0
098A:  RCALL  042E
....................       PRINTF(LCD_PUTCHAR, "GIAY: %01u", val_timer_ktra_AC);
098C:  MOVLW  24
098E:  MOVWF  FF6
0990:  MOVLW  01
0992:  MOVWF  FF7
0994:  MOVLW  06
0996:  MOVLB  1
0998:  MOVWF  x29
099A:  MOVLB  0
099C:  RCALL  078A
099E:  MOVFF  62,129
09A2:  MOVLW  08
09A4:  MOVLB  1
09A6:  MOVWF  x2A
09A8:  MOVLB  0
09AA:  RCALL  07DE
....................       clear_lcd();
09AC:  MOVLB  1
09AE:  CLRF   x29
09B0:  MOVLB  0
09B2:  RCALL  06B4
....................       break;
09B4:  MOVLB  1
09B6:  BRA    0AAE
....................    case 5: // AC BINH THUONG
....................       LCD_PUTCMD(Line_1);
09B8:  MOVLW  80
09BA:  MOVLB  1
09BC:  MOVWF  x2D
09BE:  MOVLB  0
09C0:  RCALL  042E
....................       PRINTF(LCD_PUTCHAR, "D.AP AC BTHUONG");
09C2:  MOVLW  30
09C4:  MOVWF  FF6
09C6:  MOVLW  01
09C8:  MOVWF  FF7
09CA:  RCALL  0670
....................       clear_lcd();
09CC:  MOVLB  1
09CE:  CLRF   x29
09D0:  MOVLB  0
09D2:  RCALL  06B4
....................       if (flag_error)
09D4:  MOVF   x6D,F
09D6:  BZ    0A08
....................       {
....................          LCD_PUTCMD(Line_2);
09D8:  MOVLW  C0
09DA:  MOVLB  1
09DC:  MOVWF  x2D
09DE:  MOVLB  0
09E0:  RCALL  042E
....................          clear_lcd();
09E2:  MOVLB  1
09E4:  CLRF   x29
09E6:  MOVLB  0
09E8:  RCALL  06B4
....................          LCD_PUTCMD(Line_2);
09EA:  MOVLW  C0
09EC:  MOVLB  1
09EE:  MOVWF  x2D
09F0:  MOVLB  0
09F2:  RCALL  042E
....................          PRINTF(LCD_PUTCHAR, "MPD LOI");
09F4:  MOVLW  40
09F6:  MOVWF  FF6
09F8:  MOVLW  01
09FA:  MOVWF  FF7
09FC:  RCALL  0670
....................          clear_lcd();
09FE:  MOVLB  1
0A00:  CLRF   x29
0A02:  MOVLB  0
0A04:  RCALL  06B4
....................       }
0A06:  BRA    0A24
....................       else
....................       {
....................          LCD_PUTCMD(Line_2);
0A08:  MOVLW  C0
0A0A:  MOVLB  1
0A0C:  MOVWF  x2D
0A0E:  MOVLB  0
0A10:  RCALL  042E
....................          PRINTF(LCD_PUTCHAR, "MPD TOT");
0A12:  MOVLW  48
0A14:  MOVWF  FF6
0A16:  MOVLW  01
0A18:  MOVWF  FF7
0A1A:  RCALL  0670
....................          clear_lcd();
0A1C:  MOVLB  1
0A1E:  CLRF   x29
0A20:  MOVLB  0
0A22:  RCALL  06B4
....................       }
....................       break;
0A24:  MOVLB  1
0A26:  BRA    0AAE
....................    case 6: // CHAY MPD
....................       LCD_PUTCMD(Line_1);
0A28:  MOVLW  80
0A2A:  MOVLB  1
0A2C:  MOVWF  x2D
0A2E:  MOVLB  0
0A30:  RCALL  042E
....................       PRINTF(LCD_PUTCHAR, "CHAY MPD");
0A32:  MOVLW  50
0A34:  MOVWF  FF6
0A36:  MOVLW  01
0A38:  MOVWF  FF7
0A3A:  RCALL  0670
....................       clear_lcd();
0A3C:  MOVLB  1
0A3E:  CLRF   x29
0A40:  MOVLB  0
0A42:  RCALL  06B4
....................       LCD_PUTCMD(Line_2);
0A44:  MOVLW  C0
0A46:  MOVLB  1
0A48:  MOVWF  x2D
0A4A:  MOVLB  0
0A4C:  RCALL  042E
....................       PRINTF(LCD_PUTCHAR, "LAN: %01u", val_counter_restart_mpd);
0A4E:  MOVLW  5A
0A50:  MOVWF  FF6
0A52:  MOVLW  01
0A54:  MOVWF  FF7
0A56:  MOVLW  05
0A58:  MOVLB  1
0A5A:  MOVWF  x29
0A5C:  MOVLB  0
0A5E:  RCALL  078A
0A60:  MOVFF  58,129
0A64:  MOVLW  08
0A66:  MOVLB  1
0A68:  MOVWF  x2A
0A6A:  MOVLB  0
0A6C:  RCALL  07DE
....................       clear_lcd();
0A6E:  MOVLB  1
0A70:  CLRF   x29
0A72:  MOVLB  0
0A74:  RCALL  06B4
....................       break;
0A76:  MOVLB  1
0A78:  BRA    0AAE
....................    case 7: // error
....................       LCD_PUTCMD(Line_1);
0A7A:  MOVLW  80
0A7C:  MOVLB  1
0A7E:  MOVWF  x2D
0A80:  MOVLB  0
0A82:  RCALL  042E
....................       PRINTF(LCD_PUTCHAR, "MPD LOI");
0A84:  MOVLW  64
0A86:  MOVWF  FF6
0A88:  MOVLW  01
0A8A:  MOVWF  FF7
0A8C:  RCALL  0670
....................       clear_lcd();
0A8E:  MOVLB  1
0A90:  CLRF   x29
0A92:  MOVLB  0
0A94:  RCALL  06B4
....................       LCD_PUTCMD(Line_2);
0A96:  MOVLW  C0
0A98:  MOVLB  1
0A9A:  MOVWF  x2D
0A9C:  MOVLB  0
0A9E:  RCALL  042E
....................       clear_lcd();
0AA0:  MOVLB  1
0AA2:  CLRF   x29
0AA4:  MOVLB  0
0AA6:  RCALL  06B4
....................       break;
0AA8:  MOVLB  1
0AAA:  BRA    0AAE
0AAC:  MOVLB  1
....................    }
0AAE:  MOVLB  0
0AB0:  RETURN 0
.................... }
.................... 
.................... void default_data(void)
.................... {
....................    timer_tri_hoan = timer_tri_hoan_md;           // LONG DELAY 1
*
0D64:  MOVFF  57,56
....................    counter_restart_mpd = counter_restart_mpd_md; // LONG SO LAN KHOI DONG LAI MPD
0D68:  MOVFF  5A,59
....................    timer_chay_lien_tuc = timer_chay_lien_tuc_md; // LONG DELAY 2
0D6C:  MOVFF  5E,5D
....................    timer_tam_dung = timer_tam_dung_md;           // LONG DELAY 3
0D70:  MOVFF  61,60
....................    timer_ktra_AC = timer_ktra_AC_md;             // LONG KT AC TIMER
0D74:  MOVFF  64,63
....................    timer_ktra_mn = timer_ktra_mn_md;             // LONG KT MN TIMER
0D78:  MOVFF  67,66
0D7C:  GOTO   0F36 (RETURN)
.................... }
.................... void display_center(void)
.................... {
.................... 
....................    unsigned char menu_main[10][17] = {{""},
....................                                       {"MAT KHAU !"},
....................                                       {"TG TRI HOAN MPD"},
....................                                       {"TG CHAY LIEN TUC"},
....................                                       {"TG TAM DUNG MPD"},
....................                                       {"TG KTRA D.AP AC"},
....................                                       {"TG KTRA D.AP MPD"},
....................                                       {"SO LAN KHOI DONG"},
....................                                       {"CAI DAT MAC DINH"},
....................                                       {""}};
*
10A4:  CLRF   x7E
10A6:  CLRF   x7F
10A8:  CLRF   x80
10AA:  CLRF   x81
10AC:  CLRF   x82
10AE:  CLRF   x83
10B0:  CLRF   x84
10B2:  CLRF   x85
10B4:  CLRF   x86
10B6:  CLRF   x87
10B8:  CLRF   x88
10BA:  CLRF   x89
10BC:  CLRF   x8A
10BE:  CLRF   x8B
10C0:  CLRF   x8C
10C2:  CLRF   x8D
10C4:  CLRF   x8E
10C6:  MOVLW  4D
10C8:  MOVWF  x8F
10CA:  MOVLW  41
10CC:  MOVWF  x90
10CE:  MOVLW  54
10D0:  MOVWF  x91
10D2:  MOVLW  20
10D4:  MOVWF  x92
10D6:  MOVLW  4B
10D8:  MOVWF  x93
10DA:  MOVLW  48
10DC:  MOVWF  x94
10DE:  MOVLW  41
10E0:  MOVWF  x95
10E2:  MOVLW  55
10E4:  MOVWF  x96
10E6:  MOVLW  20
10E8:  MOVWF  x97
10EA:  MOVLW  21
10EC:  MOVWF  x98
10EE:  CLRF   x99
10F0:  CLRF   x9A
10F2:  CLRF   x9B
10F4:  CLRF   x9C
10F6:  CLRF   x9D
10F8:  CLRF   x9E
10FA:  CLRF   x9F
10FC:  MOVLW  54
10FE:  MOVWF  xA0
1100:  MOVLW  47
1102:  MOVWF  xA1
1104:  MOVLW  20
1106:  MOVWF  xA2
1108:  MOVLW  54
110A:  MOVWF  xA3
110C:  MOVLW  52
110E:  MOVWF  xA4
1110:  MOVLW  49
1112:  MOVWF  xA5
1114:  MOVLW  20
1116:  MOVWF  xA6
1118:  MOVLW  48
111A:  MOVWF  xA7
111C:  MOVLW  4F
111E:  MOVWF  xA8
1120:  MOVLW  41
1122:  MOVWF  xA9
1124:  MOVLW  4E
1126:  MOVWF  xAA
1128:  MOVLW  20
112A:  MOVWF  xAB
112C:  MOVLW  4D
112E:  MOVWF  xAC
1130:  MOVLW  50
1132:  MOVWF  xAD
1134:  MOVLW  44
1136:  MOVWF  xAE
1138:  CLRF   xAF
113A:  CLRF   xB0
113C:  MOVLW  54
113E:  MOVWF  xB1
1140:  MOVLW  47
1142:  MOVWF  xB2
1144:  MOVLW  20
1146:  MOVWF  xB3
1148:  MOVLW  43
114A:  MOVWF  xB4
114C:  MOVLW  48
114E:  MOVWF  xB5
1150:  MOVLW  41
1152:  MOVWF  xB6
1154:  MOVLW  59
1156:  MOVWF  xB7
1158:  MOVLW  20
115A:  MOVWF  xB8
115C:  MOVLW  4C
115E:  MOVWF  xB9
1160:  MOVLW  49
1162:  MOVWF  xBA
1164:  MOVLW  45
1166:  MOVWF  xBB
1168:  MOVLW  4E
116A:  MOVWF  xBC
116C:  MOVLW  20
116E:  MOVWF  xBD
1170:  MOVLW  54
1172:  MOVWF  xBE
1174:  MOVLW  55
1176:  MOVWF  xBF
1178:  MOVLW  43
117A:  MOVWF  xC0
117C:  CLRF   xC1
117E:  MOVLW  54
1180:  MOVWF  xC2
1182:  MOVLW  47
1184:  MOVWF  xC3
1186:  MOVLW  20
1188:  MOVWF  xC4
118A:  MOVLW  54
118C:  MOVWF  xC5
118E:  MOVLW  41
1190:  MOVWF  xC6
1192:  MOVLW  4D
1194:  MOVWF  xC7
1196:  MOVLW  20
1198:  MOVWF  xC8
119A:  MOVLW  44
119C:  MOVWF  xC9
119E:  MOVLW  55
11A0:  MOVWF  xCA
11A2:  MOVLW  4E
11A4:  MOVWF  xCB
11A6:  MOVLW  47
11A8:  MOVWF  xCC
11AA:  MOVLW  20
11AC:  MOVWF  xCD
11AE:  MOVLW  4D
11B0:  MOVWF  xCE
11B2:  MOVLW  50
11B4:  MOVWF  xCF
11B6:  MOVLW  44
11B8:  MOVWF  xD0
11BA:  CLRF   xD1
11BC:  CLRF   xD2
11BE:  MOVLW  54
11C0:  MOVWF  xD3
11C2:  MOVLW  47
11C4:  MOVWF  xD4
11C6:  MOVLW  20
11C8:  MOVWF  xD5
11CA:  MOVLW  4B
11CC:  MOVWF  xD6
11CE:  MOVLW  54
11D0:  MOVWF  xD7
11D2:  MOVLW  52
11D4:  MOVWF  xD8
11D6:  MOVLW  41
11D8:  MOVWF  xD9
11DA:  MOVLW  20
11DC:  MOVWF  xDA
11DE:  MOVLW  44
11E0:  MOVWF  xDB
11E2:  MOVLW  2E
11E4:  MOVWF  xDC
11E6:  MOVLW  41
11E8:  MOVWF  xDD
11EA:  MOVLW  50
11EC:  MOVWF  xDE
11EE:  MOVLW  20
11F0:  MOVWF  xDF
11F2:  MOVLW  41
11F4:  MOVWF  xE0
11F6:  MOVLW  43
11F8:  MOVWF  xE1
11FA:  CLRF   xE2
11FC:  CLRF   xE3
11FE:  MOVLW  54
1200:  MOVWF  xE4
1202:  MOVLW  47
1204:  MOVWF  xE5
1206:  MOVLW  20
1208:  MOVWF  xE6
120A:  MOVLW  4B
120C:  MOVWF  xE7
120E:  MOVLW  54
1210:  MOVWF  xE8
1212:  MOVLW  52
1214:  MOVWF  xE9
1216:  MOVLW  41
1218:  MOVWF  xEA
121A:  MOVLW  20
121C:  MOVWF  xEB
121E:  MOVLW  44
1220:  MOVWF  xEC
1222:  MOVLW  2E
1224:  MOVWF  xED
1226:  MOVLW  41
1228:  MOVWF  xEE
122A:  MOVLW  50
122C:  MOVWF  xEF
122E:  MOVLW  20
1230:  MOVWF  xF0
1232:  MOVLW  4D
1234:  MOVWF  xF1
1236:  MOVLW  50
1238:  MOVWF  xF2
123A:  MOVLW  44
123C:  MOVWF  xF3
123E:  CLRF   xF4
1240:  MOVLW  53
1242:  MOVWF  xF5
1244:  MOVLW  4F
1246:  MOVWF  xF6
1248:  MOVLW  20
124A:  MOVWF  xF7
124C:  MOVLW  4C
124E:  MOVWF  xF8
1250:  MOVLW  41
1252:  MOVWF  xF9
1254:  MOVLW  4E
1256:  MOVWF  xFA
1258:  MOVLW  20
125A:  MOVWF  xFB
125C:  MOVLW  4B
125E:  MOVWF  xFC
1260:  MOVLW  48
1262:  MOVWF  xFD
1264:  MOVLW  4F
1266:  MOVWF  xFE
1268:  MOVLW  49
126A:  MOVWF  xFF
126C:  MOVLW  20
126E:  MOVLB  1
1270:  MOVWF  x00
1272:  MOVLW  44
1274:  MOVWF  x01
1276:  MOVLW  4F
1278:  MOVWF  x02
127A:  MOVLW  4E
127C:  MOVWF  x03
127E:  MOVLW  47
1280:  MOVWF  x04
1282:  CLRF   x05
1284:  MOVLW  43
1286:  MOVWF  x06
1288:  MOVLW  41
128A:  MOVWF  x07
128C:  MOVLW  49
128E:  MOVWF  x08
1290:  MOVLW  20
1292:  MOVWF  x09
1294:  MOVLW  44
1296:  MOVWF  x0A
1298:  MOVLW  41
129A:  MOVWF  x0B
129C:  MOVLW  54
129E:  MOVWF  x0C
12A0:  MOVLW  20
12A2:  MOVWF  x0D
12A4:  MOVLW  4D
12A6:  MOVWF  x0E
12A8:  MOVLW  41
12AA:  MOVWF  x0F
12AC:  MOVLW  43
12AE:  MOVWF  x10
12B0:  MOVLW  20
12B2:  MOVWF  x11
12B4:  MOVLW  44
12B6:  MOVWF  x12
12B8:  MOVLW  49
12BA:  MOVWF  x13
12BC:  MOVLW  4E
12BE:  MOVWF  x14
12C0:  MOVLW  48
12C2:  MOVWF  x15
12C4:  CLRF   x16
12C6:  CLRF   x17
.................... 
....................    if (refresh_menu)
12C8:  BTFSS  52.0
12CA:  BRA    1308
....................    {
....................       LCD_PUTCMD(Line_1); // Dua hien thi chu dau dong hang` duoi
12CC:  MOVLW  80
12CE:  MOVWF  x2D
12D0:  MOVLB  0
12D2:  CALL   042E
....................       PRINTF(LCD_PUTCHAR, "%s", menu_main[mode]);
12D6:  MOVF   50,W
12D8:  MULLW  11
12DA:  MOVF   FF3,W
12DC:  CLRF   03
12DE:  ADDLW  7E
12E0:  MOVWF  01
12E2:  MOVLW  00
12E4:  ADDWFC 03,F
12E6:  MOVFF  01,128
12EA:  MOVFF  03,129
12EE:  MOVFF  03,FEA
12F2:  MOVFF  01,FE9
12F6:  MOVLB  0
12F8:  CALL   0690
....................       clear_lcd();
12FC:  MOVLB  1
12FE:  CLRF   x29
1300:  MOVLB  0
1302:  CALL   06B4
1306:  MOVLB  1
....................    }
....................    LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
1308:  MOVLW  C0
130A:  MOVWF  x2D
130C:  MOVLB  0
130E:  CALL   042E
.................... 
....................    switch (mode)
1312:  MOVF   50,W
1314:  ADDLW  F6
1316:  BTFSC  FD8.0
1318:  BRA    1598
131A:  ADDLW  0A
131C:  GOTO   15CE
....................    {
....................    case 0: // LCD TINH NANG CHINH
....................       switch (state_AC)
1320:  MOVF   4F,W
1322:  ADDLW  F5
1324:  BC    1380
1326:  ADDLW  0B
1328:  GOTO   159E
....................       {
....................       case 0:
....................          display(do_ac);
132C:  MOVLW  04
132E:  MOVLB  1
1330:  MOVWF  x28
1332:  MOVLB  0
1334:  CALL   085A
....................          break;
1338:  BRA    1380
....................       case 1:
....................          display(ac_bthg);
133A:  MOVLW  05
133C:  MOVLB  1
133E:  MOVWF  x28
1340:  MOVLB  0
1342:  CALL   085A
....................          break;
1346:  BRA    1380
....................       case 2:
....................          display(tg_tri_hoan);
1348:  MOVLW  01
134A:  MOVLB  1
134C:  MOVWF  x28
134E:  MOVLB  0
1350:  CALL   085A
....................          break;
1354:  BRA    1380
....................       case 3:
....................          break;
1356:  BRA    1380
....................       case 4:
....................          display(tg_chay_lien_tuc);
1358:  MOVLW  02
135A:  MOVLB  1
135C:  MOVWF  x28
135E:  MOVLB  0
1360:  CALL   085A
....................          break;
1364:  BRA    1380
....................       case 5:
....................          display(tg_tam_dung);
1366:  MOVLW  03
1368:  MOVLB  1
136A:  MOVWF  x28
136C:  MOVLB  0
136E:  CALL   085A
....................          break;
1372:  BRA    1380
....................       case 10:
....................          display(error);
1374:  MOVLW  07
1376:  MOVLB  1
1378:  MOVWF  x28
137A:  MOVLB  0
137C:  CALL   085A
....................          break;
....................       }
....................       break;
1380:  BRA    1598
....................    case 1:                // nhap mat khau
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
1382:  MOVLW  C0
1384:  MOVLB  1
1386:  MOVWF  x2D
1388:  MOVLB  0
138A:  CALL   042E
....................       sch_1 = str_temp;
138E:  CLRF   2B
1390:  MOVLW  35
1392:  MOVWF  2A
....................       sch_1_s_set();
1394:  MOVLW  0B
1396:  MOVLB  1
1398:  MOVWF  x29
139A:  MOVLB  0
139C:  CALL   06B4
....................       break;
13A0:  BRA    1598
.................... 
....................    case 2:                // TG TRI HOAN MPD
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
13A2:  MOVLW  C0
13A4:  MOVLB  1
13A6:  MOVWF  x2D
13A8:  MOVLB  0
13AA:  CALL   042E
....................       PRINTF(LCD_PUTCHAR, "PHUT: <%01u>", timer_tri_hoan);
13AE:  MOVLW  6C
13B0:  MOVWF  FF6
13B2:  MOVLW  01
13B4:  MOVWF  FF7
13B6:  MOVLW  07
13B8:  MOVLB  1
13BA:  MOVWF  x29
13BC:  MOVLB  0
13BE:  CALL   078A
13C2:  MOVFF  56,129
13C6:  MOVLW  08
13C8:  MOVLB  1
13CA:  MOVWF  x2A
13CC:  MOVLB  0
13CE:  CALL   07DE
13D2:  MOVLW  3E
13D4:  MOVLB  1
13D6:  MOVWF  x2C
13D8:  MOVLB  0
13DA:  CALL   0660
....................       clear_lcd();
13DE:  MOVLB  1
13E0:  CLRF   x29
13E2:  MOVLB  0
13E4:  CALL   06B4
....................       break;
13E8:  BRA    1598
.................... 
....................    case 3:                // TG CHAY LIEN TUC
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
13EA:  MOVLW  C0
13EC:  MOVLB  1
13EE:  MOVWF  x2D
13F0:  MOVLB  0
13F2:  CALL   042E
....................       PRINTF(LCD_PUTCHAR, "GIO: <%01u>", timer_chay_lien_tuc);
13F6:  MOVLW  7A
13F8:  MOVWF  FF6
13FA:  MOVLW  01
13FC:  MOVWF  FF7
13FE:  MOVLW  06
1400:  MOVLB  1
1402:  MOVWF  x29
1404:  MOVLB  0
1406:  CALL   078A
140A:  MOVFF  5D,129
140E:  MOVLW  08
1410:  MOVLB  1
1412:  MOVWF  x2A
1414:  MOVLB  0
1416:  CALL   07DE
141A:  MOVLW  3E
141C:  MOVLB  1
141E:  MOVWF  x2C
1420:  MOVLB  0
1422:  CALL   0660
....................       clear_lcd();
1426:  MOVLB  1
1428:  CLRF   x29
142A:  MOVLB  0
142C:  CALL   06B4
....................       break;
1430:  BRA    1598
.................... 
....................    case 4:                // TG TAM DUNG MPD
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
1432:  MOVLW  C0
1434:  MOVLB  1
1436:  MOVWF  x2D
1438:  MOVLB  0
143A:  CALL   042E
....................       PRINTF(LCD_PUTCHAR, "PHUT: <%01u>", timer_tam_dung);
143E:  MOVLW  86
1440:  MOVWF  FF6
1442:  MOVLW  01
1444:  MOVWF  FF7
1446:  MOVLW  07
1448:  MOVLB  1
144A:  MOVWF  x29
144C:  MOVLB  0
144E:  CALL   078A
1452:  MOVFF  60,129
1456:  MOVLW  08
1458:  MOVLB  1
145A:  MOVWF  x2A
145C:  MOVLB  0
145E:  CALL   07DE
1462:  MOVLW  3E
1464:  MOVLB  1
1466:  MOVWF  x2C
1468:  MOVLB  0
146A:  CALL   0660
....................       clear_lcd();
146E:  MOVLB  1
1470:  CLRF   x29
1472:  MOVLB  0
1474:  CALL   06B4
....................       break;
1478:  BRA    1598
....................    case 5:                // TG KTRA DA AC
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
147A:  MOVLW  C0
147C:  MOVLB  1
147E:  MOVWF  x2D
1480:  MOVLB  0
1482:  CALL   042E
....................       PRINTF(LCD_PUTCHAR, "GIAY: <%01u>", timer_ktra_AC);
1486:  MOVLW  94
1488:  MOVWF  FF6
148A:  MOVLW  01
148C:  MOVWF  FF7
148E:  MOVLW  07
1490:  MOVLB  1
1492:  MOVWF  x29
1494:  MOVLB  0
1496:  CALL   078A
149A:  MOVFF  63,129
149E:  MOVLW  08
14A0:  MOVLB  1
14A2:  MOVWF  x2A
14A4:  MOVLB  0
14A6:  CALL   07DE
14AA:  MOVLW  3E
14AC:  MOVLB  1
14AE:  MOVWF  x2C
14B0:  MOVLB  0
14B2:  CALL   0660
....................       clear_lcd();
14B6:  MOVLB  1
14B8:  CLRF   x29
14BA:  MOVLB  0
14BC:  CALL   06B4
....................       break;
14C0:  BRA    1598
....................    case 6:                // TG KTRA DA MN
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
14C2:  MOVLW  C0
14C4:  MOVLB  1
14C6:  MOVWF  x2D
14C8:  MOVLB  0
14CA:  CALL   042E
....................       PRINTF(LCD_PUTCHAR, "GIAY: <%01u>", timer_ktra_mn);
14CE:  MOVLW  A2
14D0:  MOVWF  FF6
14D2:  MOVLW  01
14D4:  MOVWF  FF7
14D6:  MOVLW  07
14D8:  MOVLB  1
14DA:  MOVWF  x29
14DC:  MOVLB  0
14DE:  CALL   078A
14E2:  MOVFF  66,129
14E6:  MOVLW  08
14E8:  MOVLB  1
14EA:  MOVWF  x2A
14EC:  MOVLB  0
14EE:  CALL   07DE
14F2:  MOVLW  3E
14F4:  MOVLB  1
14F6:  MOVWF  x2C
14F8:  MOVLB  0
14FA:  CALL   0660
....................       clear_lcd();
14FE:  MOVLB  1
1500:  CLRF   x29
1502:  MOVLB  0
1504:  CALL   06B4
....................       break;
1508:  BRA    1598
....................    case 7:                // SO LAN KHOI DONG
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
150A:  MOVLW  C0
150C:  MOVLB  1
150E:  MOVWF  x2D
1510:  MOVLB  0
1512:  CALL   042E
....................       PRINTF(LCD_PUTCHAR, "LAN: <%01u>", counter_restart_mpd);
1516:  MOVLW  B0
1518:  MOVWF  FF6
151A:  MOVLW  01
151C:  MOVWF  FF7
151E:  MOVLW  06
1520:  MOVLB  1
1522:  MOVWF  x29
1524:  MOVLB  0
1526:  CALL   078A
152A:  MOVFF  59,129
152E:  MOVLW  08
1530:  MOVLB  1
1532:  MOVWF  x2A
1534:  MOVLB  0
1536:  CALL   07DE
153A:  MOVLW  3E
153C:  MOVLB  1
153E:  MOVWF  x2C
1540:  MOVLB  0
1542:  CALL   0660
....................       clear_lcd();
1546:  MOVLB  1
1548:  CLRF   x29
154A:  MOVLB  0
154C:  CALL   06B4
....................       break;
1550:  BRA    1598
....................    case 8: // cai dat mat dinh
....................       yesno();
1552:  MOVLW  09
1554:  MOVLB  1
1556:  MOVWF  x29
1558:  MOVLB  0
155A:  CALL   06B4
....................       break;
155E:  BRA    1598
....................    case 9:
....................       LCD_PUTCMD(Line_1);
1560:  MOVLW  80
1562:  MOVLB  1
1564:  MOVWF  x2D
1566:  MOVLB  0
1568:  CALL   042E
....................       loading();
156C:  MOVLW  0A
156E:  MOVLB  1
1570:  MOVWF  x29
1572:  MOVLB  0
1574:  CALL   06B4
....................       clear_lcd();
1578:  MOVLB  1
157A:  CLRF   x29
157C:  MOVLB  0
157E:  CALL   06B4
....................       LCD_PUTCMD(Line_2);
1582:  MOVLW  C0
1584:  MOVLB  1
1586:  MOVWF  x2D
1588:  MOVLB  0
158A:  CALL   042E
....................       clear_lcd();
158E:  MOVLB  1
1590:  CLRF   x29
1592:  MOVLB  0
1594:  CALL   06B4
....................       break;
....................    }
....................    refresh_menu = 0; // cap nhat du lieu mang hinh xong
1598:  BCF    52.0
159A:  GOTO   18E0 (RETURN)
.................... }
.................... 
.................... //=========================
.................... void reset_timer_data(void)
.................... {
....................    val_timer_tri_hoan = timer_tri_hoan;
*
062C:  MOVFF  56,55
....................    val_counter_restart_mpd = 1;
0630:  MOVLW  01
0632:  MOVWF  58
....................    counter_restart_mpd_current = counter_restart_mpd;
0634:  MOVFF  59,5B
....................    val_timer_chay_lien_tuc = timer_chay_lien_tuc;
0638:  MOVFF  5D,5C
....................    val_timer_tam_dung = timer_tam_dung;
063C:  MOVFF  60,5F
....................    val_timer_on_mpd = timer_on_mpd;
0640:  MOVFF  69,68
....................    val_timer_off_mpd = timer_off_mpd;
0644:  MOVFF  6B,6A
....................    val_timer_ktra_mn = timer_ktra_mn;
0648:  MOVFF  66,65
....................    state_mn = 0;
064C:  CLRF   51
....................    flag_timer_tri_hoan_60s = 60, flag_timer_chay_lien_tuc_3600s = 3600, flag_timer_tam_dung_60s = 60;
064E:  MOVLW  3C
0650:  MOVWF  x73
0652:  MOVLW  0E
0654:  MOVWF  x72
0656:  MOVLW  10
0658:  MOVWF  x71
065A:  MOVLW  3C
065C:  MOVWF  x75
065E:  RETURN 0
.................... }
.................... 
.................... void lcd_printf(char code_printf)
.................... {
....................    switch (code_printf)
*
06B4:  MOVLB  1
06B6:  MOVF   x29,W
06B8:  XORLW  00
06BA:  MOVLB  0
06BC:  BZ    06CC
06BE:  XORLW  09
06C0:  BZ    06D8
06C2:  XORLW  03
06C4:  BZ    06E4
06C6:  XORLW  01
06C8:  BZ    074E
06CA:  BRA    0762
....................    {
....................    case 0:
....................       PRINTF(LCD_PUTCHAR, "                 ");
06CC:  MOVLW  BC
06CE:  MOVWF  FF6
06D0:  MOVLW  01
06D2:  MOVWF  FF7
06D4:  RCALL  0670
....................       break;
06D6:  BRA    0762
.................... 
....................    case 9:
....................       PRINTF(LCD_PUTCHAR, "  <YES || NO>");
06D8:  MOVLW  CE
06DA:  MOVWF  FF6
06DC:  MOVLW  01
06DE:  MOVWF  FF7
06E0:  RCALL  0670
....................       break;
06E2:  BRA    0762
.................... 
....................    case 10:
.................... 
....................       if (++val_loading > 5)
06E4:  INCF   x6C,F
06E6:  MOVF   x6C,W
06E8:  SUBLW  05
06EA:  BC    06F0
....................       {
....................          val_loading = 0;
06EC:  CLRF   x6C
....................          mode = 0;
06EE:  CLRF   50
....................       }
....................       PRINTF(LCD_PUTCHAR, "Loading ");
06F0:  MOVLW  DC
06F2:  MOVWF  FF6
06F4:  MOVLW  01
06F6:  MOVWF  FF7
06F8:  RCALL  0670
....................       switch (val_loading)
06FA:  MOVF   x6C,W
06FC:  ADDLW  FA
06FE:  BC    074C
0700:  ADDLW  06
0702:  GOTO   0764
....................       {
....................       case 0:
....................          PRINTF(LCD_PUTCHAR, ".  ");
0706:  MOVLW  E6
0708:  MOVWF  FF6
070A:  MOVLW  01
070C:  MOVWF  FF7
070E:  RCALL  0670
....................          break;
0710:  BRA    074C
.................... 
....................       case 1:
....................          PRINTF(LCD_PUTCHAR, ".. ");
0712:  MOVLW  EA
0714:  MOVWF  FF6
0716:  MOVLW  01
0718:  MOVWF  FF7
071A:  RCALL  0670
....................          break;
071C:  BRA    074C
.................... 
....................       case 2:
....................          PRINTF(LCD_PUTCHAR, "...");
071E:  MOVLW  EE
0720:  MOVWF  FF6
0722:  MOVLW  01
0724:  MOVWF  FF7
0726:  RCALL  0670
....................          break;
0728:  BRA    074C
.................... 
....................       case 3:
....................          PRINTF(LCD_PUTCHAR, " ..");
072A:  MOVLW  F2
072C:  MOVWF  FF6
072E:  MOVLW  01
0730:  MOVWF  FF7
0732:  RCALL  0670
....................          break;
0734:  BRA    074C
.................... 
....................       case 4:
....................          PRINTF(LCD_PUTCHAR, "  .");
0736:  MOVLW  F6
0738:  MOVWF  FF6
073A:  MOVLW  01
073C:  MOVWF  FF7
073E:  RCALL  0670
....................          break;
0740:  BRA    074C
.................... 
....................       case 5:
....................          PRINTF(LCD_PUTCHAR, "   ");
0742:  MOVLW  FA
0744:  MOVWF  FF6
0746:  MOVLW  01
0748:  MOVWF  FF7
074A:  RCALL  0670
....................          break;
....................       }
....................       break;
074C:  BRA    0762
.................... 
....................    case 11:
....................       PRINTF(LCD_PUTCHAR, "%s<", sch_1);
074E:  MOVFF  2B,FEA
0752:  MOVFF  2A,FE9
0756:  RCALL  0690
0758:  MOVLW  3C
075A:  MOVLB  1
075C:  MOVWF  x2C
075E:  MOVLB  0
0760:  RCALL  0660
....................       break;
....................    }
0762:  RETURN 0
.................... }
.................... //=======================================
.................... char key_scan(void)
*
0B0E:  CLRF   x7F
0B10:  MOVLW  C8
0B12:  MOVWF  x7E
.................... {
....................    unsigned long bounce = 200;
.................... 
....................    if (val_mode() == 1)
0B14:  BSF    F92.3
0B16:  BTFSC  F80.3
0B18:  BRA    0B64
....................    {
....................       while (bounce--)
0B1A:  MOVFF  7F,03
0B1E:  MOVF   x7E,W
0B20:  BTFSC  FD8.2
0B22:  DECF   x7F,F
0B24:  DECF   x7E,F
0B26:  IORWF  03,W
0B28:  BZ    0B38
....................       {
....................          if (val_mode() == 0)
0B2A:  BSF    F92.3
0B2C:  BTFSS  F80.3
0B2E:  BRA    0B36
....................             return 0x00;
0B30:  MOVLW  00
0B32:  MOVWF  01
0B34:  BRA    0C38
0B36:  BRA    0B1A
....................       }
....................       bounce = 1024;
0B38:  MOVLW  04
0B3A:  MOVWF  x7F
0B3C:  CLRF   x7E
....................       while (bounce--)
0B3E:  MOVFF  7F,03
0B42:  MOVF   x7E,W
0B44:  BTFSC  FD8.2
0B46:  DECF   x7F,F
0B48:  DECF   x7E,F
0B4A:  IORWF  03,W
0B4C:  BZ    0B5C
....................       {
....................          if (val_mode() == 0)
0B4E:  BSF    F92.3
0B50:  BTFSS  F80.3
0B52:  BRA    0B5A
....................             return 0x01;
0B54:  MOVLW  01
0B56:  MOVWF  01
0B58:  BRA    0C38
0B5A:  BRA    0B3E
....................       }
....................       return 0x01;
0B5C:  MOVLW  01
0B5E:  MOVWF  01
0B60:  BRA    0C38
....................    }
0B62:  BRA    0C34
.................... 
....................    else if (val_up() == 1)
0B64:  BSF    F92.2
0B66:  BTFSC  F80.2
0B68:  BRA    0BB4
....................    {
....................       while (bounce--)
0B6A:  MOVFF  7F,03
0B6E:  MOVF   x7E,W
0B70:  BTFSC  FD8.2
0B72:  DECF   x7F,F
0B74:  DECF   x7E,F
0B76:  IORWF  03,W
0B78:  BZ    0B88
....................       {
....................          if (val_up() == 0)
0B7A:  BSF    F92.2
0B7C:  BTFSS  F80.2
0B7E:  BRA    0B86
....................             return 0x00;
0B80:  MOVLW  00
0B82:  MOVWF  01
0B84:  BRA    0C38
0B86:  BRA    0B6A
....................       }
....................       bounce = 256;
0B88:  MOVLW  01
0B8A:  MOVWF  x7F
0B8C:  CLRF   x7E
....................       while (bounce--)
0B8E:  MOVFF  7F,03
0B92:  MOVF   x7E,W
0B94:  BTFSC  FD8.2
0B96:  DECF   x7F,F
0B98:  DECF   x7E,F
0B9A:  IORWF  03,W
0B9C:  BZ    0BAC
....................       {
....................          if (val_up() == 0)
0B9E:  BSF    F92.2
0BA0:  BTFSS  F80.2
0BA2:  BRA    0BAA
....................             return 0x02;
0BA4:  MOVLW  02
0BA6:  MOVWF  01
0BA8:  BRA    0C38
0BAA:  BRA    0B8E
....................       }
....................       return 0x02;
0BAC:  MOVLW  02
0BAE:  MOVWF  01
0BB0:  BRA    0C38
....................    }
0BB2:  BRA    0C34
.................... 
....................    else if (val_down() == 1)
0BB4:  BSF    F92.1
0BB6:  BTFSC  F80.1
0BB8:  BRA    0C04
....................    {
....................       while (bounce--)
0BBA:  MOVFF  7F,03
0BBE:  MOVF   x7E,W
0BC0:  BTFSC  FD8.2
0BC2:  DECF   x7F,F
0BC4:  DECF   x7E,F
0BC6:  IORWF  03,W
0BC8:  BZ    0BD8
....................       {
....................          if (val_down() == 0)
0BCA:  BSF    F92.1
0BCC:  BTFSS  F80.1
0BCE:  BRA    0BD6
....................             return 0x00;
0BD0:  MOVLW  00
0BD2:  MOVWF  01
0BD4:  BRA    0C38
0BD6:  BRA    0BBA
....................       }
....................       bounce = 256;
0BD8:  MOVLW  01
0BDA:  MOVWF  x7F
0BDC:  CLRF   x7E
....................       while (bounce--)
0BDE:  MOVFF  7F,03
0BE2:  MOVF   x7E,W
0BE4:  BTFSC  FD8.2
0BE6:  DECF   x7F,F
0BE8:  DECF   x7E,F
0BEA:  IORWF  03,W
0BEC:  BZ    0BFC
....................       {
....................          if (val_down() == 0)
0BEE:  BSF    F92.1
0BF0:  BTFSS  F80.1
0BF2:  BRA    0BFA
....................             return 0x03;
0BF4:  MOVLW  03
0BF6:  MOVWF  01
0BF8:  BRA    0C38
0BFA:  BRA    0BDE
....................       }
....................       return 0x03;
0BFC:  MOVLW  03
0BFE:  MOVWF  01
0C00:  BRA    0C38
....................    }
0C02:  BRA    0C34
.................... 
....................    else if (val_exit() == 1)
0C04:  BSF    F92.0
0C06:  BTFSC  F80.0
0C08:  BRA    0C34
....................    {
....................       while (bounce--)
0C0A:  MOVFF  7F,03
0C0E:  MOVF   x7E,W
0C10:  BTFSC  FD8.2
0C12:  DECF   x7F,F
0C14:  DECF   x7E,F
0C16:  IORWF  03,W
0C18:  BZ    0C28
....................       {
....................          if (val_exit() == 0)
0C1A:  BSF    F92.0
0C1C:  BTFSS  F80.0
0C1E:  BRA    0C26
....................             return 0x00;
0C20:  MOVLW  00
0C22:  MOVWF  01
0C24:  BRA    0C38
0C26:  BRA    0C0A
....................       }
....................       while (val_exit() == 0)
0C28:  BSF    F92.0
0C2A:  BTFSC  F80.0
0C2C:  BRA    0C28
....................          ;
....................       return 0x04;
0C2E:  MOVLW  04
0C30:  MOVWF  01
0C32:  BRA    0C38
....................    }
....................    return 0x00;
0C34:  MOVLW  00
0C36:  MOVWF  01
0C38:  GOTO   1812 (RETURN)
.................... }
.................... 
.................... //=========================
.................... void process_menu(void)
.................... {
....................    refresh_menu = 1;
*
0CE6:  BSF    52.0
....................    loop_not_display = 1;
0CE8:  MOVLW  01
0CEA:  MOVWF  x79
....................    switch (mode)
0CEC:  MOVF   50,W
0CEE:  XORLW  01
0CF0:  BZ    0CF4
0CF2:  BRA    0D48
....................    {
....................    case 1:
....................       if (strlen(str_temp) == strlen(password))
0CF4:  CLRF   x81
0CF6:  MOVLW  35
0CF8:  MOVWF  x80
0CFA:  RCALL  0C3C
0CFC:  MOVFF  02,7F
0D00:  MOVFF  01,7E
0D04:  CLRF   x81
0D06:  MOVLW  30
0D08:  MOVWF  x80
0D0A:  RCALL  0C3C
0D0C:  MOVFF  02,03
0D10:  MOVF   01,W
0D12:  SUBWF  x7E,W
0D14:  BNZ   0D34
0D16:  MOVF   03,W
0D18:  SUBWF  x7F,W
0D1A:  BNZ   0D34
....................       {
....................          if (strcmp(password, str_temp) == 0)
0D1C:  CLRF   x7F
0D1E:  MOVLW  30
0D20:  MOVWF  x7E
0D22:  CLRF   x81
0D24:  MOVLW  35
0D26:  MOVWF  x80
0D28:  BRA    0C70
0D2A:  MOVF   01,F
0D2C:  BNZ   0D34
....................          {
....................             mode++;
0D2E:  INCF   50,F
....................             time_reset_password = 20; // 4   phut
0D30:  MOVLW  14
0D32:  MOVWF  4E
....................          }
....................       }
....................       val_sch_1 = 0;
0D34:  CLRF   2E
....................       sch_1 = str_temp;
0D36:  CLRF   2B
0D38:  MOVLW  35
0D3A:  MOVWF  2A
....................       *sch_1 = 0;
0D3C:  MOVFF  2A,FE9
0D40:  MOVFF  2B,FEA
0D44:  CLRF   FEF
....................       break;
0D46:  BRA    0D60
.................... 
....................    default:
....................       if (++mode > 8)
0D48:  INCF   50,F
0D4A:  MOVF   50,W
0D4C:  SUBLW  08
0D4E:  BC    0D54
....................          mode = 9; // ve loading screen
0D50:  MOVLW  09
0D52:  MOVWF  50
....................       if (time_reset_password != 0 && mode == 1)
0D54:  MOVF   4E,F
0D56:  BZ    0D60
0D58:  DECFSZ 50,W
0D5A:  BRA    0D60
....................          mode = 2;
0D5C:  MOVLW  02
0D5E:  MOVWF  50
....................       break;
....................    }
0D60:  GOTO   1830 (RETURN)
.................... }
.................... 
.................... //=========================
.................... void process_up(void)
.................... {
....................    switch (mode)
*
0E80:  MOVF   50,W
0E82:  ADDLW  F7
0E84:  BC    0F3A
0E86:  ADDLW  09
0E88:  GOTO   0F3E
....................    {
....................    case 0: // mang hinh chinh
....................       break;
0E8C:  BRA    0F3A
.................... 
....................    case 1: // nhap mat khau
....................       sch_2 = val_number_defaul;
0E8E:  CLRF   2D
0E90:  MOVLW  1F
0E92:  MOVWF  2C
....................       if (++val_sch_2 > 10)
0E94:  INCF   2F,F
0E96:  MOVF   2F,W
0E98:  SUBLW  0A
0E9A:  BC    0E9E
....................          val_sch_2 = 0;
0E9C:  CLRF   2F
....................       sch_2 = sch_2 + val_sch_2;
0E9E:  MOVF   2F,W
0EA0:  ADDWF  2C,F
0EA2:  MOVLW  00
0EA4:  ADDWFC 2D,F
....................       sch_1 = sch_1 + val_sch_1;
0EA6:  MOVF   2E,W
0EA8:  ADDWF  2A,F
0EAA:  MOVLW  00
0EAC:  ADDWFC 2B,F
....................       *sch_1++ = *sch_2;
0EAE:  MOVFF  2B,7F
0EB2:  MOVF   2A,W
0EB4:  INCF   2A,F
0EB6:  BTFSC  FD8.2
0EB8:  INCF   2B,F
0EBA:  MOVFF  2C,FE9
0EBE:  MOVFF  2D,FEA
0EC2:  MOVFF  FEF,80
0EC6:  MOVFF  7F,FEA
0ECA:  MOVWF  FE9
0ECC:  MOVFF  80,FEF
....................       *sch_1 = 0;
0ED0:  MOVFF  2A,FE9
0ED4:  MOVFF  2B,FEA
0ED8:  CLRF   FEF
....................       break;
0EDA:  BRA    0F3A
.................... 
....................    case 2: // TG TRI HOAN
....................       if (++timer_tri_hoan > 254)
0EDC:  INCF   56,F
0EDE:  MOVF   56,W
0EE0:  SUBLW  FE
0EE2:  BC    0EE8
....................       {
....................          timer_tri_hoan = 1;
0EE4:  MOVLW  01
0EE6:  MOVWF  56
....................       }
....................       break;
0EE8:  BRA    0F3A
....................    case 3: // TG CHAY LIEN TUC
....................       if (++timer_chay_lien_tuc > 24)
0EEA:  INCF   5D,F
0EEC:  MOVF   5D,W
0EEE:  SUBLW  18
0EF0:  BC    0EF6
....................       {
....................          timer_chay_lien_tuc = 1;
0EF2:  MOVLW  01
0EF4:  MOVWF  5D
....................       }
....................       break;
0EF6:  BRA    0F3A
.................... 
....................    case 4: // TG TAM DUNG MPD
....................       if (++timer_tam_dung > 254)
0EF8:  INCF   x60,F
0EFA:  MOVF   x60,W
0EFC:  SUBLW  FE
0EFE:  BC    0F04
....................       {
....................          timer_tam_dung = 1;
0F00:  MOVLW  01
0F02:  MOVWF  x60
....................       }
....................       break;
0F04:  BRA    0F3A
.................... 
....................    case 5: // TG KTRA DA AC
....................       if (++timer_ktra_AC > 240)
0F06:  INCF   x63,F
0F08:  MOVF   x63,W
0F0A:  SUBLW  F0
0F0C:  BC    0F12
....................       {
....................          timer_ktra_AC = 10;
0F0E:  MOVLW  0A
0F10:  MOVWF  x63
....................       }
....................       break;
0F12:  BRA    0F3A
.................... 
....................    case 6: // TG KTRA DA MN
....................       if (++timer_ktra_mn > 240)
0F14:  INCF   x66,F
0F16:  MOVF   x66,W
0F18:  SUBLW  F0
0F1A:  BC    0F20
....................       {
....................          timer_ktra_mn = 10;
0F1C:  MOVLW  0A
0F1E:  MOVWF  x66
....................       }
....................       break;
0F20:  BRA    0F3A
.................... 
....................    case 7: // SO LAN KHOI DONG
....................       if (++counter_restart_mpd > 4)
0F22:  INCF   59,F
0F24:  MOVF   59,W
0F26:  SUBLW  04
0F28:  BC    0F2E
....................       {
....................          counter_restart_mpd = 2;
0F2A:  MOVLW  02
0F2C:  MOVWF  59
....................       }
....................       break;
0F2E:  BRA    0F3A
....................    case 8:      // cai dat mat dinh
....................       mode = 9; // ve loading screen
0F30:  MOVLW  09
0F32:  MOVWF  50
....................       default_data();
0F34:  BRA    0D64
....................       write_data();
0F36:  RCALL  0D80
....................       reset_cpu();
0F38:  RESET
....................       break;
....................    }
0F3A:  GOTO   184A (RETURN)
.................... }
.................... 
.................... //=========================
.................... void process_down(void)
.................... {
....................    switch (mode)
*
0F6A:  MOVF   50,W
0F6C:  ADDLW  F7
0F6E:  BC    1014
0F70:  ADDLW  09
0F72:  GOTO   1018
....................    {
....................    case 0: // mang hinh chinh
....................       break;
0F76:  BRA    1014
.................... 
....................    case 1: // nhap mat khau
....................       sch_2 = val_number_defaul;
0F78:  CLRF   2D
0F7A:  MOVLW  1F
0F7C:  MOVWF  2C
....................       if (--val_sch_2 > 10)
0F7E:  DECF   2F,F
0F80:  MOVF   2F,W
0F82:  SUBLW  0A
0F84:  BC    0F8A
....................          val_sch_2 = 10;
0F86:  MOVLW  0A
0F88:  MOVWF  2F
....................       sch_2 = sch_2 + val_sch_2;
0F8A:  MOVF   2F,W
0F8C:  ADDWF  2C,F
0F8E:  MOVLW  00
0F90:  ADDWFC 2D,F
....................       sch_1 = sch_1 + val_sch_1;
0F92:  MOVF   2E,W
0F94:  ADDWF  2A,F
0F96:  MOVLW  00
0F98:  ADDWFC 2B,F
....................       *sch_1++ = *sch_2;
0F9A:  MOVFF  2B,7F
0F9E:  MOVF   2A,W
0FA0:  INCF   2A,F
0FA2:  BTFSC  FD8.2
0FA4:  INCF   2B,F
0FA6:  MOVFF  2C,FE9
0FAA:  MOVFF  2D,FEA
0FAE:  MOVFF  FEF,80
0FB2:  MOVFF  7F,FEA
0FB6:  MOVWF  FE9
0FB8:  MOVFF  80,FEF
....................       *sch_1 = 0;
0FBC:  MOVFF  2A,FE9
0FC0:  MOVFF  2B,FEA
0FC4:  CLRF   FEF
....................       break;
0FC6:  BRA    1014
.................... 
....................    case 2: // TG TRI HOAN
....................       if (--timer_tri_hoan < 1)
0FC8:  DECFSZ 56,F
0FCA:  BRA    0FD0
....................       {
....................          timer_tri_hoan = 254;
0FCC:  MOVLW  FE
0FCE:  MOVWF  56
....................       }
....................       break;
0FD0:  BRA    1014
.................... 
....................    case 3: // TG CHAY LIEN TUC
....................       if (--timer_chay_lien_tuc < 1)
0FD2:  DECFSZ 5D,F
0FD4:  BRA    0FDA
....................       {
....................          timer_chay_lien_tuc = 24;
0FD6:  MOVLW  18
0FD8:  MOVWF  5D
....................       }
....................       break;
0FDA:  BRA    1014
.................... 
....................    case 4: // TG TAM DUNG MPD
....................       if (--timer_tam_dung < 1)
0FDC:  DECFSZ x60,F
0FDE:  BRA    0FE4
....................       {
....................          timer_tam_dung = 254;
0FE0:  MOVLW  FE
0FE2:  MOVWF  x60
....................       }
....................       break;
0FE4:  BRA    1014
.................... 
....................    case 5: // TG KTRA DA AC
....................       if (--timer_ktra_AC < 10)
0FE6:  DECF   x63,F
0FE8:  MOVF   x63,W
0FEA:  SUBLW  09
0FEC:  BNC   0FF2
....................       {
....................          timer_ktra_AC = 240;
0FEE:  MOVLW  F0
0FF0:  MOVWF  x63
....................       }
....................       break;
0FF2:  BRA    1014
.................... 
....................    case 6: // TG KTRA DA MN
....................       if (--timer_ktra_mn < 10)
0FF4:  DECF   x66,F
0FF6:  MOVF   x66,W
0FF8:  SUBLW  09
0FFA:  BNC   1000
....................       {
....................          timer_ktra_mn = 240;
0FFC:  MOVLW  F0
0FFE:  MOVWF  x66
....................       }
....................       break;
1000:  BRA    1014
.................... 
....................    case 7: // SO LAN KHOI DONG
....................       if (--counter_restart_mpd < 2)
1002:  DECF   59,F
1004:  MOVF   59,W
1006:  SUBLW  01
1008:  BNC   100E
....................       {
....................          counter_restart_mpd = 4;
100A:  MOVLW  04
100C:  MOVWF  59
....................       }
....................       break;
100E:  BRA    1014
....................    case 8:      // cai dat mat dinh
....................       mode = 9; // ve loading screen
1010:  MOVLW  09
1012:  MOVWF  50
....................       break;
....................    }
1014:  GOTO   1874 (RETURN)
.................... }
.................... 
.................... //=========================
.................... void process_exit(void)
.................... {
.................... 
....................    char val_null;
....................    val_sch_2 = 0;
*
1044:  CLRF   2F
....................    loop_not_display = 1;
1046:  MOVLW  01
1048:  MOVWF  x79
....................    switch (mode)
104A:  MOVF   50,W
104C:  BZ    1054
104E:  XORLW  01
1050:  BZ    1058
1052:  BRA    10A0
....................    {
....................    case 0: // mang hinh chinh
....................       time_reset_password = 0;
1054:  CLRF   4E
....................       break;
1056:  BRA    10A0
.................... 
....................    case 1: // nhap mat khau
....................       sch_1 = sch_1 + val_sch_1;
1058:  MOVF   2E,W
105A:  ADDWF  2A,F
105C:  MOVLW  00
105E:  ADDWFC 2B,F
....................       val_null = *sch_1;
1060:  MOVFF  2A,FE9
1064:  MOVFF  2B,FEA
1068:  MOVFF  FEF,7E
....................       if (val_null != 0 && val_null != 0XFF)
106C:  MOVF   x7E,F
106E:  BZ    10A0
1070:  INCFSZ x7E,W
1072:  BRA    1076
1074:  BRA    10A0
....................       {
....................          if (++val_sch_1 > 16)
1076:  INCF   2E,F
1078:  MOVF   2E,W
107A:  SUBLW  10
107C:  BC    1080
....................             val_sch_1 = 0;
107E:  CLRF   2E
....................          sch_1++;
1080:  INCF   2A,F
1082:  BTFSC  FD8.2
1084:  INCF   2B,F
....................          *sch_1++ = 0XFF;
1086:  MOVFF  2B,FEA
108A:  MOVF   2A,W
108C:  INCF   2A,F
108E:  BTFSC  FD8.2
1090:  INCF   2B,F
1092:  MOVWF  FE9
1094:  SETF   FEF
....................          *sch_1 = 0;
1096:  MOVFF  2A,FE9
109A:  MOVFF  2B,FEA
109E:  CLRF   FEF
....................       }
....................       break;
....................    }
10A0:  GOTO   189E (RETURN)
.................... }
.................... 
.................... void write_data(void)
.................... {
....................    wee(timer_tri_hoan_ee, timer_tri_hoan);
*
0D80:  MOVF   FF2,W
0D82:  MOVWF  00
0D84:  BCF    FF2.7
0D86:  CLRF   FAA
0D88:  CLRF   FA9
0D8A:  MOVFF  56,FA8
0D8E:  BCF    FA6.6
0D90:  BCF    FA6.7
0D92:  BSF    FA6.2
0D94:  MOVLB  F
0D96:  MOVLW  55
0D98:  MOVWF  FA7
0D9A:  MOVLW  AA
0D9C:  MOVWF  FA7
0D9E:  BSF    FA6.1
0DA0:  BTFSC  FA6.1
0DA2:  BRA    0DA0
0DA4:  BCF    FA6.2
0DA6:  MOVF   00,W
0DA8:  IORWF  FF2,F
....................    wee(timer_chay_lien_tuc_ee, timer_chay_lien_tuc);
0DAA:  MOVFF  FF2,00
0DAE:  BCF    FF2.7
0DB0:  CLRF   FAA
0DB2:  MOVLW  02
0DB4:  MOVWF  FA9
0DB6:  MOVFF  5D,FA8
0DBA:  BCF    FA6.6
0DBC:  BCF    FA6.7
0DBE:  BSF    FA6.2
0DC0:  MOVLW  55
0DC2:  MOVWF  FA7
0DC4:  MOVLW  AA
0DC6:  MOVWF  FA7
0DC8:  BSF    FA6.1
0DCA:  BTFSC  FA6.1
0DCC:  BRA    0DCA
0DCE:  BCF    FA6.2
0DD0:  MOVF   00,W
0DD2:  IORWF  FF2,F
....................    wee(timer_tam_dung_ee, timer_tam_dung);
0DD4:  MOVFF  FF2,00
0DD8:  BCF    FF2.7
0DDA:  CLRF   FAA
0DDC:  MOVLW  03
0DDE:  MOVWF  FA9
0DE0:  MOVFF  60,FA8
0DE4:  BCF    FA6.6
0DE6:  BCF    FA6.7
0DE8:  BSF    FA6.2
0DEA:  MOVLW  55
0DEC:  MOVWF  FA7
0DEE:  MOVLW  AA
0DF0:  MOVWF  FA7
0DF2:  BSF    FA6.1
0DF4:  BTFSC  FA6.1
0DF6:  BRA    0DF4
0DF8:  BCF    FA6.2
0DFA:  MOVF   00,W
0DFC:  IORWF  FF2,F
....................    wee(timer_ktra_mn_ee, timer_ktra_mn);
0DFE:  MOVFF  FF2,00
0E02:  BCF    FF2.7
0E04:  CLRF   FAA
0E06:  MOVLW  05
0E08:  MOVWF  FA9
0E0A:  MOVFF  66,FA8
0E0E:  BCF    FA6.6
0E10:  BCF    FA6.7
0E12:  BSF    FA6.2
0E14:  MOVLW  55
0E16:  MOVWF  FA7
0E18:  MOVLW  AA
0E1A:  MOVWF  FA7
0E1C:  BSF    FA6.1
0E1E:  BTFSC  FA6.1
0E20:  BRA    0E1E
0E22:  BCF    FA6.2
0E24:  MOVF   00,W
0E26:  IORWF  FF2,F
....................    wee(timer_ktra_AC_ee, timer_ktra_AC);
0E28:  MOVFF  FF2,00
0E2C:  BCF    FF2.7
0E2E:  CLRF   FAA
0E30:  MOVLW  04
0E32:  MOVWF  FA9
0E34:  MOVFF  63,FA8
0E38:  BCF    FA6.6
0E3A:  BCF    FA6.7
0E3C:  BSF    FA6.2
0E3E:  MOVLW  55
0E40:  MOVWF  FA7
0E42:  MOVLW  AA
0E44:  MOVWF  FA7
0E46:  BSF    FA6.1
0E48:  BTFSC  FA6.1
0E4A:  BRA    0E48
0E4C:  BCF    FA6.2
0E4E:  MOVF   00,W
0E50:  IORWF  FF2,F
....................    wee(counter_restart_mpd_ee, counter_restart_mpd);
0E52:  MOVFF  FF2,00
0E56:  BCF    FF2.7
0E58:  CLRF   FAA
0E5A:  MOVLW  01
0E5C:  MOVWF  FA9
0E5E:  MOVFF  59,FA8
0E62:  BCF    FA6.6
0E64:  BCF    FA6.7
0E66:  BSF    FA6.2
0E68:  MOVLW  55
0E6A:  MOVWF  FA7
0E6C:  MOVLW  AA
0E6E:  MOVWF  FA7
0E70:  BSF    FA6.1
0E72:  BTFSC  FA6.1
0E74:  BRA    0E72
0E76:  BCF    FA6.2
0E78:  MOVF   00,W
0E7A:  IORWF  FF2,F
0E7C:  MOVLB  0
0E7E:  RETURN 0
.................... }
.................... 
.................... //=========================
.................... void read_data(void)
.................... {
....................    timer_tri_hoan = ree(timer_tri_hoan_ee);
*
04A8:  MOVFF  FF2,7E
04AC:  BCF    FF2.7
04AE:  CLRF   FAA
04B0:  CLRF   FA9
04B2:  BCF    FA6.6
04B4:  BCF    FA6.7
04B6:  BSF    FA6.0
04B8:  MOVF   FA8,W
04BA:  BTFSC  x7E.7
04BC:  BSF    FF2.7
04BE:  MOVWF  56
....................    timer_chay_lien_tuc = ree(timer_chay_lien_tuc_ee);
04C0:  MOVFF  FF2,7E
04C4:  BCF    FF2.7
04C6:  CLRF   FAA
04C8:  MOVLW  02
04CA:  MOVWF  FA9
04CC:  BCF    FA6.6
04CE:  BCF    FA6.7
04D0:  BSF    FA6.0
04D2:  MOVF   FA8,W
04D4:  BTFSC  x7E.7
04D6:  BSF    FF2.7
04D8:  MOVWF  5D
....................    timer_tam_dung = ree(timer_tam_dung_ee);
04DA:  MOVFF  FF2,7E
04DE:  BCF    FF2.7
04E0:  CLRF   FAA
04E2:  MOVLW  03
04E4:  MOVWF  FA9
04E6:  BCF    FA6.6
04E8:  BCF    FA6.7
04EA:  BSF    FA6.0
04EC:  MOVF   FA8,W
04EE:  BTFSC  x7E.7
04F0:  BSF    FF2.7
04F2:  MOVWF  x60
....................    timer_ktra_mn = ree(timer_ktra_mn_ee);
04F4:  MOVFF  FF2,7E
04F8:  BCF    FF2.7
04FA:  CLRF   FAA
04FC:  MOVLW  05
04FE:  MOVWF  FA9
0500:  BCF    FA6.6
0502:  BCF    FA6.7
0504:  BSF    FA6.0
0506:  MOVF   FA8,W
0508:  BTFSC  x7E.7
050A:  BSF    FF2.7
050C:  MOVWF  x66
....................    timer_ktra_AC = ree(timer_ktra_AC_ee);
050E:  MOVFF  FF2,7E
0512:  BCF    FF2.7
0514:  CLRF   FAA
0516:  MOVLW  04
0518:  MOVWF  FA9
051A:  BCF    FA6.6
051C:  BCF    FA6.7
051E:  BSF    FA6.0
0520:  MOVF   FA8,W
0522:  BTFSC  x7E.7
0524:  BSF    FF2.7
0526:  MOVWF  x63
....................    counter_restart_mpd = ree(counter_restart_mpd_ee);
0528:  MOVFF  FF2,7E
052C:  BCF    FF2.7
052E:  CLRF   FAA
0530:  MOVLW  01
0532:  MOVWF  FA9
0534:  BCF    FA6.6
0536:  BCF    FA6.7
0538:  BSF    FA6.0
053A:  MOVF   FA8,W
053C:  BTFSC  x7E.7
053E:  BSF    FF2.7
0540:  MOVWF  59
0542:  GOTO   16FA (RETURN)
.................... }
.................... 
.................... void disable_reset(void)
.................... {
....................    output_high(clock_reset);
*
0382:  BCF    F92.3
0384:  BSF    F89.3
....................    delay_ms(1);
0386:  MOVLW  01
0388:  MOVLB  1
038A:  MOVWF  x2E
038C:  MOVLB  0
038E:  RCALL  0358
....................    output_low(clock_reset);
0390:  BCF    F92.3
0392:  BCF    F89.3
....................    delay_ms(1);
0394:  MOVLW  01
0396:  MOVLB  1
0398:  MOVWF  x2E
039A:  MOVLB  0
039C:  RCALL  0358
....................    output_high(clock_reset);
039E:  BCF    F92.3
03A0:  BSF    F89.3
....................    delay_ms(1);
03A2:  MOVLW  01
03A4:  MOVLB  1
03A6:  MOVWF  x2E
03A8:  MOVLB  0
03AA:  RCALL  0358
....................    output_low(clock_reset);
03AC:  BCF    F92.3
03AE:  BCF    F89.3
....................    delay_ms(1);
03B0:  MOVLW  01
03B2:  MOVLB  1
03B4:  MOVWF  x2E
03B6:  MOVLB  0
03B8:  RCALL  0358
....................    output_high(clock_reset);
03BA:  BCF    F92.3
03BC:  BSF    F89.3
....................    delay_ms(1);
03BE:  MOVLW  01
03C0:  MOVLB  1
03C2:  MOVWF  x2E
03C4:  MOVLB  0
03C6:  RCALL  0358
....................    output_low(clock_reset);
03C8:  BCF    F92.3
03CA:  BCF    F89.3
....................    delay_ms(1);
03CC:  MOVLW  01
03CE:  MOVLB  1
03D0:  MOVWF  x2E
03D2:  MOVLB  0
03D4:  RCALL  0358
....................    output_float(clock_reset);
03D6:  BSF    F92.3
03D8:  RETURN 0
.................... }
.................... 
.................... #int_timer0
.................... void interrupt_timer0()
.................... {
....................    clear_interrupt(INT_TIMER0);
*
01FE:  BCF    FF2.2
....................    set_timer0(62536); // 500us => 65536 - (0.0005/(4/24000000))
0200:  MOVLW  F4
0202:  MOVWF  FD7
0204:  MOVLW  48
0206:  MOVWF  FD6
0208:  NOP   
.................... 
....................    if (mode == 0 && state_AC == 1) // DIMMER LCD
020A:  MOVF   50,F
020C:  BNZ   023E
020E:  DECFSZ 4F,W
0210:  BRA    023E
....................    {
....................       switch (pwm_lcd)
0212:  MOVF   x76,W
0214:  BZ    0220
0216:  XORLW  01
0218:  BZ    0226
021A:  XORLW  06
021C:  BZ    0232
021E:  BRA    023C
....................       {
....................       case 0:
....................          backligh_on();
0220:  BCF    F92.4
0222:  BSF    F89.4
....................          break;
0224:  BRA    023C
.................... 
....................       case 1:
....................          if (timer_backlight < 30)
0226:  MOVF   54,W
0228:  SUBLW  1D
022A:  BNC   0230
....................             backligh_off();
022C:  BCF    F92.4
022E:  BCF    F89.4
....................          break;
0230:  BRA    023C
.................... 
....................       case 7:
....................          if (timer_backlight < 120)
0232:  MOVF   54,W
0234:  SUBLW  77
0236:  BNC   023C
....................             backligh_off();
0238:  BCF    F92.4
023A:  BCF    F89.4
....................          break;
....................       }
....................    }
023C:  BRA    0242
....................    else
....................    {
....................       backligh_on();
023E:  BCF    F92.4
0240:  BSF    F89.4
....................    }
....................    if (++pwm_lcd > 10)
0242:  INCF   x76,F
0244:  MOVF   x76,W
0246:  SUBLW  0A
0248:  BC    024C
....................       pwm_lcd = 0;
024A:  CLRF   x76
.................... 
....................    if (++counter_timer0 > 500)
024C:  INCF   x6F,F
024E:  BTFSC  FD8.2
0250:  INCF   x70,F
0252:  MOVF   x70,W
0254:  SUBLW  00
0256:  BTFSC  FD8.0
0258:  BRA    032A
025A:  XORLW  FF
025C:  BNZ   0266
025E:  MOVF   x6F,W
0260:  SUBLW  F4
0262:  BTFSC  FD8.0
0264:  BRA    032A
....................    { // timer 1s
....................       counter_timer0 = 0;
0266:  CLRF   x70
0268:  CLRF   x6F
....................       DISABLE_INTERRUPTS(INT_TIMER0);
026A:  BCF    FF2.5
.................... 
....................       switch (mode)
026C:  MOVF   50,W
026E:  BZ    0272
0270:  BRA    0302
....................       {
....................       case 0: // TINH NANG CHINH
....................          if (flag_mn == 1 && val_timer_ktra_mn > 0)
0272:  DECFSZ x6E,W
0274:  BRA    027C
0276:  MOVF   x65,F
0278:  BZ    027C
....................          {
....................             val_timer_ktra_mn--;
027A:  DECF   x65,F
....................          }
....................          switch (state_AC)
027C:  MOVF   4F,W
027E:  ADDLW  FA
0280:  BC    0300
0282:  ADDLW  06
0284:  GOTO   0332
....................          {
....................          case 0: // TIMER DEM DO AC
....................             if (val_timer_ktra_AC > 0)
0288:  MOVF   x62,F
028A:  BZ    028E
....................                val_timer_ktra_AC--;
028C:  DECF   x62,F
....................             break;
028E:  BRA    0300
....................          case 1:
....................             break;
0290:  BRA    0300
....................          case 2: // TIMER TRI HOAN
....................             if (--flag_timer_tri_hoan_60s > 59)
0292:  DECF   x73,F
0294:  MOVF   x73,W
0296:  SUBLW  3B
0298:  BC    02A4
....................             {
....................                flag_timer_tri_hoan_60s = 59;
029A:  MOVLW  3B
029C:  MOVWF  x73
....................                if (val_timer_tri_hoan > 0)
029E:  MOVF   55,F
02A0:  BZ    02A4
....................                   val_timer_tri_hoan--;
02A2:  DECF   55,F
....................             }
....................             break;
02A4:  BRA    0300
....................          case 3:
....................             switch (state_mn)
02A6:  MOVF   51,W
02A8:  BZ    02B4
02AA:  XORLW  01
02AC:  BZ    02BC
02AE:  XORLW  03
02B0:  BZ    02BE
02B2:  BRA    02C4
....................             {
....................             case 0:
....................                if (val_timer_on_mpd > 0)
02B4:  MOVF   x68,F
02B6:  BZ    02BA
....................                {
....................                   val_timer_on_mpd--;
02B8:  DECF   x68,F
....................                }
....................                break;
02BA:  BRA    02C4
....................             case 1:
....................                break;
02BC:  BRA    02C4
....................             case 2:
....................                if (val_timer_off_mpd > 0)
02BE:  MOVF   x6A,F
02C0:  BZ    02C4
....................                {
....................                   val_timer_off_mpd--;
02C2:  DECF   x6A,F
....................                }
....................                break;
....................             }
....................             break;
02C4:  BRA    0300
....................          case 4:
....................             if (--flag_timer_chay_lien_tuc_3600s > 3599)
02C6:  MOVF   x71,W
02C8:  BTFSC  FD8.2
02CA:  DECF   x72,F
02CC:  DECF   x71,F
02CE:  MOVF   x72,W
02D0:  SUBLW  0D
02D2:  BC    02EC
02D4:  XORLW  FF
02D6:  BNZ   02DE
02D8:  MOVF   x71,W
02DA:  SUBLW  0F
02DC:  BC    02EC
....................             {
....................                flag_timer_chay_lien_tuc_3600s = 3599;
02DE:  MOVLW  0E
02E0:  MOVWF  x72
02E2:  MOVLW  0F
02E4:  MOVWF  x71
....................                if (val_timer_chay_lien_tuc > 0)
02E6:  MOVF   5C,F
02E8:  BZ    02EC
....................                   val_timer_chay_lien_tuc--;
02EA:  DECF   5C,F
....................             }
....................             break;
02EC:  BRA    0300
....................          case 5:
....................             if (--flag_timer_tam_dung_60s > 59)
02EE:  DECF   x75,F
02F0:  MOVF   x75,W
02F2:  SUBLW  3B
02F4:  BC    0300
....................             {
....................                flag_timer_tam_dung_60s = 59;
02F6:  MOVLW  3B
02F8:  MOVWF  x75
....................                if (val_timer_tam_dung > 0)
02FA:  MOVF   5F,F
02FC:  BZ    0300
....................                   val_timer_tam_dung--;
02FE:  DECF   5F,F
....................             }
....................             break;
....................          }
....................          break;
0300:  BRA    0302
....................       }
....................       // TRO VE MANG HINH CHINH KHI KHONG NHAN NUT
....................       if (timer_exit != 0)
0302:  MOVF   53,F
0304:  BZ    0308
....................          timer_exit--;
0306:  DECF   53,F
....................       if (timer_exit == 0)
0308:  MOVF   53,F
030A:  BNZ   030E
....................       {
....................          mode = 0; // ve loading screen
030C:  CLRF   50
....................       }
.................... 
....................       // DEN LCD
....................       if (timer_backlight != 0)
030E:  MOVF   54,F
0310:  BZ    0314
....................          timer_backlight--;
0312:  DECF   54,F
.................... 
....................       // timer 1 phut
....................       if (--flag_timer_60s_password > 59)
0314:  DECF   x74,F
0316:  MOVF   x74,W
0318:  SUBLW  3B
031A:  BC    032A
....................       {
....................          flag_timer_60s_password = 59;
031C:  MOVLW  3B
031E:  MOVWF  x74
....................          loop_not_display = 1;
0320:  MOVLW  01
0322:  MOVWF  x79
....................          if (time_reset_password != 0)
0324:  MOVF   4E,F
0326:  BZ    032A
....................             time_reset_password--;
0328:  DECF   4E,F
.................... 
....................          // nhan nut up mot luc reset ve mat dinh
....................       }
....................    }
....................    enable_interrupts(INT_TIMER0);
032A:  BSF    FF2.5
032C:  BCF    FF2.2
032E:  GOTO   0060
.................... }

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1C09   NOPUT NOBROWNOUT BORV27 NOWDT WDT16384
   Word  3: 8F00   CCP2C1 PBADEN LPT1OSC HFOFST MCLR
   Word  4: 0000   NOSTVREN NOLVP NOXINST DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
