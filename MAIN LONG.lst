CCS PCH C Compiler, Version 5.101, 43599               13-Feb-23 10:55

               Filename:   E:\DAT 2022\TIET KIEM DIEN AN GIANG\LONG NAP CHO THIET BI AG T02-2023\MAIN LONG.lst

               ROM used:   6496 bytes (10%)
                           Largest free fragment is 59036
               RAM used:   126 (3%) at main() level
                           303 (8%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   15F8
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  FF2.5
00056:  GOTO   0060
0005A:  BTFSC  FF2.2
0005C:  GOTO   01FA
00060:  MOVFF  0E,00
00064:  MOVFF  0F,01
00068:  MOVFF  10,02
0006C:  MOVFF  11,03
00070:  MOVFF  0C,FE9
00074:  MOVFF  07,FEA
00078:  BSF    07.7
0007A:  MOVFF  08,FE1
0007E:  MOVFF  09,FE2
00082:  MOVFF  0A,FD9
00086:  MOVFF  0B,FDA
0008A:  MOVFF  12,FF3
0008E:  MOVFF  13,FF4
00092:  MOVFF  14,FFA
00096:  MOVFF  15,FF5
0009A:  MOVFF  16,FF6
0009E:  MOVFF  17,FF7
000A2:  MOVF   04,W
000A4:  MOVFF  06,FE0
000A8:  MOVFF  05,FD8
000AC:  RETFIE 0
.................... #include "C:\Program Files (x86)\PICC\Devices\18f26k20.h"
.................... //////////// Standard Header file for the PIC18F26K20 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F26K20
000AE:  CLRF   FF7
000B0:  ADDLW  BE
000B2:  MOVWF  FF6
000B4:  MOVLW  00
000B6:  ADDWFC FF7,F
000B8:  TBLRD*+
000BA:  MOVF   FF5,W
000BC:  RETURN 0
000BE:  DATA 00,00
000C0:  DATA 54,47
000C2:  DATA 20,54
000C4:  DATA 52,49
000C6:  DATA 20,48
000C8:  DATA 4F,41
000CA:  DATA 4E,20
000CC:  DATA 4D,50
000CE:  DATA 44,00
000D0:  DATA 50,48
000D2:  DATA 55,54
000D4:  DATA 3A,20
000D6:  DATA 25,30
000D8:  DATA 31,75
000DA:  DATA 00,00
000DC:  DATA 54,47
000DE:  DATA 20,43
000E0:  DATA 48,41
000E2:  DATA 59,20
000E4:  DATA 4C,49
000E6:  DATA 45,4E
000E8:  DATA 20,54
000EA:  DATA 55,43
000EC:  DATA 00,00
000EE:  DATA 47,49
000F0:  DATA 4F,3A
000F2:  DATA 20,25
000F4:  DATA 30,31
000F6:  DATA 75,00
000F8:  DATA 54,47
000FA:  DATA 20,54
000FC:  DATA 41,4D
000FE:  DATA 20,44
00100:  DATA 55,4E
00102:  DATA 47,20
00104:  DATA 4D,50
00106:  DATA 44,00
00108:  DATA 50,48
0010A:  DATA 55,54
0010C:  DATA 3A,20
0010E:  DATA 25,30
00110:  DATA 31,75
00112:  DATA 00,00
00114:  DATA 4B,49
00116:  DATA 45,4D
00118:  DATA 20,54
0011A:  DATA 52,41
0011C:  DATA 20,41
0011E:  DATA 43,00
00120:  DATA 47,49
00122:  DATA 41,59
00124:  DATA 3A,20
00126:  DATA 25,30
00128:  DATA 31,75
0012A:  DATA 00,00
0012C:  DATA 44,2E
0012E:  DATA 41,50
00130:  DATA 20,41
00132:  DATA 43,20
00134:  DATA 42,54
00136:  DATA 48,55
00138:  DATA 4F,4E
0013A:  DATA 47,00
0013C:  DATA 4D,50
0013E:  DATA 44,20
00140:  DATA 4C,4F
00142:  DATA 49,00
00144:  DATA 4D,50
00146:  DATA 44,20
00148:  DATA 54,4F
0014A:  DATA 54,00
0014C:  DATA 43,48
0014E:  DATA 41,59
00150:  DATA 20,4D
00152:  DATA 50,44
00154:  DATA 00,00
00156:  DATA 4C,41
00158:  DATA 4E,3A
0015A:  DATA 20,25
0015C:  DATA 30,31
0015E:  DATA 75,00
00160:  DATA 4D,50
00162:  DATA 44,20
00164:  DATA 4C,4F
00166:  DATA 49,00
00168:  DATA 50,48
0016A:  DATA 55,54
0016C:  DATA 3A,20
0016E:  DATA 3C,25
00170:  DATA 30,31
00172:  DATA 75,3E
00174:  DATA 00,00
00176:  DATA 47,49
00178:  DATA 4F,3A
0017A:  DATA 20,3C
0017C:  DATA 25,30
0017E:  DATA 31,75
00180:  DATA 3E,00
00182:  DATA 50,48
00184:  DATA 55,54
00186:  DATA 3A,20
00188:  DATA 3C,25
0018A:  DATA 30,31
0018C:  DATA 75,3E
0018E:  DATA 00,00
00190:  DATA 47,49
00192:  DATA 41,59
00194:  DATA 3A,20
00196:  DATA 3C,25
00198:  DATA 30,31
0019A:  DATA 75,3E
0019C:  DATA 00,00
0019E:  DATA 47,49
001A0:  DATA 41,59
001A2:  DATA 3A,20
001A4:  DATA 3C,25
001A6:  DATA 30,31
001A8:  DATA 75,3E
001AA:  DATA 00,00
001AC:  DATA 4C,41
001AE:  DATA 4E,3A
001B0:  DATA 20,3C
001B2:  DATA 25,30
001B4:  DATA 31,75
001B6:  DATA 3E,00
001B8:  DATA 20,20
001BA:  DATA 20,20
001BC:  DATA 20,20
001BE:  DATA 20,20
001C0:  DATA 20,20
001C2:  DATA 20,20
001C4:  DATA 20,20
001C6:  DATA 20,20
001C8:  DATA 20,00
001CA:  DATA 20,20
001CC:  DATA 3C,59
001CE:  DATA 45,53
001D0:  DATA 20,7C
001D2:  DATA 7C,20
001D4:  DATA 4E,4F
001D6:  DATA 3E,00
001D8:  DATA 4C,6F
001DA:  DATA 61,64
001DC:  DATA 69,6E
001DE:  DATA 67,20
001E0:  DATA 00,00
001E2:  DATA 2E,20
001E4:  DATA 20,00
001E6:  DATA 2E,2E
001E8:  DATA 20,00
001EA:  DATA 2E,2E
001EC:  DATA 2E,00
001EE:  DATA 20,2E
001F0:  DATA 2E,00
001F2:  DATA 20,20
001F4:  DATA 2E,00
001F6:  DATA 20,20
001F8:  DATA 20,00
*
0032E:  ADDWF  FE8,W
00330:  CLRF   FF7
00332:  RLCF   FF7,F
00334:  ADDLW  49
00336:  MOVWF  FF6
00338:  MOVLW  03
0033A:  ADDWFC FF7,F
0033C:  TBLRD*-
0033E:  MOVF   FF5,W
00340:  MOVWF  FFA
00342:  TBLRD*
00344:  MOVF   FF5,W
00346:  MOVWF  FF9
00348:  DATA 84,02
0034A:  DATA 8C,02
0034C:  DATA 8E,02
0034E:  DATA A2,02
00350:  DATA C2,02
00352:  DATA EA,02
*
0066C:  TBLRD*+
0066E:  MOVF   FF5,F
00670:  BZ    068A
00672:  MOVFF  FF6,12A
00676:  MOVFF  FF7,12B
0067A:  MOVFF  FF5,12C
0067E:  RCALL  065C
00680:  MOVFF  12A,FF6
00684:  MOVFF  12B,FF7
00688:  BRA    066C
0068A:  RETURN 0
0068C:  MOVF   FEF,F
0068E:  BZ    06AE
00690:  MOVFF  FEA,12B
00694:  MOVFF  FE9,12A
00698:  MOVFF  FEF,12C
0069C:  RCALL  065C
0069E:  MOVFF  12B,FEA
006A2:  MOVFF  12A,FE9
006A6:  INCF   FE9,F
006A8:  BTFSC  FD8.2
006AA:  INCF   FEA,F
006AC:  BRA    068C
006AE:  RETURN 0
*
00760:  ADDWF  FE8,W
00762:  CLRF   FF7
00764:  RLCF   FF7,F
00766:  ADDLW  7B
00768:  MOVWF  FF6
0076A:  MOVLW  07
0076C:  ADDWFC FF7,F
0076E:  TBLRD*-
00770:  MOVF   FF5,W
00772:  MOVWF  FFA
00774:  TBLRD*
00776:  MOVF   FF5,W
00778:  MOVWF  FF9
0077A:  DATA 02,07
0077C:  DATA 0E,07
0077E:  DATA 1A,07
00780:  DATA 26,07
00782:  DATA 32,07
00784:  DATA 3E,07
00786:  TBLRD*+
00788:  MOVFF  FF6,12A
0078C:  MOVFF  FF7,12B
00790:  MOVFF  FF5,12C
00794:  RCALL  065C
00796:  MOVFF  12A,FF6
0079A:  MOVFF  12B,FF7
0079E:  MOVLB  1
007A0:  DECFSZ x29,F
007A2:  BRA    07A6
007A4:  BRA    07AA
007A6:  MOVLB  0
007A8:  BRA    0786
007AA:  MOVLB  0
007AC:  RETURN 0
007AE:  MOVLB  1
007B0:  MOVF   x2C,W
007B2:  CLRF   01
007B4:  SUBWF  x2B,W
007B6:  BC    07BE
007B8:  MOVFF  12B,00
007BC:  BRA    07D6
007BE:  CLRF   00
007C0:  MOVLW  08
007C2:  MOVWF  x2D
007C4:  RLCF   x2B,F
007C6:  RLCF   00,F
007C8:  MOVF   x2C,W
007CA:  SUBWF  00,W
007CC:  BTFSC  FD8.0
007CE:  MOVWF  00
007D0:  RLCF   01,F
007D2:  DECFSZ x2D,F
007D4:  BRA    07C4
007D6:  MOVLB  0
007D8:  RETURN 0
007DA:  MOVF   01,W
007DC:  MOVFF  129,12B
007E0:  MOVLW  64
007E2:  MOVLB  1
007E4:  MOVWF  x2C
007E6:  MOVLB  0
007E8:  RCALL  07AE
007EA:  MOVFF  00,129
007EE:  MOVF   01,W
007F0:  MOVLW  30
007F2:  BNZ   0804
007F4:  MOVLB  1
007F6:  BTFSS  x2A.1
007F8:  BRA    0818
007FA:  BTFSC  x2A.3
007FC:  BRA    0818
007FE:  BTFSC  x2A.4
00800:  MOVLW  20
00802:  BRA    080C
00804:  MOVLB  1
00806:  BCF    x2A.3
00808:  BCF    x2A.4
0080A:  BSF    x2A.0
0080C:  ADDWF  01,F
0080E:  MOVFF  01,12C
00812:  MOVLB  0
00814:  RCALL  065C
00816:  MOVLB  1
00818:  MOVFF  129,12B
0081C:  MOVLW  0A
0081E:  MOVWF  x2C
00820:  MOVLB  0
00822:  RCALL  07AE
00824:  MOVFF  00,129
00828:  MOVF   01,W
0082A:  MOVLW  30
0082C:  BNZ   083E
0082E:  MOVLB  1
00830:  BTFSC  x2A.3
00832:  BRA    0848
00834:  BTFSS  x2A.0
00836:  BRA    0848
00838:  BTFSC  x2A.4
0083A:  MOVLW  20
0083C:  MOVLB  0
0083E:  ADDWF  01,F
00840:  MOVFF  01,12C
00844:  RCALL  065C
00846:  MOVLB  1
00848:  MOVLW  30
0084A:  ADDWF  x29,F
0084C:  MOVFF  129,12C
00850:  MOVLB  0
00852:  RCALL  065C
00854:  RETURN 0
*
00AAE:  ADDWF  FE8,W
00AB0:  CLRF   FF7
00AB2:  RLCF   FF7,F
00AB4:  ADDLW  C9
00AB6:  MOVWF  FF6
00AB8:  MOVLW  0A
00ABA:  ADDWFC FF7,F
00ABC:  TBLRD*-
00ABE:  MOVF   FF5,W
00AC0:  MOVWF  FFA
00AC2:  TBLRD*
00AC4:  MOVF   FF5,W
00AC6:  MOVWF  FF9
00AC8:  DATA 68,08
00ACA:  DATA 6C,08
00ACC:  DATA BE,08
00ACE:  DATA 10,09
00AD0:  DATA 62,09
00AD2:  DATA B4,09
00AD4:  DATA 24,0A
00AD6:  DATA 76,0A
*
00F3A:  ADDWF  FE8,W
00F3C:  CLRF   FF7
00F3E:  RLCF   FF7,F
00F40:  ADDLW  55
00F42:  MOVWF  FF6
00F44:  MOVLW  0F
00F46:  ADDWFC FF7,F
00F48:  TBLRD*-
00F4A:  MOVF   FF5,W
00F4C:  MOVWF  FFA
00F4E:  TBLRD*
00F50:  MOVF   FF5,W
00F52:  MOVWF  FF9
00F54:  DATA 88,0E
00F56:  DATA 8A,0E
00F58:  DATA D8,0E
00F5A:  DATA E6,0E
00F5C:  DATA F4,0E
00F5E:  DATA 02,0F
00F60:  DATA 10,0F
00F62:  DATA 1E,0F
00F64:  DATA 2C,0F
*
01014:  ADDWF  FE8,W
01016:  CLRF   FF7
01018:  RLCF   FF7,F
0101A:  ADDLW  2F
0101C:  MOVWF  FF6
0101E:  MOVLW  10
01020:  ADDWFC FF7,F
01022:  TBLRD*-
01024:  MOVF   FF5,W
01026:  MOVWF  FFA
01028:  TBLRD*
0102A:  MOVF   FF5,W
0102C:  MOVWF  FF9
0102E:  DATA 72,0F
01030:  DATA 74,0F
01032:  DATA C4,0F
01034:  DATA CE,0F
01036:  DATA D8,0F
01038:  DATA E2,0F
0103A:  DATA F0,0F
0103C:  DATA FE,0F
0103E:  DATA 0C,10
*
0159A:  ADDWF  FE8,W
0159C:  CLRF   FF7
0159E:  RLCF   FF7,F
015A0:  ADDLW  B5
015A2:  MOVWF  FF6
015A4:  MOVLW  15
015A6:  ADDWFC FF7,F
015A8:  TBLRD*-
015AA:  MOVF   FF5,W
015AC:  MOVWF  FFA
015AE:  TBLRD*
015B0:  MOVF   FF5,W
015B2:  MOVWF  FF9
015B4:  DATA 28,13
015B6:  DATA 36,13
015B8:  DATA 44,13
015BA:  DATA 52,13
015BC:  DATA 54,13
015BE:  DATA 62,13
015C0:  DATA 7C,13
015C2:  DATA 7C,13
015C4:  DATA 7C,13
015C6:  DATA 7C,13
015C8:  DATA 70,13
015CA:  ADDWF  FE8,W
015CC:  CLRF   FF7
015CE:  RLCF   FF7,F
015D0:  ADDLW  E5
015D2:  MOVWF  FF6
015D4:  MOVLW  15
015D6:  ADDWFC FF7,F
015D8:  TBLRD*-
015DA:  MOVF   FF5,W
015DC:  MOVWF  FFA
015DE:  TBLRD*
015E0:  MOVF   FF5,W
015E2:  MOVWF  FF9
015E4:  DATA 1C,13
015E6:  DATA 7E,13
015E8:  DATA 9E,13
015EA:  DATA E6,13
015EC:  DATA 2E,14
015EE:  DATA 76,14
015F0:  DATA BE,14
015F2:  DATA 06,15
015F4:  DATA 4E,15
015F6:  DATA 5C,15
*
018E4:  ADDWF  FE8,W
018E6:  CLRF   FF7
018E8:  RLCF   FF7,F
018EA:  ADDLW  FF
018EC:  MOVWF  FF6
018EE:  MOVLW  18
018F0:  ADDWFC FF7,F
018F2:  TBLRD*-
018F4:  MOVF   FF5,W
018F6:  MOVWF  FFA
018F8:  TBLRD*
018FA:  MOVF   FF5,W
018FC:  MOVWF  FF9
018FE:  DATA 20,17
01900:  DATA 22,17
01902:  DATA 30,17
01904:  DATA 3E,17
01906:  DATA AA,17
01908:  DATA D4,17
0190A:  DATA F6,17
0190C:  DATA F6,17
0190E:  DATA F6,17
01910:  DATA F6,17
01912:  DATA E2,17
01914:  ADDWF  FE8,W
01916:  CLRF   FF7
01918:  RLCF   FF7,F
0191A:  ADDLW  2F
0191C:  MOVWF  FF6
0191E:  MOVLW  19
01920:  ADDWFC FF7,F
01922:  TBLRD*-
01924:  MOVF   FF5,W
01926:  MOVWF  FFA
01928:  TBLRD*
0192A:  MOVF   FF5,W
0192C:  MOVWF  FF9
0192E:  DATA 0E,17
01930:  DATA F8,17
01932:  DATA FA,17
01934:  DATA FC,17
01936:  DATA FE,17
01938:  DATA 00,18
0193A:  DATA 02,18
0193C:  DATA 04,18
0193E:  DATA 06,18
01940:  DATA 08,18
01942:  ADDWF  FE8,W
01944:  CLRF   FF7
01946:  RLCF   FF7,F
01948:  ADDLW  5D
0194A:  MOVWF  FF6
0194C:  MOVLW  19
0194E:  ADDWFC FF7,F
01950:  TBLRD*-
01952:  MOVF   FF5,W
01954:  MOVWF  FFA
01956:  TBLRD*
01958:  MOVF   FF5,W
0195A:  MOVWF  FF9
0195C:  DATA 1C,18
0195E:  DATA 3A,18
01960:  DATA 64,18
01962:  DATA 8E,18
.................... 
.................... #list
.................... 
.................... #device adc = 10
.................... #fuses hs, nolvp, protect, MCLR, NOPUT, BORV27
.................... #include "C:\Program Files (x86)\PICC\Drivers\stdlib.h"
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
00C6C:  MOVFF  7E,FE9
00C70:  MOVFF  7F,FEA
00C74:  MOVFF  FEF,82
00C78:  MOVFF  81,03
00C7C:  MOVFF  80,FE9
00C80:  MOVFF  81,FEA
00C84:  MOVF   FEF,W
00C86:  SUBWF  x82,W
00C88:  BNZ   0CB4
....................       if (*s1 == '\0')
00C8A:  MOVFF  7F,03
00C8E:  MOVFF  7E,FE9
00C92:  MOVFF  03,FEA
00C96:  MOVF   FEF,F
00C98:  BNZ   0CA0
....................          return(0);
00C9A:  MOVLW  00
00C9C:  MOVWF  01
00C9E:  BRA    0CDE
00CA0:  MOVFF  7F,03
00CA4:  MOVF   x7E,W
00CA6:  INCF   x7E,F
00CA8:  BTFSC  FD8.2
00CAA:  INCF   x7F,F
00CAC:  INCF   x80,F
00CAE:  BTFSC  FD8.2
00CB0:  INCF   x81,F
00CB2:  BRA    0C6C
....................    return((*s1 < *s2) ? -1: 1);
00CB4:  MOVFF  7F,03
00CB8:  MOVFF  7E,FE9
00CBC:  MOVFF  7F,FEA
00CC0:  MOVFF  FEF,82
00CC4:  MOVFF  81,03
00CC8:  MOVFF  80,FE9
00CCC:  MOVFF  81,FEA
00CD0:  MOVF   FEF,W
00CD2:  SUBWF  x82,W
00CD4:  BC    0CDA
00CD6:  MOVLW  FF
00CD8:  BRA    0CDC
00CDA:  MOVLW  01
00CDC:  MOVWF  01
00CDE:  GOTO   0D26 (RETURN)
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
00C38:  MOVFF  81,83
00C3C:  MOVFF  80,82
00C40:  MOVFF  83,03
00C44:  MOVFF  82,FE9
00C48:  MOVFF  83,FEA
00C4C:  MOVF   FEF,F
00C4E:  BZ    0C58
00C50:  INCF   x82,F
00C52:  BTFSC  FD8.2
00C54:  INCF   x83,F
00C56:  BRA    0C40
....................    return(sc - s);
00C58:  MOVF   x80,W
00C5A:  SUBWF  x82,W
00C5C:  MOVWF  00
00C5E:  MOVF   x81,W
00C60:  SUBWFB x83,W
00C62:  MOVWF  03
00C64:  MOVFF  00,01
00C68:  MOVWF  02
00C6A:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #fuses WDT16384
.................... #use delay(clock = 24000000)
*
00354:  MOVLW  01
00356:  MOVWF  FEA
00358:  MOVLW  2E
0035A:  MOVWF  FE9
0035C:  MOVF   FEF,W
0035E:  BZ    037C
00360:  MOVLW  07
00362:  MOVWF  01
00364:  CLRF   00
00366:  DECFSZ 00,F
00368:  BRA    0366
0036A:  DECFSZ 01,F
0036C:  BRA    0364
0036E:  MOVLW  C7
00370:  MOVWF  00
00372:  DECFSZ 00,F
00374:  BRA    0372
00376:  NOP   
00378:  DECFSZ FEF,F
0037A:  BRA    0360
0037C:  RETURN 0
.................... #include "lcd_lib_4bit.c"
.................... //#include <stddef.h>
.................... #include "C:\Program Files (x86)\PICC\Drivers\stddef.h"
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... #define LCD_RS          PIN_B1
.................... #define LCD_EN          PIN_B0
.................... #define LCD_D4          PIN_C7
.................... #define LCD_D5          PIN_C6
.................... #define LCD_D6          PIN_C5
.................... #define LCD_D7          PIN_C4
.................... #define Line_1          0x80
.................... #define Line_2          0xC0
.................... #define Clear_Scr       0x01
.................... 
.................... void LCD_Init ();// ham khoi tao LCD
.................... void LCD_SetPosition ( unsigned int cX );//Thiet lap vi tri con tro
.................... void LCD_PutChar ( unsigned int cX );// Ham viet1kitu/1chuoi len LCD
.................... void LCD_PutCmd ( unsigned int cX) ;// Ham gui lenh len LCD
.................... void LCD_PulseEnable ( void );// Xung kich hoat
.................... void LCD_SetData ( unsigned int cX );// Dat du lieu len chan Data
.................... 
.................... //khoi tao LCD**********************************************
.................... void LCD_Init ()
....................     {
....................     LCD_SetData ( 0x00 );
*
00448:  MOVLB  1
0044A:  CLRF   x2E
0044C:  MOVLB  0
0044E:  RCALL  03D6
....................     delay_ms(20);       /*Cho cho lcd khoi tao */
00450:  MOVLW  14
00452:  MOVLB  1
00454:  MOVWF  x2E
00456:  MOVLB  0
00458:  RCALL  0354
....................     output_low ( LCD_RS );// che do gui lenh
0045A:  BCF    F93.1
0045C:  BCF    F8A.1
....................     LCD_SetData ( 0x03 );   /* khoi tao che do 4 bit */
0045E:  MOVLW  03
00460:  MOVLB  1
00462:  MOVWF  x2E
00464:  MOVLB  0
00466:  RCALL  03D6
....................     LCD_PulseEnable();
00468:  RCALL  040C
....................     LCD_PulseEnable();
0046A:  RCALL  040C
....................     LCD_PulseEnable();
0046C:  RCALL  040C
....................     LCD_SetData ( 0x02 );   /* tao giao dien 4 bit */
0046E:  MOVLW  02
00470:  MOVLB  1
00472:  MOVWF  x2E
00474:  MOVLB  0
00476:  RCALL  03D6
....................     LCD_PulseEnable();      /* send dual nibbles hereafter, MSN first */
00478:  RCALL  040C
....................     LCD_PutCmd ( 0x2C );    /* function set (all lines, 5x7 characters) */
0047A:  MOVLW  2C
0047C:  MOVLB  1
0047E:  MOVWF  x2D
00480:  MOVLB  0
00482:  RCALL  042A
....................     LCD_PutCmd ( 0x0C );    /* display ON, cursor off, no blink */
00484:  MOVLW  0C
00486:  MOVLB  1
00488:  MOVWF  x2D
0048A:  MOVLB  0
0048C:  RCALL  042A
....................     LCD_PutCmd ( 0x06 );    /* entry mode set, increment & scroll left */
0048E:  MOVLW  06
00490:  MOVLB  1
00492:  MOVWF  x2D
00494:  MOVLB  0
00496:  RCALL  042A
....................     LCD_PutCmd ( 0x01 );    /* clear display */
00498:  MOVLW  01
0049A:  MOVLB  1
0049C:  MOVWF  x2D
0049E:  MOVLB  0
004A0:  RCALL  042A
004A2:  RETURN 0
.................... 
....................     // Init for BarGraph
.................... 
....................     }
.................... 
.................... void LCD_SetPosition ( unsigned int cX )
....................     {
....................     /* this subroutine works specifically for 4-bit Port A */
....................     LCD_SetData ( swap ( cX ) | 0x08 );
....................     LCD_PulseEnable();
....................     LCD_SetData ( swap ( cX ) );
....................     LCD_PulseEnable();
....................     }
.................... 
.................... void LCD_PutChar ( unsigned int cX )
....................     {
....................     /* this subroutine works specifically for 4-bit Port A */
....................         output_high ( LCD_RS );
*
0065C:  BCF    F93.1
0065E:  BSF    F8A.1
....................         LCD_PutCmd( cX );
00660:  MOVFF  12C,12D
00664:  RCALL  042A
....................         output_low ( LCD_RS );
00666:  BCF    F93.1
00668:  BCF    F8A.1
0066A:  RETURN 0
....................     }
.................... 
.................... void LCD_PutCmd ( unsigned int cX )
....................     {
....................     /* this subroutine works specifically for 4-bit Port A */
....................    
....................     LCD_SetData ( swap ( cX ) );     /* send high nibble */
*
0042A:  MOVLB  1
0042C:  SWAPF  x2D,F
0042E:  MOVFF  12D,12E
00432:  MOVLB  0
00434:  RCALL  03D6
....................     LCD_PulseEnable();
00436:  RCALL  040C
....................     LCD_SetData ( swap ( cX ) );     /* send low nibble */
00438:  MOVLB  1
0043A:  SWAPF  x2D,F
0043C:  MOVFF  12D,12E
00440:  MOVLB  0
00442:  RCALL  03D6
....................     LCD_PulseEnable();
00444:  RCALL  040C
00446:  RETURN 0
....................     }
.................... 	
.................... void LCD_PulseEnable ( void )
....................     {
....................     output_high ( LCD_EN );
*
0040C:  BCF    F93.0
0040E:  BSF    F8A.0
....................     delay_us ( 3 );         // was 10
00410:  MOVLW  05
00412:  MOVWF  00
00414:  DECFSZ 00,F
00416:  BRA    0414
00418:  BRA    041A
....................     output_low ( LCD_EN );
0041A:  BCF    F93.0
0041C:  BCF    F8A.0
....................     delay_ms ( 3 );         // was 5
0041E:  MOVLW  03
00420:  MOVLB  1
00422:  MOVWF  x2E
00424:  MOVLB  0
00426:  RCALL  0354
00428:  RETURN 0
....................     }
.................... 
.................... void LCD_SetData ( unsigned int cX )
....................     {
....................     output_bit ( LCD_D4, cX & 0x01 );
*
003D6:  MOVLB  1
003D8:  BTFSC  x2E.0
003DA:  BRA    03E0
003DC:  BCF    F8B.7
003DE:  BRA    03E2
003E0:  BSF    F8B.7
003E2:  BCF    F94.7
....................     output_bit ( LCD_D5, cX & 0x02 );
003E4:  BTFSC  x2E.1
003E6:  BRA    03EC
003E8:  BCF    F8B.6
003EA:  BRA    03EE
003EC:  BSF    F8B.6
003EE:  BCF    F94.6
....................     output_bit ( LCD_D6, cX & 0x04 );
003F0:  BTFSC  x2E.2
003F2:  BRA    03F8
003F4:  BCF    F8B.5
003F6:  BRA    03FA
003F8:  BSF    F8B.5
003FA:  BCF    F94.5
....................     output_bit ( LCD_D7, cX & 0x08 );
003FC:  BTFSC  x2E.3
003FE:  BRA    0404
00400:  BCF    F8B.4
00402:  BRA    0406
00404:  BSF    F8B.4
00406:  BCF    F94.4
00408:  MOVLB  0
0040A:  RETURN 0
....................     }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //============================
.................... #define sw_mode PIN_A3
.................... #define sw_up PIN_A2
.................... #define sw_down PIN_A1
.................... #define sw_exit PIN_A0
.................... 
.................... #define val_mode() !input(sw_mode)
.................... #define val_up() !input(sw_up)
.................... #define val_down() !input(sw_down)
.................... #define val_exit() !input(sw_exit)
.................... 
.................... #define clock_reset PIN_A3 // TAO XUNG CHONG TREO
.................... 
.................... #define backligh_lcd PIN_A4
.................... #define backligh_on() output_high(backligh_lcd);
.................... #define backligh_off() output_low(backligh_lcd);
.................... 
.................... #define cb_mn PIN_C2
.................... #define cb_ac PIN_C3
.................... 
.................... #define status_mn() !input(cb_mn)
.................... #define status_ac() !input(cb_ac)
.................... 
.................... #define out_fire PIN_B2
.................... #define out_temp PIN_B3
.................... #define out_error PIN_B5
.................... #define out_delay PIN_B4
.................... #define out_mn PIN_B6
.................... #define out_ac PIN_B7
.................... 
.................... #define ree(x) read_eeprom(x);
.................... #define wee(x, y) write_eeprom(x, y);
.................... 
.................... #define tg_tri_hoan 1
.................... #define tg_chay_lien_tuc 2
.................... #define tg_tam_dung 3
.................... #define do_ac 4
.................... #define ac_bthg 5
.................... #define chay_mpd 6
.................... #define error 7
.................... 
.................... //===================
.................... #define clear_lcd() lcd_printf(0);
.................... #define yesno() lcd_printf(9);
.................... #define loading() lcd_printf(10);
.................... 
.................... #define sch_1_s_set() lcd_printf(11);
.................... 
.................... // luu tru trong rom
.................... 
.................... #define timer_tri_hoan_ee 0x00
.................... #define counter_restart_mpd_ee timer_tri_hoan_ee + 1
.................... #define timer_chay_lien_tuc_ee counter_restart_mpd_ee + 1
.................... #define timer_tam_dung_ee timer_chay_lien_tuc_ee + 1
.................... #define timer_ktra_AC_ee timer_tam_dung_ee + 1
.................... #define timer_ktra_mn_ee timer_ktra_AC_ee + 1
.................... 
.................... #define size_pass 5
.................... 
.................... // khai bao bien
.................... unsigned char val_number_defaul[11] = {"0123456789"};
.................... // con tro phuc vu cai dat
.................... char *sch_1 = 0, *sch_2 = 0, val_sch_1 = 0, val_sch_2 = 0;
.................... 
.................... char password[size_pass] = {"1111"};
.................... char str_temp[25] = "";
.................... char time_reset_password = 0;
.................... 
.................... char state_AC = 0;
.................... char mode = 9;
.................... char state_mn = 0;
.................... short refresh_menu = 0;
.................... 
.................... char timer_exit = 0;
.................... char timer_backlight = 240;
.................... 
.................... char val_timer_tri_hoan = 60, timer_tri_hoan = 60, timer_tri_hoan_md = 60;             // LONG DELAY 1
.................... char val_counter_restart_mpd = 1, counter_restart_mpd = 4, counter_restart_mpd_md = 4; // LONG SO LAN KHOI DONG LAI MPD
.................... char counter_restart_mpd_current = 4;
.................... char val_timer_chay_lien_tuc = 3, timer_chay_lien_tuc = 3, timer_chay_lien_tuc_md = 3; // LONG DELAY 2
.................... char val_timer_tam_dung = 60, timer_tam_dung = 60, timer_tam_dung_md = 60;             // LONG DELAY 3
.................... char val_timer_ktra_AC = 60, timer_ktra_AC = 60, timer_ktra_AC_md = 60;                // LONG KT AC TIMER
.................... char val_timer_ktra_mn = 30, timer_ktra_mn = 30, timer_ktra_mn_md = 30;                // LONG KT MN TIMER
.................... char val_timer_on_mpd = 20, timer_on_mpd = 20;
.................... char val_timer_off_mpd = 20, timer_off_mpd = 20;
.................... 
.................... char val_loading = 0;
.................... 
.................... char flag_error = 0; // LONG FLAG = 0 la ko loi, = 1 la LOI
.................... char flag_mn = 0;    // LONG FLAG = 0 la chay xong check_mn(), = 1 la dang chay
.................... 
.................... unsigned long counter_timer0 = 0, flag_timer_chay_lien_tuc_3600s = 3600;
.................... char flag_timer_tri_hoan_60s = 60, flag_timer_60s_password = 0, flag_timer_tam_dung_60s = 60;
.................... 
.................... char pwm_lcd = 0;
.................... char sum_out = 0, sum_out_old = 0, loop_not_display = 0;
.................... 
.................... //===============================
.................... void init_data(void);
.................... void check_AC(void);
.................... char check_mn(void);
.................... void default_data(void);
.................... void display(char code_print);
.................... char key_scan(void);
.................... void process_menu(void);
.................... void process_up(void);
.................... void process_down(void);
.................... void process_exit(void);
.................... void display_center(void);
.................... void lcd_printf(char code_printf);
.................... void reset_timer_data(void);
.................... void write_data(void);
.................... void read_data(void);
.................... 
.................... unsigned char read_eeprom(unsigned char addr);
.................... void write_eeprom(unsigned char addr, unsigned char value);
.................... 
.................... void disable_reset(void);
.................... 
.................... //===============================
.................... void main()
*
015F8:  CLRF   FF8
015FA:  BCF    FD0.7
015FC:  BSF    07.7
015FE:  CLRF   2B
01600:  CLRF   2A
01602:  CLRF   2D
01604:  CLRF   2C
01606:  CLRF   2E
01608:  CLRF   2F
0160A:  CLRF   4E
0160C:  CLRF   4F
0160E:  MOVLW  09
01610:  MOVWF  50
01612:  CLRF   51
01614:  BCF    52.0
01616:  CLRF   53
01618:  MOVLW  F0
0161A:  MOVWF  54
0161C:  MOVLW  3C
0161E:  MOVWF  55
01620:  MOVWF  56
01622:  MOVWF  57
01624:  MOVLW  01
01626:  MOVWF  58
01628:  MOVLW  04
0162A:  MOVWF  59
0162C:  MOVWF  5A
0162E:  MOVWF  5B
01630:  MOVLW  03
01632:  MOVWF  5C
01634:  MOVWF  5D
01636:  MOVWF  5E
01638:  MOVLW  3C
0163A:  MOVWF  5F
0163C:  MOVWF  x60
0163E:  MOVWF  x61
01640:  MOVWF  x62
01642:  MOVWF  x63
01644:  MOVWF  x64
01646:  MOVLW  1E
01648:  MOVWF  x65
0164A:  MOVWF  x66
0164C:  MOVWF  x67
0164E:  MOVLW  14
01650:  MOVWF  x68
01652:  MOVWF  x69
01654:  MOVWF  x6A
01656:  MOVWF  x6B
01658:  CLRF   x6C
0165A:  CLRF   x6D
0165C:  CLRF   x6E
0165E:  CLRF   x70
01660:  CLRF   x6F
01662:  MOVLW  0E
01664:  MOVWF  x72
01666:  MOVLW  10
01668:  MOVWF  x71
0166A:  MOVLW  3C
0166C:  MOVWF  x73
0166E:  CLRF   x74
01670:  MOVWF  x75
01672:  CLRF   x76
01674:  CLRF   x77
01676:  CLRF   x78
01678:  CLRF   x79
0167A:  CLRF   x7B
0167C:  CLRF   x7A
0167E:  MOVLW  00
01680:  MOVWF  F7E
01682:  BCF    FC1.4
01684:  BCF    FC1.5
01686:  MOVF   F7F,W
01688:  ANDLW  E0
0168A:  MOVWF  F7F
0168C:  BCF    F79.5
0168E:  BCF    F79.4
01690:  CLRF   F7A
01692:  CLRF   F7B
01694:  CLRF   19
01696:  CLRF   1A
01698:  MOVLW  30
0169A:  MOVWF  1F
0169C:  MOVLW  31
0169E:  MOVWF  20
016A0:  MOVLW  32
016A2:  MOVWF  21
016A4:  MOVLW  33
016A6:  MOVWF  22
016A8:  MOVLW  34
016AA:  MOVWF  23
016AC:  MOVLW  35
016AE:  MOVWF  24
016B0:  MOVLW  36
016B2:  MOVWF  25
016B4:  MOVLW  37
016B6:  MOVWF  26
016B8:  MOVLW  38
016BA:  MOVWF  27
016BC:  MOVLW  39
016BE:  MOVWF  28
016C0:  CLRF   29
016C2:  MOVLW  31
016C4:  MOVWF  30
016C6:  MOVWF  31
016C8:  MOVWF  32
016CA:  MOVWF  33
016CC:  CLRF   34
016CE:  CLRF   35
.................... {
....................    // chong treo xu li
....................    disable_reset();
016D0:  CALL   037E
....................    // KHOI DONG NGAT TIMER 0
....................    SETUP_TIMER_0(T0_INTERNAL | T0_DIV_4);
016D4:  MOVLW  81
016D6:  MOVWF  FD5
....................    enable_interrupts(INT_TIMER0);
016D8:  BSF    FF2.5
....................    enable_interrupts(GLOBAL);
016DA:  MOVLW  C0
016DC:  IORWF  FF2,F
....................    clear_interrupt(INT_TIMER0);
016DE:  BCF    FF2.2
....................    set_timer0(62536); //(24000000/128)/(65535-65160)=187500/375=500us
016E0:  MOVLW  F4
016E2:  MOVWF  FD7
016E4:  MOVLW  48
016E6:  MOVWF  FD6
016E8:  NOP   
....................    lcd_init();        // khoi dong mang hinh lcd
016EA:  CALL   0448
....................    backligh_on();
016EE:  BCF    F92.4
016F0:  BSF    F89.4
....................    read_data();
016F2:  GOTO   04A4
....................    init_data();
016F6:  GOTO   0542
....................    // CHUONG TRINH CHINH
....................    while (1)
....................    {
....................       disable_reset();
016FA:  CALL   037E
....................       restart_wdt();
016FE:  CLRWDT
....................       // DIEU HOA TRANG THAI: Tinh nang chinh - nhap menu
....................       switch (mode)
01700:  MOVF   50,W
01702:  ADDLW  F6
01704:  BTFSC  FD8.0
01706:  BRA    1808
01708:  ADDLW  0A
0170A:  GOTO   1914
....................       {
....................       case 0: // TINH NANG CHINH
....................          check_AC();
0170E:  GOTO   05E2
.................... 
....................          switch (state_AC)
01712:  MOVF   4F,W
01714:  ADDLW  F5
01716:  BTFSC  FD8.0
01718:  BRA    17F6
0171A:  ADDLW  0B
0171C:  GOTO   18E4
....................          {
....................          case 0: // Timer delay ktra ac
....................             break;
01720:  BRA    17F6
.................... 
....................          case 1: // co AC ->hien thi LCD
....................             reset_timer_data();
01722:  CALL   0628
....................             output_low(out_fire);
01726:  BCF    F93.2
01728:  BCF    F8A.2
....................             output_low(out_delay);
0172A:  BCF    F93.4
0172C:  BCF    F8A.4
....................             break;
0172E:  BRA    17F6
....................          case 2: // mat AC: DELAY 1
....................             output_high(out_delay);
01730:  BCF    F93.4
01732:  BSF    F8A.4
....................             if (val_timer_tri_hoan <= 0)
01734:  MOVF   55,F
01736:  BNZ   173C
....................             {
....................                state_AC = 3;
01738:  MOVLW  03
0173A:  MOVWF  4F
....................             }
....................             break;
0173C:  BRA    17F6
....................          case 3: // mat AC: DO DIEN AP MPD
....................             if (val_counter_restart_mpd <= counter_restart_mpd_current)
0173E:  MOVF   58,W
01740:  SUBWF  5B,W
01742:  BNC   179E
....................             {
....................                display(chay_mpd);
01744:  MOVLW  06
01746:  MOVLB  1
01748:  MOVWF  x28
0174A:  MOVLB  0
0174C:  CALL   0856
....................                switch (state_mn)
01750:  MOVF   51,W
01752:  BZ    175E
01754:  XORLW  01
01756:  BZ    1770
01758:  XORLW  03
0175A:  BZ    178C
0175C:  BRA    179C
....................                {
....................                case 0: // on remote start delay
....................                   output_high(out_fire);
0175E:  BCF    F93.2
01760:  BSF    F8A.2
....................                   if (val_timer_on_mpd <= 0)
01762:  MOVF   x68,F
01764:  BNZ   176E
....................                   {
....................                      state_mn = 1;
01766:  MOVLW  01
01768:  MOVWF  51
....................                      val_timer_on_mpd = timer_on_mpd;
0176A:  MOVFF  69,68
....................                   }
....................                   break;
0176E:  BRA    179C
....................                case 1: // do mpd
....................                   char mn = check_mn();
01770:  CALL   0AD8
01774:  MOVFF  01,7C
....................                   if (mn == 1)
01778:  DECFSZ x7C,W
0177A:  BRA    1782
....................                   {
....................                      state_AC = 4;
0177C:  MOVLW  04
0177E:  MOVWF  4F
....................                   }
01780:  BRA    178A
....................                   else if (mn == 0)
01782:  MOVF   x7C,F
01784:  BNZ   178A
....................                   {
....................                      state_mn = 2;
01786:  MOVLW  02
01788:  MOVWF  51
....................                   }
....................                   break;
0178A:  BRA    179C
....................                case 2: // off remote start delay
....................                   output_low(out_fire);
0178C:  BCF    F93.2
0178E:  BCF    F8A.2
....................                   if (val_timer_off_mpd <= 0)
01790:  MOVF   x6A,F
01792:  BNZ   179C
....................                   {
....................                      state_mn = 0;
01794:  CLRF   51
....................                      val_timer_off_mpd = timer_off_mpd;
01796:  MOVFF  6B,6A
....................                      val_counter_restart_mpd++;
0179A:  INCF   58,F
....................                   }
....................                   break;
....................                }
....................             }
0179C:  BRA    17A8
....................             else if (val_counter_restart_mpd > counter_restart_mpd_current)
0179E:  MOVF   58,W
017A0:  SUBWF  5B,W
017A2:  BC    17A8
....................             {
....................                state_AC = 10; // error
017A4:  MOVLW  0A
017A6:  MOVWF  4F
....................             }
....................             break;
017A8:  BRA    17F6
....................          case 4: // DELAY 2 + OFF REMOTE START
....................             char mn = check_mn();
017AA:  CALL   0AD8
017AE:  MOVFF  01,7D
....................             if (mn == 0)
017B2:  MOVF   x7D,F
017B4:  BNZ   17BC
....................             {
....................                state_AC = 10; // error
017B6:  MOVLW  0A
017B8:  MOVWF  4F
....................                break;
017BA:  BRA    17F6
....................             }
....................             // OFF REMOTE START
....................             if (val_timer_chay_lien_tuc <= 0)
017BC:  MOVF   5C,F
017BE:  BNZ   17D2
....................             {
....................                output_low(out_fire);
017C0:  BCF    F93.2
017C2:  BCF    F8A.2
....................                flag_error = 0;
017C4:  CLRF   x6D
....................                output_low(out_temp);
017C6:  BCF    F93.3
017C8:  BCF    F8A.3
....................                output_low(out_error);
017CA:  BCF    F93.5
017CC:  BCF    F8A.5
....................                state_AC = 5;
017CE:  MOVLW  05
017D0:  MOVWF  4F
....................             }
....................             break;
017D2:  BRA    17F6
....................          case 5: // DELAY 3
....................             if (val_timer_tam_dung <= 0)
017D4:  MOVF   5F,F
017D6:  BNZ   17E0
....................             {
....................                state_AC = 3;
017D8:  MOVLW  03
017DA:  MOVWF  4F
....................                reset_timer_data();
017DC:  CALL   0628
....................             }
....................             break;
017E0:  BRA    17F6
....................          case 10: // error
....................             flag_error = 1;
017E2:  MOVLW  01
017E4:  MOVWF  x6D
....................             output_low(out_fire);
017E6:  BCF    F93.2
017E8:  BCF    F8A.2
....................             output_high(out_temp);
017EA:  BCF    F93.3
017EC:  BSF    F8A.3
....................             output_high(out_error);
017EE:  BCF    F93.5
017F0:  BSF    F8A.5
....................             output_low(out_delay);
017F2:  BCF    F93.4
017F4:  BCF    F8A.4
....................             break;
....................          }
....................          break;
017F6:  BRA    1808
....................       case 1: // nhap mat khau
....................          break;
017F8:  BRA    1808
....................       case 2: // MENU TG TRI HOAN MPD
....................          break;
017FA:  BRA    1808
....................       case 3: // MENU TG CHAY LIEN TUC
....................          break;
017FC:  BRA    1808
....................       case 4: // MENU TG TAM DUNG MPD
....................          break;
017FE:  BRA    1808
....................       case 5: // MENU TG KTRA DA AC
....................          break;
01800:  BRA    1808
....................       case 6: // MENU TG KTRA DA MN
....................          break;
01802:  BRA    1808
....................       case 7: // MENU SO LAN KHOI DONG
....................          break;
01804:  BRA    1808
....................       case 8: // MENU cai dat mat dinh
....................          break;
01806:  BRA    1808
....................       case 9: // Loading screen
....................          // loading xong chay tinh nang chinh
....................          break;
....................       }
.................... 
....................       // kiem tra phim nhan
....................       output_float(sw_down);
01808:  BSF    F92.1
....................       switch (key_scan())
0180A:  GOTO   0B0A
0180E:  MOVLW  01
01810:  SUBWF  01,W
01812:  ADDLW  FC
01814:  BC    18A6
01816:  ADDLW  04
01818:  GOTO   1942
....................       {
....................       case 0x01: // nut menu duoc nhan
....................          lcd_init();
0181C:  CALL   0448
....................          timer_exit = 30;
01820:  MOVLW  1E
01822:  MOVWF  53
....................          timer_backlight = 250;
01824:  MOVLW  FA
01826:  MOVWF  54
....................          process_menu();
01828:  GOTO   0CE2
....................          delay_ms(200);
0182C:  MOVLW  C8
0182E:  MOVLB  1
01830:  MOVWF  x2E
01832:  MOVLB  0
01834:  CALL   0354
....................          break;
01838:  BRA    18A6
.................... 
....................       case 0x02: // nut up duoc nhan
....................          timer_exit = 90;
0183A:  MOVLW  5A
0183C:  MOVWF  53
....................          timer_backlight = 250;
0183E:  MOVLW  FA
01840:  MOVWF  54
....................          process_up();
01842:  GOTO   0E7C
....................          if (mode >= 2 && mode <= 7)
01846:  MOVF   50,W
01848:  SUBLW  01
0184A:  BC    1856
0184C:  MOVF   50,W
0184E:  SUBLW  07
01850:  BNC   1856
....................             write_data();
01852:  CALL   0D7C
....................          delay_ms(200);
01856:  MOVLW  C8
01858:  MOVLB  1
0185A:  MOVWF  x2E
0185C:  MOVLB  0
0185E:  CALL   0354
....................          break;
01862:  BRA    18A6
.................... 
....................       case 0x03: // nut down duoc nhan
....................          timer_exit = 90;
01864:  MOVLW  5A
01866:  MOVWF  53
....................          timer_backlight = 250;
01868:  MOVLW  FA
0186A:  MOVWF  54
....................          process_down();
0186C:  GOTO   0F66
....................          if (mode >= 2 && mode <= 7)
01870:  MOVF   50,W
01872:  SUBLW  01
01874:  BC    1880
01876:  MOVF   50,W
01878:  SUBLW  07
0187A:  BNC   1880
....................             write_data();
0187C:  CALL   0D7C
....................          delay_ms(200);
01880:  MOVLW  C8
01882:  MOVLB  1
01884:  MOVWF  x2E
01886:  MOVLB  0
01888:  CALL   0354
....................          break;
0188C:  BRA    18A6
.................... 
....................       case 0x04: // nut exit duoc nhan
....................          timer_exit = 90;
0188E:  MOVLW  5A
01890:  MOVWF  53
....................          timer_backlight = 250;
01892:  MOVLW  FA
01894:  MOVWF  54
....................          process_exit();
01896:  GOTO   1040
....................          delay_ms(200);
0189A:  MOVLW  C8
0189C:  MOVLB  1
0189E:  MOVWF  x2E
018A0:  MOVLB  0
018A2:  CALL   0354
....................          break;
....................       }
.................... 
....................       // chuong trinh hien thi
....................       sum_out = 0;
018A6:  CLRF   x77
.................... 
....................       if (sum_out > sum_out_old)
018A8:  MOVF   x77,W
018AA:  SUBWF  x78,W
018AC:  BC    18B6
....................       {
....................          loop_not_display = 3;
018AE:  MOVLW  03
018B0:  MOVWF  x79
....................          timer_backlight = 250;
018B2:  MOVLW  FA
018B4:  MOVWF  54
....................       }
....................       sum_out_old = sum_out;
018B6:  MOVFF  77,78
.................... 
....................       disable_reset();
018BA:  CALL   037E
.................... 
....................       switch (loop_not_display)
018BE:  MOVF   x79,W
018C0:  XORLW  01
018C2:  BZ    18CA
018C4:  XORLW  01
018C6:  BZ    18D8
018C8:  BRA    18DC
....................       {
....................       case 1:
....................          lcd_init();
018CA:  CALL   0448
....................          loop_not_display--;
018CE:  DECF   x79,F
....................          if (mode != 0)
018D0:  MOVF   50,F
018D2:  BZ    18D6
....................             refresh_menu = 1;
018D4:  BSF    52.0
....................          break;
018D6:  BRA    18DC
....................       case 0:
....................          display_center();
018D8:  GOTO   10A0
....................          break;
....................       }
.................... 
....................       disable_reset();
018DC:  CALL   037E
018E0:  BRA    16FA
....................    }
.................... }
.................... 
018E2:  SLEEP 
.................... //=========================
.................... void init_data(void)
.................... {
....................    // con tro phuc vu cai dat
....................    *sch_1 = 0, *sch_2 = 0, val_sch_1 = 0, val_sch_2 = 0;
*
00542:  MOVFF  2A,FE9
00546:  MOVFF  2B,FEA
0054A:  CLRF   FEF
0054C:  MOVLW  00
0054E:  MOVFF  2C,FE9
00552:  MOVFF  2D,FEA
00556:  CLRF   FEF
00558:  MOVLW  00
0055A:  CLRF   2E
0055C:  CLRF   2F
....................    str_temp = "";
0055E:  CLRF   FEA
00560:  MOVLW  35
00562:  MOVWF  FE9
00564:  MOVLW  00
00566:  RCALL  00AE
00568:  TBLRD*-
0056A:  TBLRD*+
0056C:  MOVF   FF5,W
0056E:  MOVWF  FEE
00570:  IORLW  00
00572:  BNZ   056A
....................    time_reset_password = 0;
00574:  CLRF   4E
.................... 
....................    state_AC = 0;
00576:  CLRF   4F
....................    mode = 9;
00578:  MOVLW  09
0057A:  MOVWF  50
....................    state_mn = 0;
0057C:  CLRF   51
....................    refresh_menu = 0;
0057E:  BCF    52.0
.................... 
....................    timer_exit = 0;
00580:  CLRF   53
....................    timer_backlight = 240;
00582:  MOVLW  F0
00584:  MOVWF  54
.................... 
....................    val_timer_tri_hoan = timer_tri_hoan, timer_tri_hoan_md = 60;                                                // LONG DELAY 1
00586:  MOVFF  56,55
0058A:  MOVLW  3C
0058C:  MOVWF  57
....................    val_counter_restart_mpd = 1, counter_restart_mpd_current = counter_restart_mpd, counter_restart_mpd_md = 4; // LONG SO LAN KHOI DONG LAI MPD
0058E:  MOVLW  01
00590:  MOVWF  58
00592:  MOVFF  59,5B
00596:  MOVLW  04
00598:  MOVWF  5A
....................    val_timer_chay_lien_tuc = timer_chay_lien_tuc, timer_chay_lien_tuc_md = 3;                                  // LONG DELAY 2
0059A:  MOVFF  5D,5C
0059E:  MOVLW  03
005A0:  MOVWF  5E
....................    val_timer_tam_dung = timer_tam_dung, timer_tam_dung_md = 60;                                                // LONG DELAY 3
005A2:  MOVFF  60,5F
005A6:  MOVLW  3C
005A8:  MOVWF  x61
....................    val_timer_ktra_AC = timer_ktra_AC, timer_ktra_AC_md = 60;                                                   // LONG KT AC TIMER
005AA:  MOVFF  63,62
005AE:  MOVWF  x64
....................    flag_error = 0;                                                                                             // LONG FLAG = 0 la ko loi, = 1 la LOI
005B0:  CLRF   x6D
....................    flag_mn = 0;
005B2:  CLRF   x6E
....................    val_timer_ktra_mn = timer_ktra_mn, timer_ktra_mn_md = 30; // LONG KT MN TIMER
005B4:  MOVFF  66,65
005B8:  MOVLW  1E
005BA:  MOVWF  x67
....................    val_timer_on_mpd = 20, timer_on_mpd = 20;
005BC:  MOVLW  14
005BE:  MOVWF  x68
005C0:  MOVWF  x69
....................    val_timer_off_mpd = 20, timer_off_mpd = 20;
005C2:  MOVWF  x6A
005C4:  MOVWF  x6B
.................... 
....................    val_loading = 0;
005C6:  CLRF   x6C
.................... 
....................    counter_timer0 = 0, flag_timer_60s_password = 0;
005C8:  CLRF   x70
005CA:  CLRF   x6F
005CC:  CLRF   x74
....................    flag_timer_tri_hoan_60s = 0, flag_timer_chay_lien_tuc_3600s = 0, flag_timer_tam_dung_60s = 0;
005CE:  CLRF   x73
005D0:  CLRF   x72
005D2:  CLRF   x71
005D4:  CLRF   x75
.................... 
....................    pwm_lcd = 0;
005D6:  CLRF   x76
....................    sum_out = 0, sum_out_old = 0, loop_not_display = 0;
005D8:  CLRF   x77
005DA:  CLRF   x78
005DC:  CLRF   x79
005DE:  GOTO   16FA (RETURN)
.................... }
.................... char check_mn(void)
.................... {
....................    flag_mn = 1;
*
00AD8:  MOVLW  01
00ADA:  MOVWF  x6E
....................    if (status_mn())
00ADC:  BSF    F94.2
00ADE:  BTFSC  F82.2
00AE0:  BRA    0AEE
....................    {
....................       flag_mn = 0;
00AE2:  CLRF   x6E
....................       val_timer_ktra_mn = timer_ktra_mn;
00AE4:  MOVFF  66,65
....................       return 1; // do dc d.a mn
00AE8:  MOVLW  01
00AEA:  MOVWF  01
00AEC:  BRA    0B08
....................    }
....................    if (val_timer_ktra_mn <= 0)
00AEE:  MOVF   x65,F
00AF0:  BNZ   0B04
....................    {
....................       flag_mn = 0;
00AF2:  CLRF   x6E
....................       val_timer_ktra_mn = timer_ktra_mn;
00AF4:  MOVFF  66,65
....................       return status_mn(); // ket thuc delay do mn va return ket qua do
00AF8:  BSF    F94.2
00AFA:  MOVLW  00
00AFC:  BTFSS  F82.2
00AFE:  MOVLW  01
00B00:  MOVWF  01
00B02:  BRA    0B08
....................    }
....................    return 2; // dang chay delay do mn
00B04:  MOVLW  02
00B06:  MOVWF  01
00B08:  RETURN 0
.................... }
.................... void check_AC(void)
.................... {
....................    if (state_AC <= 1 && (!(status_AC())))
*
005E2:  MOVF   4F,W
005E4:  SUBLW  01
005E6:  BNC   0604
005E8:  BSF    F94.3
005EA:  BTFSS  F82.3
005EC:  BRA    0604
....................    {
....................       state_AC = 0; // chay trang thai dem do AC
005EE:  CLRF   4F
....................       if (val_timer_ktra_AC <= 0)
005F0:  MOVF   x62,F
005F2:  BNZ   0602
....................       {
....................          if (!(status_AC()))
005F4:  BSF    F94.3
005F6:  BTFSS  F82.3
005F8:  BRA    05FE
....................          {
....................             state_AC = 2;
005FA:  MOVLW  02
005FC:  MOVWF  4F
....................          }
....................          val_timer_ktra_AC = timer_ktra_AC;
005FE:  MOVFF  63,62
....................       }
....................    }
00602:  BRA    0624
....................    else if (state_AC != 1 && (status_AC()))
00604:  DECFSZ 4F,W
00606:  BRA    060A
00608:  BRA    0624
0060A:  BSF    F94.3
0060C:  BTFSC  F82.3
0060E:  BRA    0624
....................    {
....................       state_AC = 0; // chay trang thai dem do AC
00610:  CLRF   4F
....................       if (val_timer_ktra_AC <= 0)
00612:  MOVF   x62,F
00614:  BNZ   0624
....................       {
....................          if (status_AC())
00616:  BSF    F94.3
00618:  BTFSC  F82.3
0061A:  BRA    0620
....................          {
....................             state_AC = 1;
0061C:  MOVLW  01
0061E:  MOVWF  4F
....................          }
....................          val_timer_ktra_AC = timer_ktra_AC;
00620:  MOVFF  63,62
....................       }
....................    }
00624:  GOTO   1712 (RETURN)
.................... }
.................... 
.................... void display(char code_print)
.................... {
....................    switch (code_print)
*
00856:  MOVLB  1
00858:  MOVF   x28,W
0085A:  ADDLW  F8
0085C:  BTFSC  FD8.0
0085E:  BRA    0AAA
00860:  ADDLW  08
00862:  MOVLB  0
00864:  GOTO   0AAE
....................    {
....................    case 0: // ko in
....................       break;
00868:  MOVLB  1
0086A:  BRA    0AAA
....................    case 1: // delay 1
....................       LCD_PUTCMD(Line_1);
0086C:  MOVLW  80
0086E:  MOVLB  1
00870:  MOVWF  x2D
00872:  MOVLB  0
00874:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "TG TRI HOAN MPD");
00876:  MOVLW  C0
00878:  MOVWF  FF6
0087A:  MOVLW  00
0087C:  MOVWF  FF7
0087E:  RCALL  066C
....................       clear_lcd();
00880:  MOVLB  1
00882:  CLRF   x29
00884:  MOVLB  0
00886:  RCALL  06B0
....................       LCD_PUTCMD(Line_2);
00888:  MOVLW  C0
0088A:  MOVLB  1
0088C:  MOVWF  x2D
0088E:  MOVLB  0
00890:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "PHUT: %01u", val_timer_tri_hoan);
00892:  MOVLW  D0
00894:  MOVWF  FF6
00896:  MOVLW  00
00898:  MOVWF  FF7
0089A:  MOVLW  06
0089C:  MOVLB  1
0089E:  MOVWF  x29
008A0:  MOVLB  0
008A2:  RCALL  0786
008A4:  MOVFF  55,129
008A8:  MOVLW  08
008AA:  MOVLB  1
008AC:  MOVWF  x2A
008AE:  MOVLB  0
008B0:  RCALL  07DA
....................       clear_lcd();
008B2:  MOVLB  1
008B4:  CLRF   x29
008B6:  MOVLB  0
008B8:  RCALL  06B0
....................       break;
008BA:  MOVLB  1
008BC:  BRA    0AAA
....................    case 2: // delay 2
....................       LCD_PUTCMD(Line_1);
008BE:  MOVLW  80
008C0:  MOVLB  1
008C2:  MOVWF  x2D
008C4:  MOVLB  0
008C6:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "TG CHAY LIEN TUC");
008C8:  MOVLW  DC
008CA:  MOVWF  FF6
008CC:  MOVLW  00
008CE:  MOVWF  FF7
008D0:  RCALL  066C
....................       clear_lcd();
008D2:  MOVLB  1
008D4:  CLRF   x29
008D6:  MOVLB  0
008D8:  RCALL  06B0
....................       LCD_PUTCMD(Line_2);
008DA:  MOVLW  C0
008DC:  MOVLB  1
008DE:  MOVWF  x2D
008E0:  MOVLB  0
008E2:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "GIO: %01u", val_timer_chay_lien_tuc);
008E4:  MOVLW  EE
008E6:  MOVWF  FF6
008E8:  MOVLW  00
008EA:  MOVWF  FF7
008EC:  MOVLW  05
008EE:  MOVLB  1
008F0:  MOVWF  x29
008F2:  MOVLB  0
008F4:  RCALL  0786
008F6:  MOVFF  5C,129
008FA:  MOVLW  08
008FC:  MOVLB  1
008FE:  MOVWF  x2A
00900:  MOVLB  0
00902:  RCALL  07DA
....................       clear_lcd();
00904:  MOVLB  1
00906:  CLRF   x29
00908:  MOVLB  0
0090A:  RCALL  06B0
....................       break;
0090C:  MOVLB  1
0090E:  BRA    0AAA
....................    case 3: // delay 3
....................       LCD_PUTCMD(Line_1);
00910:  MOVLW  80
00912:  MOVLB  1
00914:  MOVWF  x2D
00916:  MOVLB  0
00918:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "TG TAM DUNG MPD");
0091A:  MOVLW  F8
0091C:  MOVWF  FF6
0091E:  MOVLW  00
00920:  MOVWF  FF7
00922:  RCALL  066C
....................       clear_lcd();
00924:  MOVLB  1
00926:  CLRF   x29
00928:  MOVLB  0
0092A:  RCALL  06B0
....................       LCD_PUTCMD(Line_2);
0092C:  MOVLW  C0
0092E:  MOVLB  1
00930:  MOVWF  x2D
00932:  MOVLB  0
00934:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "PHUT: %01u", val_timer_tam_dung);
00936:  MOVLW  08
00938:  MOVWF  FF6
0093A:  MOVLW  01
0093C:  MOVWF  FF7
0093E:  MOVLW  06
00940:  MOVLB  1
00942:  MOVWF  x29
00944:  MOVLB  0
00946:  RCALL  0786
00948:  MOVFF  5F,129
0094C:  MOVLW  08
0094E:  MOVLB  1
00950:  MOVWF  x2A
00952:  MOVLB  0
00954:  RCALL  07DA
....................       clear_lcd();
00956:  MOVLB  1
00958:  CLRF   x29
0095A:  MOVLB  0
0095C:  RCALL  06B0
....................       break;
0095E:  MOVLB  1
00960:  BRA    0AAA
....................    case 4: // Do AC
....................       LCD_PUTCMD(Line_1);
00962:  MOVLW  80
00964:  MOVLB  1
00966:  MOVWF  x2D
00968:  MOVLB  0
0096A:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "KIEM TRA AC");
0096C:  MOVLW  14
0096E:  MOVWF  FF6
00970:  MOVLW  01
00972:  MOVWF  FF7
00974:  RCALL  066C
....................       clear_lcd()
00976:  MOVLB  1
00978:  CLRF   x29
0097A:  MOVLB  0
0097C:  RCALL  06B0
....................           LCD_PUTCMD(Line_2);
0097E:  MOVLW  C0
00980:  MOVLB  1
00982:  MOVWF  x2D
00984:  MOVLB  0
00986:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "GIAY: %01u", val_timer_ktra_AC);
00988:  MOVLW  20
0098A:  MOVWF  FF6
0098C:  MOVLW  01
0098E:  MOVWF  FF7
00990:  MOVLW  06
00992:  MOVLB  1
00994:  MOVWF  x29
00996:  MOVLB  0
00998:  RCALL  0786
0099A:  MOVFF  62,129
0099E:  MOVLW  08
009A0:  MOVLB  1
009A2:  MOVWF  x2A
009A4:  MOVLB  0
009A6:  RCALL  07DA
....................       clear_lcd();
009A8:  MOVLB  1
009AA:  CLRF   x29
009AC:  MOVLB  0
009AE:  RCALL  06B0
....................       break;
009B0:  MOVLB  1
009B2:  BRA    0AAA
....................    case 5: // AC BINH THUONG
....................       LCD_PUTCMD(Line_1);
009B4:  MOVLW  80
009B6:  MOVLB  1
009B8:  MOVWF  x2D
009BA:  MOVLB  0
009BC:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "D.AP AC BTHUONG");
009BE:  MOVLW  2C
009C0:  MOVWF  FF6
009C2:  MOVLW  01
009C4:  MOVWF  FF7
009C6:  RCALL  066C
....................       clear_lcd();
009C8:  MOVLB  1
009CA:  CLRF   x29
009CC:  MOVLB  0
009CE:  RCALL  06B0
....................       if (flag_error)
009D0:  MOVF   x6D,F
009D2:  BZ    0A04
....................       {
....................          LCD_PUTCMD(Line_2);
009D4:  MOVLW  C0
009D6:  MOVLB  1
009D8:  MOVWF  x2D
009DA:  MOVLB  0
009DC:  RCALL  042A
....................          clear_lcd();
009DE:  MOVLB  1
009E0:  CLRF   x29
009E2:  MOVLB  0
009E4:  RCALL  06B0
....................          LCD_PUTCMD(Line_2);
009E6:  MOVLW  C0
009E8:  MOVLB  1
009EA:  MOVWF  x2D
009EC:  MOVLB  0
009EE:  RCALL  042A
....................          PRINTF(LCD_PUTCHAR, "MPD LOI");
009F0:  MOVLW  3C
009F2:  MOVWF  FF6
009F4:  MOVLW  01
009F6:  MOVWF  FF7
009F8:  RCALL  066C
....................          clear_lcd();
009FA:  MOVLB  1
009FC:  CLRF   x29
009FE:  MOVLB  0
00A00:  RCALL  06B0
....................       }
00A02:  BRA    0A20
....................       else
....................       {
....................          LCD_PUTCMD(Line_2);
00A04:  MOVLW  C0
00A06:  MOVLB  1
00A08:  MOVWF  x2D
00A0A:  MOVLB  0
00A0C:  RCALL  042A
....................          PRINTF(LCD_PUTCHAR, "MPD TOT");
00A0E:  MOVLW  44
00A10:  MOVWF  FF6
00A12:  MOVLW  01
00A14:  MOVWF  FF7
00A16:  RCALL  066C
....................          clear_lcd();
00A18:  MOVLB  1
00A1A:  CLRF   x29
00A1C:  MOVLB  0
00A1E:  RCALL  06B0
....................       }
....................       break;
00A20:  MOVLB  1
00A22:  BRA    0AAA
....................    case 6: // CHAY MPD
....................       LCD_PUTCMD(Line_1);
00A24:  MOVLW  80
00A26:  MOVLB  1
00A28:  MOVWF  x2D
00A2A:  MOVLB  0
00A2C:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "CHAY MPD");
00A2E:  MOVLW  4C
00A30:  MOVWF  FF6
00A32:  MOVLW  01
00A34:  MOVWF  FF7
00A36:  RCALL  066C
....................       clear_lcd();
00A38:  MOVLB  1
00A3A:  CLRF   x29
00A3C:  MOVLB  0
00A3E:  RCALL  06B0
....................       LCD_PUTCMD(Line_2);
00A40:  MOVLW  C0
00A42:  MOVLB  1
00A44:  MOVWF  x2D
00A46:  MOVLB  0
00A48:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "LAN: %01u", val_counter_restart_mpd);
00A4A:  MOVLW  56
00A4C:  MOVWF  FF6
00A4E:  MOVLW  01
00A50:  MOVWF  FF7
00A52:  MOVLW  05
00A54:  MOVLB  1
00A56:  MOVWF  x29
00A58:  MOVLB  0
00A5A:  RCALL  0786
00A5C:  MOVFF  58,129
00A60:  MOVLW  08
00A62:  MOVLB  1
00A64:  MOVWF  x2A
00A66:  MOVLB  0
00A68:  RCALL  07DA
....................       clear_lcd();
00A6A:  MOVLB  1
00A6C:  CLRF   x29
00A6E:  MOVLB  0
00A70:  RCALL  06B0
....................       break;
00A72:  MOVLB  1
00A74:  BRA    0AAA
....................    case 7: // error
....................       LCD_PUTCMD(Line_1);
00A76:  MOVLW  80
00A78:  MOVLB  1
00A7A:  MOVWF  x2D
00A7C:  MOVLB  0
00A7E:  RCALL  042A
....................       PRINTF(LCD_PUTCHAR, "MPD LOI");
00A80:  MOVLW  60
00A82:  MOVWF  FF6
00A84:  MOVLW  01
00A86:  MOVWF  FF7
00A88:  RCALL  066C
....................       clear_lcd();
00A8A:  MOVLB  1
00A8C:  CLRF   x29
00A8E:  MOVLB  0
00A90:  RCALL  06B0
....................       LCD_PUTCMD(Line_2);
00A92:  MOVLW  C0
00A94:  MOVLB  1
00A96:  MOVWF  x2D
00A98:  MOVLB  0
00A9A:  RCALL  042A
....................       clear_lcd();
00A9C:  MOVLB  1
00A9E:  CLRF   x29
00AA0:  MOVLB  0
00AA2:  RCALL  06B0
....................       break;
00AA4:  MOVLB  1
00AA6:  BRA    0AAA
00AA8:  MOVLB  1
....................    }
00AAA:  MOVLB  0
00AAC:  RETURN 0
.................... }
.................... 
.................... void default_data(void)
.................... {
....................    timer_tri_hoan = timer_tri_hoan_md;           // LONG DELAY 1
*
00D60:  MOVFF  57,56
....................    counter_restart_mpd = counter_restart_mpd_md; // LONG SO LAN KHOI DONG LAI MPD
00D64:  MOVFF  5A,59
....................    timer_chay_lien_tuc = timer_chay_lien_tuc_md; // LONG DELAY 2
00D68:  MOVFF  5E,5D
....................    timer_tam_dung = timer_tam_dung_md;           // LONG DELAY 3
00D6C:  MOVFF  61,60
....................    timer_ktra_AC = timer_ktra_AC_md;             // LONG KT AC TIMER
00D70:  MOVFF  64,63
....................    timer_ktra_mn = timer_ktra_mn_md;             // LONG KT MN TIMER
00D74:  MOVFF  67,66
00D78:  GOTO   0F32 (RETURN)
.................... }
.................... void display_center(void)
.................... {
.................... 
....................    unsigned char menu_main[10][17] = {{""},
....................                                       {"MAT KHAU !"},
....................                                       {"TG TRI HOAN MPD"},
....................                                       {"TG CHAY LIEN TUC"},
....................                                       {"TG TAM DUNG MPD"},
....................                                       {"TG KTRA D.AP AC"},
....................                                       {"TG KTRA D.AP MPD"},
....................                                       {"SO LAN KHOI DONG"},
....................                                       {"CAI DAT MAC DINH"},
....................                                       {""}};
*
010A0:  CLRF   x7E
010A2:  CLRF   x7F
010A4:  CLRF   x80
010A6:  CLRF   x81
010A8:  CLRF   x82
010AA:  CLRF   x83
010AC:  CLRF   x84
010AE:  CLRF   x85
010B0:  CLRF   x86
010B2:  CLRF   x87
010B4:  CLRF   x88
010B6:  CLRF   x89
010B8:  CLRF   x8A
010BA:  CLRF   x8B
010BC:  CLRF   x8C
010BE:  CLRF   x8D
010C0:  CLRF   x8E
010C2:  MOVLW  4D
010C4:  MOVWF  x8F
010C6:  MOVLW  41
010C8:  MOVWF  x90
010CA:  MOVLW  54
010CC:  MOVWF  x91
010CE:  MOVLW  20
010D0:  MOVWF  x92
010D2:  MOVLW  4B
010D4:  MOVWF  x93
010D6:  MOVLW  48
010D8:  MOVWF  x94
010DA:  MOVLW  41
010DC:  MOVWF  x95
010DE:  MOVLW  55
010E0:  MOVWF  x96
010E2:  MOVLW  20
010E4:  MOVWF  x97
010E6:  MOVLW  21
010E8:  MOVWF  x98
010EA:  CLRF   x99
010EC:  CLRF   x9A
010EE:  CLRF   x9B
010F0:  CLRF   x9C
010F2:  CLRF   x9D
010F4:  CLRF   x9E
010F6:  CLRF   x9F
010F8:  MOVLW  54
010FA:  MOVWF  xA0
010FC:  MOVLW  47
010FE:  MOVWF  xA1
01100:  MOVLW  20
01102:  MOVWF  xA2
01104:  MOVLW  54
01106:  MOVWF  xA3
01108:  MOVLW  52
0110A:  MOVWF  xA4
0110C:  MOVLW  49
0110E:  MOVWF  xA5
01110:  MOVLW  20
01112:  MOVWF  xA6
01114:  MOVLW  48
01116:  MOVWF  xA7
01118:  MOVLW  4F
0111A:  MOVWF  xA8
0111C:  MOVLW  41
0111E:  MOVWF  xA9
01120:  MOVLW  4E
01122:  MOVWF  xAA
01124:  MOVLW  20
01126:  MOVWF  xAB
01128:  MOVLW  4D
0112A:  MOVWF  xAC
0112C:  MOVLW  50
0112E:  MOVWF  xAD
01130:  MOVLW  44
01132:  MOVWF  xAE
01134:  CLRF   xAF
01136:  CLRF   xB0
01138:  MOVLW  54
0113A:  MOVWF  xB1
0113C:  MOVLW  47
0113E:  MOVWF  xB2
01140:  MOVLW  20
01142:  MOVWF  xB3
01144:  MOVLW  43
01146:  MOVWF  xB4
01148:  MOVLW  48
0114A:  MOVWF  xB5
0114C:  MOVLW  41
0114E:  MOVWF  xB6
01150:  MOVLW  59
01152:  MOVWF  xB7
01154:  MOVLW  20
01156:  MOVWF  xB8
01158:  MOVLW  4C
0115A:  MOVWF  xB9
0115C:  MOVLW  49
0115E:  MOVWF  xBA
01160:  MOVLW  45
01162:  MOVWF  xBB
01164:  MOVLW  4E
01166:  MOVWF  xBC
01168:  MOVLW  20
0116A:  MOVWF  xBD
0116C:  MOVLW  54
0116E:  MOVWF  xBE
01170:  MOVLW  55
01172:  MOVWF  xBF
01174:  MOVLW  43
01176:  MOVWF  xC0
01178:  CLRF   xC1
0117A:  MOVLW  54
0117C:  MOVWF  xC2
0117E:  MOVLW  47
01180:  MOVWF  xC3
01182:  MOVLW  20
01184:  MOVWF  xC4
01186:  MOVLW  54
01188:  MOVWF  xC5
0118A:  MOVLW  41
0118C:  MOVWF  xC6
0118E:  MOVLW  4D
01190:  MOVWF  xC7
01192:  MOVLW  20
01194:  MOVWF  xC8
01196:  MOVLW  44
01198:  MOVWF  xC9
0119A:  MOVLW  55
0119C:  MOVWF  xCA
0119E:  MOVLW  4E
011A0:  MOVWF  xCB
011A2:  MOVLW  47
011A4:  MOVWF  xCC
011A6:  MOVLW  20
011A8:  MOVWF  xCD
011AA:  MOVLW  4D
011AC:  MOVWF  xCE
011AE:  MOVLW  50
011B0:  MOVWF  xCF
011B2:  MOVLW  44
011B4:  MOVWF  xD0
011B6:  CLRF   xD1
011B8:  CLRF   xD2
011BA:  MOVLW  54
011BC:  MOVWF  xD3
011BE:  MOVLW  47
011C0:  MOVWF  xD4
011C2:  MOVLW  20
011C4:  MOVWF  xD5
011C6:  MOVLW  4B
011C8:  MOVWF  xD6
011CA:  MOVLW  54
011CC:  MOVWF  xD7
011CE:  MOVLW  52
011D0:  MOVWF  xD8
011D2:  MOVLW  41
011D4:  MOVWF  xD9
011D6:  MOVLW  20
011D8:  MOVWF  xDA
011DA:  MOVLW  44
011DC:  MOVWF  xDB
011DE:  MOVLW  2E
011E0:  MOVWF  xDC
011E2:  MOVLW  41
011E4:  MOVWF  xDD
011E6:  MOVLW  50
011E8:  MOVWF  xDE
011EA:  MOVLW  20
011EC:  MOVWF  xDF
011EE:  MOVLW  41
011F0:  MOVWF  xE0
011F2:  MOVLW  43
011F4:  MOVWF  xE1
011F6:  CLRF   xE2
011F8:  CLRF   xE3
011FA:  MOVLW  54
011FC:  MOVWF  xE4
011FE:  MOVLW  47
01200:  MOVWF  xE5
01202:  MOVLW  20
01204:  MOVWF  xE6
01206:  MOVLW  4B
01208:  MOVWF  xE7
0120A:  MOVLW  54
0120C:  MOVWF  xE8
0120E:  MOVLW  52
01210:  MOVWF  xE9
01212:  MOVLW  41
01214:  MOVWF  xEA
01216:  MOVLW  20
01218:  MOVWF  xEB
0121A:  MOVLW  44
0121C:  MOVWF  xEC
0121E:  MOVLW  2E
01220:  MOVWF  xED
01222:  MOVLW  41
01224:  MOVWF  xEE
01226:  MOVLW  50
01228:  MOVWF  xEF
0122A:  MOVLW  20
0122C:  MOVWF  xF0
0122E:  MOVLW  4D
01230:  MOVWF  xF1
01232:  MOVLW  50
01234:  MOVWF  xF2
01236:  MOVLW  44
01238:  MOVWF  xF3
0123A:  CLRF   xF4
0123C:  MOVLW  53
0123E:  MOVWF  xF5
01240:  MOVLW  4F
01242:  MOVWF  xF6
01244:  MOVLW  20
01246:  MOVWF  xF7
01248:  MOVLW  4C
0124A:  MOVWF  xF8
0124C:  MOVLW  41
0124E:  MOVWF  xF9
01250:  MOVLW  4E
01252:  MOVWF  xFA
01254:  MOVLW  20
01256:  MOVWF  xFB
01258:  MOVLW  4B
0125A:  MOVWF  xFC
0125C:  MOVLW  48
0125E:  MOVWF  xFD
01260:  MOVLW  4F
01262:  MOVWF  xFE
01264:  MOVLW  49
01266:  MOVWF  xFF
01268:  MOVLW  20
0126A:  MOVLB  1
0126C:  MOVWF  x00
0126E:  MOVLW  44
01270:  MOVWF  x01
01272:  MOVLW  4F
01274:  MOVWF  x02
01276:  MOVLW  4E
01278:  MOVWF  x03
0127A:  MOVLW  47
0127C:  MOVWF  x04
0127E:  CLRF   x05
01280:  MOVLW  43
01282:  MOVWF  x06
01284:  MOVLW  41
01286:  MOVWF  x07
01288:  MOVLW  49
0128A:  MOVWF  x08
0128C:  MOVLW  20
0128E:  MOVWF  x09
01290:  MOVLW  44
01292:  MOVWF  x0A
01294:  MOVLW  41
01296:  MOVWF  x0B
01298:  MOVLW  54
0129A:  MOVWF  x0C
0129C:  MOVLW  20
0129E:  MOVWF  x0D
012A0:  MOVLW  4D
012A2:  MOVWF  x0E
012A4:  MOVLW  41
012A6:  MOVWF  x0F
012A8:  MOVLW  43
012AA:  MOVWF  x10
012AC:  MOVLW  20
012AE:  MOVWF  x11
012B0:  MOVLW  44
012B2:  MOVWF  x12
012B4:  MOVLW  49
012B6:  MOVWF  x13
012B8:  MOVLW  4E
012BA:  MOVWF  x14
012BC:  MOVLW  48
012BE:  MOVWF  x15
012C0:  CLRF   x16
012C2:  CLRF   x17
.................... 
....................    if (refresh_menu)
012C4:  BTFSS  52.0
012C6:  BRA    1304
....................    {
....................       LCD_PUTCMD(Line_1); // Dua hien thi chu dau dong hang` duoi
012C8:  MOVLW  80
012CA:  MOVWF  x2D
012CC:  MOVLB  0
012CE:  CALL   042A
....................       PRINTF(LCD_PUTCHAR, "%s", menu_main[mode]);
012D2:  MOVF   50,W
012D4:  MULLW  11
012D6:  MOVF   FF3,W
012D8:  CLRF   03
012DA:  ADDLW  7E
012DC:  MOVWF  01
012DE:  MOVLW  00
012E0:  ADDWFC 03,F
012E2:  MOVFF  01,128
012E6:  MOVFF  03,129
012EA:  MOVFF  03,FEA
012EE:  MOVFF  01,FE9
012F2:  MOVLB  0
012F4:  CALL   068C
....................       clear_lcd();
012F8:  MOVLB  1
012FA:  CLRF   x29
012FC:  MOVLB  0
012FE:  CALL   06B0
01302:  MOVLB  1
....................    }
....................    LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
01304:  MOVLW  C0
01306:  MOVWF  x2D
01308:  MOVLB  0
0130A:  CALL   042A
.................... 
....................    switch (mode)
0130E:  MOVF   50,W
01310:  ADDLW  F6
01312:  BTFSC  FD8.0
01314:  BRA    1594
01316:  ADDLW  0A
01318:  GOTO   15CA
....................    {
....................    case 0: // LCD TINH NANG CHINH
....................       switch (state_AC)
0131C:  MOVF   4F,W
0131E:  ADDLW  F5
01320:  BC    137C
01322:  ADDLW  0B
01324:  GOTO   159A
....................       {
....................       case 0:
....................          display(do_ac);
01328:  MOVLW  04
0132A:  MOVLB  1
0132C:  MOVWF  x28
0132E:  MOVLB  0
01330:  CALL   0856
....................          break;
01334:  BRA    137C
....................       case 1:
....................          display(ac_bthg);
01336:  MOVLW  05
01338:  MOVLB  1
0133A:  MOVWF  x28
0133C:  MOVLB  0
0133E:  CALL   0856
....................          break;
01342:  BRA    137C
....................       case 2:
....................          display(tg_tri_hoan);
01344:  MOVLW  01
01346:  MOVLB  1
01348:  MOVWF  x28
0134A:  MOVLB  0
0134C:  CALL   0856
....................          break;
01350:  BRA    137C
....................       case 3:
....................          break;
01352:  BRA    137C
....................       case 4:
....................          display(tg_chay_lien_tuc);
01354:  MOVLW  02
01356:  MOVLB  1
01358:  MOVWF  x28
0135A:  MOVLB  0
0135C:  CALL   0856
....................          break;
01360:  BRA    137C
....................       case 5:
....................          display(tg_tam_dung);
01362:  MOVLW  03
01364:  MOVLB  1
01366:  MOVWF  x28
01368:  MOVLB  0
0136A:  CALL   0856
....................          break;
0136E:  BRA    137C
....................       case 10:
....................          display(error);
01370:  MOVLW  07
01372:  MOVLB  1
01374:  MOVWF  x28
01376:  MOVLB  0
01378:  CALL   0856
....................          break;
....................       }
....................       break;
0137C:  BRA    1594
....................    case 1:                // nhap mat khau
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
0137E:  MOVLW  C0
01380:  MOVLB  1
01382:  MOVWF  x2D
01384:  MOVLB  0
01386:  CALL   042A
....................       sch_1 = str_temp;
0138A:  CLRF   2B
0138C:  MOVLW  35
0138E:  MOVWF  2A
....................       sch_1_s_set();
01390:  MOVLW  0B
01392:  MOVLB  1
01394:  MOVWF  x29
01396:  MOVLB  0
01398:  CALL   06B0
....................       break;
0139C:  BRA    1594
.................... 
....................    case 2:                // TG TRI HOAN MPD
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
0139E:  MOVLW  C0
013A0:  MOVLB  1
013A2:  MOVWF  x2D
013A4:  MOVLB  0
013A6:  CALL   042A
....................       PRINTF(LCD_PUTCHAR, "PHUT: <%01u>", timer_tri_hoan);
013AA:  MOVLW  68
013AC:  MOVWF  FF6
013AE:  MOVLW  01
013B0:  MOVWF  FF7
013B2:  MOVLW  07
013B4:  MOVLB  1
013B6:  MOVWF  x29
013B8:  MOVLB  0
013BA:  CALL   0786
013BE:  MOVFF  56,129
013C2:  MOVLW  08
013C4:  MOVLB  1
013C6:  MOVWF  x2A
013C8:  MOVLB  0
013CA:  CALL   07DA
013CE:  MOVLW  3E
013D0:  MOVLB  1
013D2:  MOVWF  x2C
013D4:  MOVLB  0
013D6:  CALL   065C
....................       clear_lcd();
013DA:  MOVLB  1
013DC:  CLRF   x29
013DE:  MOVLB  0
013E0:  CALL   06B0
....................       break;
013E4:  BRA    1594
.................... 
....................    case 3:                // TG CHAY LIEN TUC
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
013E6:  MOVLW  C0
013E8:  MOVLB  1
013EA:  MOVWF  x2D
013EC:  MOVLB  0
013EE:  CALL   042A
....................       PRINTF(LCD_PUTCHAR, "GIO: <%01u>", timer_chay_lien_tuc);
013F2:  MOVLW  76
013F4:  MOVWF  FF6
013F6:  MOVLW  01
013F8:  MOVWF  FF7
013FA:  MOVLW  06
013FC:  MOVLB  1
013FE:  MOVWF  x29
01400:  MOVLB  0
01402:  CALL   0786
01406:  MOVFF  5D,129
0140A:  MOVLW  08
0140C:  MOVLB  1
0140E:  MOVWF  x2A
01410:  MOVLB  0
01412:  CALL   07DA
01416:  MOVLW  3E
01418:  MOVLB  1
0141A:  MOVWF  x2C
0141C:  MOVLB  0
0141E:  CALL   065C
....................       clear_lcd();
01422:  MOVLB  1
01424:  CLRF   x29
01426:  MOVLB  0
01428:  CALL   06B0
....................       break;
0142C:  BRA    1594
.................... 
....................    case 4:                // TG TAM DUNG MPD
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
0142E:  MOVLW  C0
01430:  MOVLB  1
01432:  MOVWF  x2D
01434:  MOVLB  0
01436:  CALL   042A
....................       PRINTF(LCD_PUTCHAR, "PHUT: <%01u>", timer_tam_dung);
0143A:  MOVLW  82
0143C:  MOVWF  FF6
0143E:  MOVLW  01
01440:  MOVWF  FF7
01442:  MOVLW  07
01444:  MOVLB  1
01446:  MOVWF  x29
01448:  MOVLB  0
0144A:  CALL   0786
0144E:  MOVFF  60,129
01452:  MOVLW  08
01454:  MOVLB  1
01456:  MOVWF  x2A
01458:  MOVLB  0
0145A:  CALL   07DA
0145E:  MOVLW  3E
01460:  MOVLB  1
01462:  MOVWF  x2C
01464:  MOVLB  0
01466:  CALL   065C
....................       clear_lcd();
0146A:  MOVLB  1
0146C:  CLRF   x29
0146E:  MOVLB  0
01470:  CALL   06B0
....................       break;
01474:  BRA    1594
....................    case 5:                // TG KTRA DA AC
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
01476:  MOVLW  C0
01478:  MOVLB  1
0147A:  MOVWF  x2D
0147C:  MOVLB  0
0147E:  CALL   042A
....................       PRINTF(LCD_PUTCHAR, "GIAY: <%01u>", timer_ktra_AC);
01482:  MOVLW  90
01484:  MOVWF  FF6
01486:  MOVLW  01
01488:  MOVWF  FF7
0148A:  MOVLW  07
0148C:  MOVLB  1
0148E:  MOVWF  x29
01490:  MOVLB  0
01492:  CALL   0786
01496:  MOVFF  63,129
0149A:  MOVLW  08
0149C:  MOVLB  1
0149E:  MOVWF  x2A
014A0:  MOVLB  0
014A2:  CALL   07DA
014A6:  MOVLW  3E
014A8:  MOVLB  1
014AA:  MOVWF  x2C
014AC:  MOVLB  0
014AE:  CALL   065C
....................       clear_lcd();
014B2:  MOVLB  1
014B4:  CLRF   x29
014B6:  MOVLB  0
014B8:  CALL   06B0
....................       break;
014BC:  BRA    1594
....................    case 6:                // TG KTRA DA MN
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
014BE:  MOVLW  C0
014C0:  MOVLB  1
014C2:  MOVWF  x2D
014C4:  MOVLB  0
014C6:  CALL   042A
....................       PRINTF(LCD_PUTCHAR, "GIAY: <%01u>", timer_ktra_mn);
014CA:  MOVLW  9E
014CC:  MOVWF  FF6
014CE:  MOVLW  01
014D0:  MOVWF  FF7
014D2:  MOVLW  07
014D4:  MOVLB  1
014D6:  MOVWF  x29
014D8:  MOVLB  0
014DA:  CALL   0786
014DE:  MOVFF  66,129
014E2:  MOVLW  08
014E4:  MOVLB  1
014E6:  MOVWF  x2A
014E8:  MOVLB  0
014EA:  CALL   07DA
014EE:  MOVLW  3E
014F0:  MOVLB  1
014F2:  MOVWF  x2C
014F4:  MOVLB  0
014F6:  CALL   065C
....................       clear_lcd();
014FA:  MOVLB  1
014FC:  CLRF   x29
014FE:  MOVLB  0
01500:  CALL   06B0
....................       break;
01504:  BRA    1594
....................    case 7:                // SO LAN KHOI DONG
....................       LCD_PUTCMD(Line_2); // Dua hien thi chu dau dong hang` duoi
01506:  MOVLW  C0
01508:  MOVLB  1
0150A:  MOVWF  x2D
0150C:  MOVLB  0
0150E:  CALL   042A
....................       PRINTF(LCD_PUTCHAR, "LAN: <%01u>", counter_restart_mpd);
01512:  MOVLW  AC
01514:  MOVWF  FF6
01516:  MOVLW  01
01518:  MOVWF  FF7
0151A:  MOVLW  06
0151C:  MOVLB  1
0151E:  MOVWF  x29
01520:  MOVLB  0
01522:  CALL   0786
01526:  MOVFF  59,129
0152A:  MOVLW  08
0152C:  MOVLB  1
0152E:  MOVWF  x2A
01530:  MOVLB  0
01532:  CALL   07DA
01536:  MOVLW  3E
01538:  MOVLB  1
0153A:  MOVWF  x2C
0153C:  MOVLB  0
0153E:  CALL   065C
....................       clear_lcd();
01542:  MOVLB  1
01544:  CLRF   x29
01546:  MOVLB  0
01548:  CALL   06B0
....................       break;
0154C:  BRA    1594
....................    case 8: // cai dat mat dinh
....................       yesno();
0154E:  MOVLW  09
01550:  MOVLB  1
01552:  MOVWF  x29
01554:  MOVLB  0
01556:  CALL   06B0
....................       break;
0155A:  BRA    1594
....................    case 9:
....................       LCD_PUTCMD(Line_1);
0155C:  MOVLW  80
0155E:  MOVLB  1
01560:  MOVWF  x2D
01562:  MOVLB  0
01564:  CALL   042A
....................       loading();
01568:  MOVLW  0A
0156A:  MOVLB  1
0156C:  MOVWF  x29
0156E:  MOVLB  0
01570:  CALL   06B0
....................       clear_lcd();
01574:  MOVLB  1
01576:  CLRF   x29
01578:  MOVLB  0
0157A:  CALL   06B0
....................       LCD_PUTCMD(Line_2);
0157E:  MOVLW  C0
01580:  MOVLB  1
01582:  MOVWF  x2D
01584:  MOVLB  0
01586:  CALL   042A
....................       clear_lcd();
0158A:  MOVLB  1
0158C:  CLRF   x29
0158E:  MOVLB  0
01590:  CALL   06B0
....................       break;
....................    }
....................    refresh_menu = 0; // cap nhat du lieu mang hinh xong
01594:  BCF    52.0
01596:  GOTO   18DC (RETURN)
.................... }
.................... 
.................... //=========================
.................... void reset_timer_data(void)
.................... {
....................    val_timer_tri_hoan = timer_tri_hoan;
*
00628:  MOVFF  56,55
....................    val_counter_restart_mpd = 1;
0062C:  MOVLW  01
0062E:  MOVWF  58
....................    counter_restart_mpd_current = counter_restart_mpd;
00630:  MOVFF  59,5B
....................    val_timer_chay_lien_tuc = timer_chay_lien_tuc;
00634:  MOVFF  5D,5C
....................    val_timer_tam_dung = timer_tam_dung;
00638:  MOVFF  60,5F
....................    val_timer_on_mpd = timer_on_mpd;
0063C:  MOVFF  69,68
....................    val_timer_off_mpd = timer_off_mpd;
00640:  MOVFF  6B,6A
....................    val_timer_ktra_mn = timer_ktra_mn;
00644:  MOVFF  66,65
....................    state_mn = 0;
00648:  CLRF   51
....................    flag_timer_tri_hoan_60s = 60, flag_timer_chay_lien_tuc_3600s = 3600, flag_timer_tam_dung_60s = 60;
0064A:  MOVLW  3C
0064C:  MOVWF  x73
0064E:  MOVLW  0E
00650:  MOVWF  x72
00652:  MOVLW  10
00654:  MOVWF  x71
00656:  MOVLW  3C
00658:  MOVWF  x75
0065A:  RETURN 0
.................... }
.................... 
.................... void lcd_printf(char code_printf)
.................... {
....................    switch (code_printf)
*
006B0:  MOVLB  1
006B2:  MOVF   x29,W
006B4:  XORLW  00
006B6:  MOVLB  0
006B8:  BZ    06C8
006BA:  XORLW  09
006BC:  BZ    06D4
006BE:  XORLW  03
006C0:  BZ    06E0
006C2:  XORLW  01
006C4:  BZ    074A
006C6:  BRA    075E
....................    {
....................    case 0:
....................       PRINTF(LCD_PUTCHAR, "                 ");
006C8:  MOVLW  B8
006CA:  MOVWF  FF6
006CC:  MOVLW  01
006CE:  MOVWF  FF7
006D0:  RCALL  066C
....................       break;
006D2:  BRA    075E
.................... 
....................    case 9:
....................       PRINTF(LCD_PUTCHAR, "  <YES || NO>");
006D4:  MOVLW  CA
006D6:  MOVWF  FF6
006D8:  MOVLW  01
006DA:  MOVWF  FF7
006DC:  RCALL  066C
....................       break;
006DE:  BRA    075E
.................... 
....................    case 10:
.................... 
....................       if (++val_loading > 5)
006E0:  INCF   x6C,F
006E2:  MOVF   x6C,W
006E4:  SUBLW  05
006E6:  BC    06EC
....................       {
....................          val_loading = 0;
006E8:  CLRF   x6C
....................          mode = 0;
006EA:  CLRF   50
....................       }
....................       PRINTF(LCD_PUTCHAR, "Loading ");
006EC:  MOVLW  D8
006EE:  MOVWF  FF6
006F0:  MOVLW  01
006F2:  MOVWF  FF7
006F4:  RCALL  066C
....................       switch (val_loading)
006F6:  MOVF   x6C,W
006F8:  ADDLW  FA
006FA:  BC    0748
006FC:  ADDLW  06
006FE:  GOTO   0760
....................       {
....................       case 0:
....................          PRINTF(LCD_PUTCHAR, ".  ");
00702:  MOVLW  E2
00704:  MOVWF  FF6
00706:  MOVLW  01
00708:  MOVWF  FF7
0070A:  RCALL  066C
....................          break;
0070C:  BRA    0748
.................... 
....................       case 1:
....................          PRINTF(LCD_PUTCHAR, ".. ");
0070E:  MOVLW  E6
00710:  MOVWF  FF6
00712:  MOVLW  01
00714:  MOVWF  FF7
00716:  RCALL  066C
....................          break;
00718:  BRA    0748
.................... 
....................       case 2:
....................          PRINTF(LCD_PUTCHAR, "...");
0071A:  MOVLW  EA
0071C:  MOVWF  FF6
0071E:  MOVLW  01
00720:  MOVWF  FF7
00722:  RCALL  066C
....................          break;
00724:  BRA    0748
.................... 
....................       case 3:
....................          PRINTF(LCD_PUTCHAR, " ..");
00726:  MOVLW  EE
00728:  MOVWF  FF6
0072A:  MOVLW  01
0072C:  MOVWF  FF7
0072E:  RCALL  066C
....................          break;
00730:  BRA    0748
.................... 
....................       case 4:
....................          PRINTF(LCD_PUTCHAR, "  .");
00732:  MOVLW  F2
00734:  MOVWF  FF6
00736:  MOVLW  01
00738:  MOVWF  FF7
0073A:  RCALL  066C
....................          break;
0073C:  BRA    0748
.................... 
....................       case 5:
....................          PRINTF(LCD_PUTCHAR, "   ");
0073E:  MOVLW  F6
00740:  MOVWF  FF6
00742:  MOVLW  01
00744:  MOVWF  FF7
00746:  RCALL  066C
....................          break;
....................       }
....................       break;
00748:  BRA    075E
.................... 
....................    case 11:
....................       PRINTF(LCD_PUTCHAR, "%s<", sch_1);
0074A:  MOVFF  2B,FEA
0074E:  MOVFF  2A,FE9
00752:  RCALL  068C
00754:  MOVLW  3C
00756:  MOVLB  1
00758:  MOVWF  x2C
0075A:  MOVLB  0
0075C:  RCALL  065C
....................       break;
....................    }
0075E:  RETURN 0
.................... }
.................... //=======================================
.................... char key_scan(void)
*
00B0A:  CLRF   x7F
00B0C:  MOVLW  C8
00B0E:  MOVWF  x7E
.................... {
....................    unsigned long bounce = 200;
.................... 
....................    if (val_mode() == 1)
00B10:  BSF    F92.3
00B12:  BTFSC  F80.3
00B14:  BRA    0B60
....................    {
....................       while (bounce--)
00B16:  MOVFF  7F,03
00B1A:  MOVF   x7E,W
00B1C:  BTFSC  FD8.2
00B1E:  DECF   x7F,F
00B20:  DECF   x7E,F
00B22:  IORWF  03,W
00B24:  BZ    0B34
....................       {
....................          if (val_mode() == 0)
00B26:  BSF    F92.3
00B28:  BTFSS  F80.3
00B2A:  BRA    0B32
....................             return 0x00;
00B2C:  MOVLW  00
00B2E:  MOVWF  01
00B30:  BRA    0C34
00B32:  BRA    0B16
....................       }
....................       bounce = 1024;
00B34:  MOVLW  04
00B36:  MOVWF  x7F
00B38:  CLRF   x7E
....................       while (bounce--)
00B3A:  MOVFF  7F,03
00B3E:  MOVF   x7E,W
00B40:  BTFSC  FD8.2
00B42:  DECF   x7F,F
00B44:  DECF   x7E,F
00B46:  IORWF  03,W
00B48:  BZ    0B58
....................       {
....................          if (val_mode() == 0)
00B4A:  BSF    F92.3
00B4C:  BTFSS  F80.3
00B4E:  BRA    0B56
....................             return 0x01;
00B50:  MOVLW  01
00B52:  MOVWF  01
00B54:  BRA    0C34
00B56:  BRA    0B3A
....................       }
....................       return 0x01;
00B58:  MOVLW  01
00B5A:  MOVWF  01
00B5C:  BRA    0C34
....................    }
00B5E:  BRA    0C30
.................... 
....................    else if (val_up() == 1)
00B60:  BSF    F92.2
00B62:  BTFSC  F80.2
00B64:  BRA    0BB0
....................    {
....................       while (bounce--)
00B66:  MOVFF  7F,03
00B6A:  MOVF   x7E,W
00B6C:  BTFSC  FD8.2
00B6E:  DECF   x7F,F
00B70:  DECF   x7E,F
00B72:  IORWF  03,W
00B74:  BZ    0B84
....................       {
....................          if (val_up() == 0)
00B76:  BSF    F92.2
00B78:  BTFSS  F80.2
00B7A:  BRA    0B82
....................             return 0x00;
00B7C:  MOVLW  00
00B7E:  MOVWF  01
00B80:  BRA    0C34
00B82:  BRA    0B66
....................       }
....................       bounce = 256;
00B84:  MOVLW  01
00B86:  MOVWF  x7F
00B88:  CLRF   x7E
....................       while (bounce--)
00B8A:  MOVFF  7F,03
00B8E:  MOVF   x7E,W
00B90:  BTFSC  FD8.2
00B92:  DECF   x7F,F
00B94:  DECF   x7E,F
00B96:  IORWF  03,W
00B98:  BZ    0BA8
....................       {
....................          if (val_up() == 0)
00B9A:  BSF    F92.2
00B9C:  BTFSS  F80.2
00B9E:  BRA    0BA6
....................             return 0x02;
00BA0:  MOVLW  02
00BA2:  MOVWF  01
00BA4:  BRA    0C34
00BA6:  BRA    0B8A
....................       }
....................       return 0x02;
00BA8:  MOVLW  02
00BAA:  MOVWF  01
00BAC:  BRA    0C34
....................    }
00BAE:  BRA    0C30
.................... 
....................    else if (val_down() == 1)
00BB0:  BSF    F92.1
00BB2:  BTFSC  F80.1
00BB4:  BRA    0C00
....................    {
....................       while (bounce--)
00BB6:  MOVFF  7F,03
00BBA:  MOVF   x7E,W
00BBC:  BTFSC  FD8.2
00BBE:  DECF   x7F,F
00BC0:  DECF   x7E,F
00BC2:  IORWF  03,W
00BC4:  BZ    0BD4
....................       {
....................          if (val_down() == 0)
00BC6:  BSF    F92.1
00BC8:  BTFSS  F80.1
00BCA:  BRA    0BD2
....................             return 0x00;
00BCC:  MOVLW  00
00BCE:  MOVWF  01
00BD0:  BRA    0C34
00BD2:  BRA    0BB6
....................       }
....................       bounce = 256;
00BD4:  MOVLW  01
00BD6:  MOVWF  x7F
00BD8:  CLRF   x7E
....................       while (bounce--)
00BDA:  MOVFF  7F,03
00BDE:  MOVF   x7E,W
00BE0:  BTFSC  FD8.2
00BE2:  DECF   x7F,F
00BE4:  DECF   x7E,F
00BE6:  IORWF  03,W
00BE8:  BZ    0BF8
....................       {
....................          if (val_down() == 0)
00BEA:  BSF    F92.1
00BEC:  BTFSS  F80.1
00BEE:  BRA    0BF6
....................             return 0x03;
00BF0:  MOVLW  03
00BF2:  MOVWF  01
00BF4:  BRA    0C34
00BF6:  BRA    0BDA
....................       }
....................       return 0x03;
00BF8:  MOVLW  03
00BFA:  MOVWF  01
00BFC:  BRA    0C34
....................    }
00BFE:  BRA    0C30
.................... 
....................    else if (val_exit() == 1)
00C00:  BSF    F92.0
00C02:  BTFSC  F80.0
00C04:  BRA    0C30
....................    {
....................       while (bounce--)
00C06:  MOVFF  7F,03
00C0A:  MOVF   x7E,W
00C0C:  BTFSC  FD8.2
00C0E:  DECF   x7F,F
00C10:  DECF   x7E,F
00C12:  IORWF  03,W
00C14:  BZ    0C24
....................       {
....................          if (val_exit() == 0)
00C16:  BSF    F92.0
00C18:  BTFSS  F80.0
00C1A:  BRA    0C22
....................             return 0x00;
00C1C:  MOVLW  00
00C1E:  MOVWF  01
00C20:  BRA    0C34
00C22:  BRA    0C06
....................       }
....................       while (val_exit() == 0)
00C24:  BSF    F92.0
00C26:  BTFSC  F80.0
00C28:  BRA    0C24
....................          ;
....................       return 0x04;
00C2A:  MOVLW  04
00C2C:  MOVWF  01
00C2E:  BRA    0C34
....................    }
....................    return 0x00;
00C30:  MOVLW  00
00C32:  MOVWF  01
00C34:  GOTO   180E (RETURN)
.................... }
.................... 
.................... //=========================
.................... void process_menu(void)
.................... {
....................    refresh_menu = 1;
*
00CE2:  BSF    52.0
....................    loop_not_display = 1;
00CE4:  MOVLW  01
00CE6:  MOVWF  x79
....................    switch (mode)
00CE8:  MOVF   50,W
00CEA:  XORLW  01
00CEC:  BZ    0CF0
00CEE:  BRA    0D44
....................    {
....................    case 1:
....................       if (strlen(str_temp) == strlen(password))
00CF0:  CLRF   x81
00CF2:  MOVLW  35
00CF4:  MOVWF  x80
00CF6:  RCALL  0C38
00CF8:  MOVFF  02,7F
00CFC:  MOVFF  01,7E
00D00:  CLRF   x81
00D02:  MOVLW  30
00D04:  MOVWF  x80
00D06:  RCALL  0C38
00D08:  MOVFF  02,03
00D0C:  MOVF   01,W
00D0E:  SUBWF  x7E,W
00D10:  BNZ   0D30
00D12:  MOVF   03,W
00D14:  SUBWF  x7F,W
00D16:  BNZ   0D30
....................       {
....................          if (strcmp(password, str_temp) == 0)
00D18:  CLRF   x7F
00D1A:  MOVLW  30
00D1C:  MOVWF  x7E
00D1E:  CLRF   x81
00D20:  MOVLW  35
00D22:  MOVWF  x80
00D24:  BRA    0C6C
00D26:  MOVF   01,F
00D28:  BNZ   0D30
....................          {
....................             mode++;
00D2A:  INCF   50,F
....................             time_reset_password = 20; // 4   phut
00D2C:  MOVLW  14
00D2E:  MOVWF  4E
....................          }
....................       }
....................       val_sch_1 = 0;
00D30:  CLRF   2E
....................       sch_1 = str_temp;
00D32:  CLRF   2B
00D34:  MOVLW  35
00D36:  MOVWF  2A
....................       *sch_1 = 0;
00D38:  MOVFF  2A,FE9
00D3C:  MOVFF  2B,FEA
00D40:  CLRF   FEF
....................       break;
00D42:  BRA    0D5C
.................... 
....................    default:
....................       if (++mode > 8)
00D44:  INCF   50,F
00D46:  MOVF   50,W
00D48:  SUBLW  08
00D4A:  BC    0D50
....................          mode = 9; // ve loading screen
00D4C:  MOVLW  09
00D4E:  MOVWF  50
....................       if (time_reset_password != 0 && mode == 1)
00D50:  MOVF   4E,F
00D52:  BZ    0D5C
00D54:  DECFSZ 50,W
00D56:  BRA    0D5C
....................          mode = 2;
00D58:  MOVLW  02
00D5A:  MOVWF  50
....................       break;
....................    }
00D5C:  GOTO   182C (RETURN)
.................... }
.................... 
.................... //=========================
.................... void process_up(void)
.................... {
....................    switch (mode)
*
00E7C:  MOVF   50,W
00E7E:  ADDLW  F7
00E80:  BC    0F36
00E82:  ADDLW  09
00E84:  GOTO   0F3A
....................    {
....................    case 0: // mang hinh chinh
....................       break;
00E88:  BRA    0F36
.................... 
....................    case 1: // nhap mat khau
....................       sch_2 = val_number_defaul;
00E8A:  CLRF   2D
00E8C:  MOVLW  1F
00E8E:  MOVWF  2C
....................       if (++val_sch_2 > 10)
00E90:  INCF   2F,F
00E92:  MOVF   2F,W
00E94:  SUBLW  0A
00E96:  BC    0E9A
....................          val_sch_2 = 0;
00E98:  CLRF   2F
....................       sch_2 = sch_2 + val_sch_2;
00E9A:  MOVF   2F,W
00E9C:  ADDWF  2C,F
00E9E:  MOVLW  00
00EA0:  ADDWFC 2D,F
....................       sch_1 = sch_1 + val_sch_1;
00EA2:  MOVF   2E,W
00EA4:  ADDWF  2A,F
00EA6:  MOVLW  00
00EA8:  ADDWFC 2B,F
....................       *sch_1++ = *sch_2;
00EAA:  MOVFF  2B,7F
00EAE:  MOVF   2A,W
00EB0:  INCF   2A,F
00EB2:  BTFSC  FD8.2
00EB4:  INCF   2B,F
00EB6:  MOVFF  2C,FE9
00EBA:  MOVFF  2D,FEA
00EBE:  MOVFF  FEF,80
00EC2:  MOVFF  7F,FEA
00EC6:  MOVWF  FE9
00EC8:  MOVFF  80,FEF
....................       *sch_1 = 0;
00ECC:  MOVFF  2A,FE9
00ED0:  MOVFF  2B,FEA
00ED4:  CLRF   FEF
....................       break;
00ED6:  BRA    0F36
.................... 
....................    case 2: // TG TRI HOAN
....................       if (++timer_tri_hoan > 254)
00ED8:  INCF   56,F
00EDA:  MOVF   56,W
00EDC:  SUBLW  FE
00EDE:  BC    0EE4
....................       {
....................          timer_tri_hoan = 1;
00EE0:  MOVLW  01
00EE2:  MOVWF  56
....................       }
....................       break;
00EE4:  BRA    0F36
....................    case 3: // TG CHAY LIEN TUC
....................       if (++timer_chay_lien_tuc > 24)
00EE6:  INCF   5D,F
00EE8:  MOVF   5D,W
00EEA:  SUBLW  18
00EEC:  BC    0EF2
....................       {
....................          timer_chay_lien_tuc = 1;
00EEE:  MOVLW  01
00EF0:  MOVWF  5D
....................       }
....................       break;
00EF2:  BRA    0F36
.................... 
....................    case 4: // TG TAM DUNG MPD
....................       if (++timer_tam_dung > 254)
00EF4:  INCF   x60,F
00EF6:  MOVF   x60,W
00EF8:  SUBLW  FE
00EFA:  BC    0F00
....................       {
....................          timer_tam_dung = 1;
00EFC:  MOVLW  01
00EFE:  MOVWF  x60
....................       }
....................       break;
00F00:  BRA    0F36
.................... 
....................    case 5: // TG KTRA DA AC
....................       if (++timer_ktra_AC > 240)
00F02:  INCF   x63,F
00F04:  MOVF   x63,W
00F06:  SUBLW  F0
00F08:  BC    0F0E
....................       {
....................          timer_ktra_AC = 10;
00F0A:  MOVLW  0A
00F0C:  MOVWF  x63
....................       }
....................       break;
00F0E:  BRA    0F36
.................... 
....................    case 6: // TG KTRA DA MN
....................       if (++timer_ktra_mn > 240)
00F10:  INCF   x66,F
00F12:  MOVF   x66,W
00F14:  SUBLW  F0
00F16:  BC    0F1C
....................       {
....................          timer_ktra_mn = 10;
00F18:  MOVLW  0A
00F1A:  MOVWF  x66
....................       }
....................       break;
00F1C:  BRA    0F36
.................... 
....................    case 7: // SO LAN KHOI DONG
....................       if (++counter_restart_mpd > 4)
00F1E:  INCF   59,F
00F20:  MOVF   59,W
00F22:  SUBLW  04
00F24:  BC    0F2A
....................       {
....................          counter_restart_mpd = 2;
00F26:  MOVLW  02
00F28:  MOVWF  59
....................       }
....................       break;
00F2A:  BRA    0F36
....................    case 8:      // cai dat mat dinh
....................       mode = 9; // ve loading screen
00F2C:  MOVLW  09
00F2E:  MOVWF  50
....................       default_data();
00F30:  BRA    0D60
....................       write_data();
00F32:  RCALL  0D7C
....................       reset_cpu();
00F34:  RESET
....................       break;
....................    }
00F36:  GOTO   1846 (RETURN)
.................... }
.................... 
.................... //=========================
.................... void process_down(void)
.................... {
....................    switch (mode)
*
00F66:  MOVF   50,W
00F68:  ADDLW  F7
00F6A:  BC    1010
00F6C:  ADDLW  09
00F6E:  GOTO   1014
....................    {
....................    case 0: // mang hinh chinh
....................       break;
00F72:  BRA    1010
.................... 
....................    case 1: // nhap mat khau
....................       sch_2 = val_number_defaul;
00F74:  CLRF   2D
00F76:  MOVLW  1F
00F78:  MOVWF  2C
....................       if (--val_sch_2 > 10)
00F7A:  DECF   2F,F
00F7C:  MOVF   2F,W
00F7E:  SUBLW  0A
00F80:  BC    0F86
....................          val_sch_2 = 10;
00F82:  MOVLW  0A
00F84:  MOVWF  2F
....................       sch_2 = sch_2 + val_sch_2;
00F86:  MOVF   2F,W
00F88:  ADDWF  2C,F
00F8A:  MOVLW  00
00F8C:  ADDWFC 2D,F
....................       sch_1 = sch_1 + val_sch_1;
00F8E:  MOVF   2E,W
00F90:  ADDWF  2A,F
00F92:  MOVLW  00
00F94:  ADDWFC 2B,F
....................       *sch_1++ = *sch_2;
00F96:  MOVFF  2B,7F
00F9A:  MOVF   2A,W
00F9C:  INCF   2A,F
00F9E:  BTFSC  FD8.2
00FA0:  INCF   2B,F
00FA2:  MOVFF  2C,FE9
00FA6:  MOVFF  2D,FEA
00FAA:  MOVFF  FEF,80
00FAE:  MOVFF  7F,FEA
00FB2:  MOVWF  FE9
00FB4:  MOVFF  80,FEF
....................       *sch_1 = 0;
00FB8:  MOVFF  2A,FE9
00FBC:  MOVFF  2B,FEA
00FC0:  CLRF   FEF
....................       break;
00FC2:  BRA    1010
.................... 
....................    case 2: // TG TRI HOAN
....................       if (--timer_tri_hoan < 1)
00FC4:  DECFSZ 56,F
00FC6:  BRA    0FCC
....................       {
....................          timer_tri_hoan = 254;
00FC8:  MOVLW  FE
00FCA:  MOVWF  56
....................       }
....................       break;
00FCC:  BRA    1010
.................... 
....................    case 3: // TG CHAY LIEN TUC
....................       if (--timer_chay_lien_tuc < 1)
00FCE:  DECFSZ 5D,F
00FD0:  BRA    0FD6
....................       {
....................          timer_chay_lien_tuc = 24;
00FD2:  MOVLW  18
00FD4:  MOVWF  5D
....................       }
....................       break;
00FD6:  BRA    1010
.................... 
....................    case 4: // TG TAM DUNG MPD
....................       if (--timer_tam_dung < 1)
00FD8:  DECFSZ x60,F
00FDA:  BRA    0FE0
....................       {
....................          timer_tam_dung = 254;
00FDC:  MOVLW  FE
00FDE:  MOVWF  x60
....................       }
....................       break;
00FE0:  BRA    1010
.................... 
....................    case 5: // TG KTRA DA AC
....................       if (--timer_ktra_AC < 10)
00FE2:  DECF   x63,F
00FE4:  MOVF   x63,W
00FE6:  SUBLW  09
00FE8:  BNC   0FEE
....................       {
....................          timer_ktra_AC = 240;
00FEA:  MOVLW  F0
00FEC:  MOVWF  x63
....................       }
....................       break;
00FEE:  BRA    1010
.................... 
....................    case 6: // TG KTRA DA MN
....................       if (--timer_ktra_mn < 10)
00FF0:  DECF   x66,F
00FF2:  MOVF   x66,W
00FF4:  SUBLW  09
00FF6:  BNC   0FFC
....................       {
....................          timer_ktra_mn = 240;
00FF8:  MOVLW  F0
00FFA:  MOVWF  x66
....................       }
....................       break;
00FFC:  BRA    1010
.................... 
....................    case 7: // SO LAN KHOI DONG
....................       if (--counter_restart_mpd < 2)
00FFE:  DECF   59,F
01000:  MOVF   59,W
01002:  SUBLW  01
01004:  BNC   100A
....................       {
....................          counter_restart_mpd = 4;
01006:  MOVLW  04
01008:  MOVWF  59
....................       }
....................       break;
0100A:  BRA    1010
....................    case 8:      // cai dat mat dinh
....................       mode = 9; // ve loading screen
0100C:  MOVLW  09
0100E:  MOVWF  50
....................       break;
....................    }
01010:  GOTO   1870 (RETURN)
.................... }
.................... 
.................... //=========================
.................... void process_exit(void)
.................... {
.................... 
....................    char val_null;
....................    val_sch_2 = 0;
*
01040:  CLRF   2F
....................    loop_not_display = 1;
01042:  MOVLW  01
01044:  MOVWF  x79
....................    switch (mode)
01046:  MOVF   50,W
01048:  BZ    1050
0104A:  XORLW  01
0104C:  BZ    1054
0104E:  BRA    109C
....................    {
....................    case 0: // mang hinh chinh
....................       time_reset_password = 0;
01050:  CLRF   4E
....................       break;
01052:  BRA    109C
.................... 
....................    case 1: // nhap mat khau
....................       sch_1 = sch_1 + val_sch_1;
01054:  MOVF   2E,W
01056:  ADDWF  2A,F
01058:  MOVLW  00
0105A:  ADDWFC 2B,F
....................       val_null = *sch_1;
0105C:  MOVFF  2A,FE9
01060:  MOVFF  2B,FEA
01064:  MOVFF  FEF,7E
....................       if (val_null != 0 && val_null != 0XFF)
01068:  MOVF   x7E,F
0106A:  BZ    109C
0106C:  INCFSZ x7E,W
0106E:  BRA    1072
01070:  BRA    109C
....................       {
....................          if (++val_sch_1 > 16)
01072:  INCF   2E,F
01074:  MOVF   2E,W
01076:  SUBLW  10
01078:  BC    107C
....................             val_sch_1 = 0;
0107A:  CLRF   2E
....................          sch_1++;
0107C:  INCF   2A,F
0107E:  BTFSC  FD8.2
01080:  INCF   2B,F
....................          *sch_1++ = 0XFF;
01082:  MOVFF  2B,FEA
01086:  MOVF   2A,W
01088:  INCF   2A,F
0108A:  BTFSC  FD8.2
0108C:  INCF   2B,F
0108E:  MOVWF  FE9
01090:  SETF   FEF
....................          *sch_1 = 0;
01092:  MOVFF  2A,FE9
01096:  MOVFF  2B,FEA
0109A:  CLRF   FEF
....................       }
....................       break;
....................    }
0109C:  GOTO   189A (RETURN)
.................... }
.................... 
.................... void write_data(void)
.................... {
....................    wee(timer_tri_hoan_ee, timer_tri_hoan);
*
00D7C:  MOVF   FF2,W
00D7E:  MOVWF  00
00D80:  BCF    FF2.7
00D82:  CLRF   FAA
00D84:  CLRF   FA9
00D86:  MOVFF  56,FA8
00D8A:  BCF    FA6.6
00D8C:  BCF    FA6.7
00D8E:  BSF    FA6.2
00D90:  MOVLB  F
00D92:  MOVLW  55
00D94:  MOVWF  FA7
00D96:  MOVLW  AA
00D98:  MOVWF  FA7
00D9A:  BSF    FA6.1
00D9C:  BTFSC  FA6.1
00D9E:  BRA    0D9C
00DA0:  BCF    FA6.2
00DA2:  MOVF   00,W
00DA4:  IORWF  FF2,F
....................    wee(timer_chay_lien_tuc_ee, timer_chay_lien_tuc);
00DA6:  MOVFF  FF2,00
00DAA:  BCF    FF2.7
00DAC:  CLRF   FAA
00DAE:  MOVLW  02
00DB0:  MOVWF  FA9
00DB2:  MOVFF  5D,FA8
00DB6:  BCF    FA6.6
00DB8:  BCF    FA6.7
00DBA:  BSF    FA6.2
00DBC:  MOVLW  55
00DBE:  MOVWF  FA7
00DC0:  MOVLW  AA
00DC2:  MOVWF  FA7
00DC4:  BSF    FA6.1
00DC6:  BTFSC  FA6.1
00DC8:  BRA    0DC6
00DCA:  BCF    FA6.2
00DCC:  MOVF   00,W
00DCE:  IORWF  FF2,F
....................    wee(timer_tam_dung_ee, timer_tam_dung);
00DD0:  MOVFF  FF2,00
00DD4:  BCF    FF2.7
00DD6:  CLRF   FAA
00DD8:  MOVLW  03
00DDA:  MOVWF  FA9
00DDC:  MOVFF  60,FA8
00DE0:  BCF    FA6.6
00DE2:  BCF    FA6.7
00DE4:  BSF    FA6.2
00DE6:  MOVLW  55
00DE8:  MOVWF  FA7
00DEA:  MOVLW  AA
00DEC:  MOVWF  FA7
00DEE:  BSF    FA6.1
00DF0:  BTFSC  FA6.1
00DF2:  BRA    0DF0
00DF4:  BCF    FA6.2
00DF6:  MOVF   00,W
00DF8:  IORWF  FF2,F
....................    wee(timer_ktra_mn_ee, timer_ktra_mn);
00DFA:  MOVFF  FF2,00
00DFE:  BCF    FF2.7
00E00:  CLRF   FAA
00E02:  MOVLW  05
00E04:  MOVWF  FA9
00E06:  MOVFF  66,FA8
00E0A:  BCF    FA6.6
00E0C:  BCF    FA6.7
00E0E:  BSF    FA6.2
00E10:  MOVLW  55
00E12:  MOVWF  FA7
00E14:  MOVLW  AA
00E16:  MOVWF  FA7
00E18:  BSF    FA6.1
00E1A:  BTFSC  FA6.1
00E1C:  BRA    0E1A
00E1E:  BCF    FA6.2
00E20:  MOVF   00,W
00E22:  IORWF  FF2,F
....................    wee(timer_ktra_AC_ee, timer_ktra_AC);
00E24:  MOVFF  FF2,00
00E28:  BCF    FF2.7
00E2A:  CLRF   FAA
00E2C:  MOVLW  04
00E2E:  MOVWF  FA9
00E30:  MOVFF  63,FA8
00E34:  BCF    FA6.6
00E36:  BCF    FA6.7
00E38:  BSF    FA6.2
00E3A:  MOVLW  55
00E3C:  MOVWF  FA7
00E3E:  MOVLW  AA
00E40:  MOVWF  FA7
00E42:  BSF    FA6.1
00E44:  BTFSC  FA6.1
00E46:  BRA    0E44
00E48:  BCF    FA6.2
00E4A:  MOVF   00,W
00E4C:  IORWF  FF2,F
....................    wee(counter_restart_mpd_ee, counter_restart_mpd);
00E4E:  MOVFF  FF2,00
00E52:  BCF    FF2.7
00E54:  CLRF   FAA
00E56:  MOVLW  01
00E58:  MOVWF  FA9
00E5A:  MOVFF  59,FA8
00E5E:  BCF    FA6.6
00E60:  BCF    FA6.7
00E62:  BSF    FA6.2
00E64:  MOVLW  55
00E66:  MOVWF  FA7
00E68:  MOVLW  AA
00E6A:  MOVWF  FA7
00E6C:  BSF    FA6.1
00E6E:  BTFSC  FA6.1
00E70:  BRA    0E6E
00E72:  BCF    FA6.2
00E74:  MOVF   00,W
00E76:  IORWF  FF2,F
00E78:  MOVLB  0
00E7A:  RETURN 0
.................... }
.................... 
.................... //=========================
.................... void read_data(void)
.................... {
....................    timer_tri_hoan = ree(timer_tri_hoan_ee);
*
004A4:  MOVFF  FF2,7E
004A8:  BCF    FF2.7
004AA:  CLRF   FAA
004AC:  CLRF   FA9
004AE:  BCF    FA6.6
004B0:  BCF    FA6.7
004B2:  BSF    FA6.0
004B4:  MOVF   FA8,W
004B6:  BTFSC  x7E.7
004B8:  BSF    FF2.7
004BA:  MOVWF  56
....................    timer_chay_lien_tuc = ree(timer_chay_lien_tuc_ee);
004BC:  MOVFF  FF2,7E
004C0:  BCF    FF2.7
004C2:  CLRF   FAA
004C4:  MOVLW  02
004C6:  MOVWF  FA9
004C8:  BCF    FA6.6
004CA:  BCF    FA6.7
004CC:  BSF    FA6.0
004CE:  MOVF   FA8,W
004D0:  BTFSC  x7E.7
004D2:  BSF    FF2.7
004D4:  MOVWF  5D
....................    timer_tam_dung = ree(timer_tam_dung_ee);
004D6:  MOVFF  FF2,7E
004DA:  BCF    FF2.7
004DC:  CLRF   FAA
004DE:  MOVLW  03
004E0:  MOVWF  FA9
004E2:  BCF    FA6.6
004E4:  BCF    FA6.7
004E6:  BSF    FA6.0
004E8:  MOVF   FA8,W
004EA:  BTFSC  x7E.7
004EC:  BSF    FF2.7
004EE:  MOVWF  x60
....................    timer_ktra_mn = ree(timer_ktra_mn_ee);
004F0:  MOVFF  FF2,7E
004F4:  BCF    FF2.7
004F6:  CLRF   FAA
004F8:  MOVLW  05
004FA:  MOVWF  FA9
004FC:  BCF    FA6.6
004FE:  BCF    FA6.7
00500:  BSF    FA6.0
00502:  MOVF   FA8,W
00504:  BTFSC  x7E.7
00506:  BSF    FF2.7
00508:  MOVWF  x66
....................    timer_ktra_AC = ree(timer_ktra_AC_ee);
0050A:  MOVFF  FF2,7E
0050E:  BCF    FF2.7
00510:  CLRF   FAA
00512:  MOVLW  04
00514:  MOVWF  FA9
00516:  BCF    FA6.6
00518:  BCF    FA6.7
0051A:  BSF    FA6.0
0051C:  MOVF   FA8,W
0051E:  BTFSC  x7E.7
00520:  BSF    FF2.7
00522:  MOVWF  x63
....................    counter_restart_mpd = ree(counter_restart_mpd_ee);
00524:  MOVFF  FF2,7E
00528:  BCF    FF2.7
0052A:  CLRF   FAA
0052C:  MOVLW  01
0052E:  MOVWF  FA9
00530:  BCF    FA6.6
00532:  BCF    FA6.7
00534:  BSF    FA6.0
00536:  MOVF   FA8,W
00538:  BTFSC  x7E.7
0053A:  BSF    FF2.7
0053C:  MOVWF  59
0053E:  GOTO   16F6 (RETURN)
.................... }
.................... 
.................... void disable_reset(void)
.................... {
....................    output_high(clock_reset);
*
0037E:  BCF    F92.3
00380:  BSF    F89.3
....................    delay_ms(1);
00382:  MOVLW  01
00384:  MOVLB  1
00386:  MOVWF  x2E
00388:  MOVLB  0
0038A:  RCALL  0354
....................    output_low(clock_reset);
0038C:  BCF    F92.3
0038E:  BCF    F89.3
....................    delay_ms(1);
00390:  MOVLW  01
00392:  MOVLB  1
00394:  MOVWF  x2E
00396:  MOVLB  0
00398:  RCALL  0354
....................    output_high(clock_reset);
0039A:  BCF    F92.3
0039C:  BSF    F89.3
....................    delay_ms(1);
0039E:  MOVLW  01
003A0:  MOVLB  1
003A2:  MOVWF  x2E
003A4:  MOVLB  0
003A6:  RCALL  0354
....................    output_low(clock_reset);
003A8:  BCF    F92.3
003AA:  BCF    F89.3
....................    delay_ms(1);
003AC:  MOVLW  01
003AE:  MOVLB  1
003B0:  MOVWF  x2E
003B2:  MOVLB  0
003B4:  RCALL  0354
....................    output_high(clock_reset);
003B6:  BCF    F92.3
003B8:  BSF    F89.3
....................    delay_ms(1);
003BA:  MOVLW  01
003BC:  MOVLB  1
003BE:  MOVWF  x2E
003C0:  MOVLB  0
003C2:  RCALL  0354
....................    output_low(clock_reset);
003C4:  BCF    F92.3
003C6:  BCF    F89.3
....................    delay_ms(1);
003C8:  MOVLW  01
003CA:  MOVLB  1
003CC:  MOVWF  x2E
003CE:  MOVLB  0
003D0:  RCALL  0354
....................    output_float(clock_reset);
003D2:  BSF    F92.3
003D4:  RETURN 0
.................... }
.................... 
.................... #int_timer0
.................... void interrupt_timer0()
.................... {
....................    clear_interrupt(INT_TIMER0);
*
001FA:  BCF    FF2.2
....................    set_timer0(62536); // 500us => 65536 - (0.0005/(4/24000000))
001FC:  MOVLW  F4
001FE:  MOVWF  FD7
00200:  MOVLW  48
00202:  MOVWF  FD6
00204:  NOP   
.................... 
....................    if (mode == 0 && state_AC == 1) // DIMMER LCD
00206:  MOVF   50,F
00208:  BNZ   023A
0020A:  DECFSZ 4F,W
0020C:  BRA    023A
....................    {
....................       switch (pwm_lcd)
0020E:  MOVF   x76,W
00210:  BZ    021C
00212:  XORLW  01
00214:  BZ    0222
00216:  XORLW  06
00218:  BZ    022E
0021A:  BRA    0238
....................       {
....................       case 0:
....................          backligh_on();
0021C:  BCF    F92.4
0021E:  BSF    F89.4
....................          break;
00220:  BRA    0238
.................... 
....................       case 1:
....................          if (timer_backlight < 30)
00222:  MOVF   54,W
00224:  SUBLW  1D
00226:  BNC   022C
....................             backligh_off();
00228:  BCF    F92.4
0022A:  BCF    F89.4
....................          break;
0022C:  BRA    0238
.................... 
....................       case 7:
....................          if (timer_backlight < 120)
0022E:  MOVF   54,W
00230:  SUBLW  77
00232:  BNC   0238
....................             backligh_off();
00234:  BCF    F92.4
00236:  BCF    F89.4
....................          break;
....................       }
....................    }
00238:  BRA    023E
....................    else
....................    {
....................       backligh_on();
0023A:  BCF    F92.4
0023C:  BSF    F89.4
....................    }
....................    if (++pwm_lcd > 10)
0023E:  INCF   x76,F
00240:  MOVF   x76,W
00242:  SUBLW  0A
00244:  BC    0248
....................       pwm_lcd = 0;
00246:  CLRF   x76
.................... 
....................    if (++counter_timer0 > 500)
00248:  INCF   x6F,F
0024A:  BTFSC  FD8.2
0024C:  INCF   x70,F
0024E:  MOVF   x70,W
00250:  SUBLW  00
00252:  BTFSC  FD8.0
00254:  BRA    0326
00256:  XORLW  FF
00258:  BNZ   0262
0025A:  MOVF   x6F,W
0025C:  SUBLW  F4
0025E:  BTFSC  FD8.0
00260:  BRA    0326
....................    { // timer 1s
....................       counter_timer0 = 0;
00262:  CLRF   x70
00264:  CLRF   x6F
....................       DISABLE_INTERRUPTS(INT_TIMER0);
00266:  BCF    FF2.5
.................... 
....................       switch (mode)
00268:  MOVF   50,W
0026A:  BZ    026E
0026C:  BRA    02FE
....................       {
....................       case 0: // TINH NANG CHINH
....................          if (flag_mn == 1 && val_timer_ktra_mn > 0)
0026E:  DECFSZ x6E,W
00270:  BRA    0278
00272:  MOVF   x65,F
00274:  BZ    0278
....................          {
....................             val_timer_ktra_mn--;
00276:  DECF   x65,F
....................          }
....................          switch (state_AC)
00278:  MOVF   4F,W
0027A:  ADDLW  FA
0027C:  BC    02FC
0027E:  ADDLW  06
00280:  GOTO   032E
....................          {
....................          case 0: // TIMER DEM DO AC
....................             if (val_timer_ktra_AC > 0)
00284:  MOVF   x62,F
00286:  BZ    028A
....................                val_timer_ktra_AC--;
00288:  DECF   x62,F
....................             break;
0028A:  BRA    02FC
....................          case 1:
....................             break;
0028C:  BRA    02FC
....................          case 2: // TIMER TRI HOAN
....................             if (--flag_timer_tri_hoan_60s > 59)
0028E:  DECF   x73,F
00290:  MOVF   x73,W
00292:  SUBLW  3B
00294:  BC    02A0
....................             {
....................                flag_timer_tri_hoan_60s = 59;
00296:  MOVLW  3B
00298:  MOVWF  x73
....................                if (val_timer_tri_hoan > 0)
0029A:  MOVF   55,F
0029C:  BZ    02A0
....................                   val_timer_tri_hoan--;
0029E:  DECF   55,F
....................             }
....................             break;
002A0:  BRA    02FC
....................          case 3:
....................             switch (state_mn)
002A2:  MOVF   51,W
002A4:  BZ    02B0
002A6:  XORLW  01
002A8:  BZ    02B8
002AA:  XORLW  03
002AC:  BZ    02BA
002AE:  BRA    02C0
....................             {
....................             case 0:
....................                if (val_timer_on_mpd > 0)
002B0:  MOVF   x68,F
002B2:  BZ    02B6
....................                {
....................                   val_timer_on_mpd--;
002B4:  DECF   x68,F
....................                }
....................                break;
002B6:  BRA    02C0
....................             case 1:
....................                break;
002B8:  BRA    02C0
....................             case 2:
....................                if (val_timer_off_mpd > 0)
002BA:  MOVF   x6A,F
002BC:  BZ    02C0
....................                {
....................                   val_timer_off_mpd--;
002BE:  DECF   x6A,F
....................                }
....................                break;
....................             }
....................             break;
002C0:  BRA    02FC
....................          case 4:
....................             if (--flag_timer_chay_lien_tuc_3600s > 3599)
002C2:  MOVF   x71,W
002C4:  BTFSC  FD8.2
002C6:  DECF   x72,F
002C8:  DECF   x71,F
002CA:  MOVF   x72,W
002CC:  SUBLW  0D
002CE:  BC    02E8
002D0:  XORLW  FF
002D2:  BNZ   02DA
002D4:  MOVF   x71,W
002D6:  SUBLW  0F
002D8:  BC    02E8
....................             {
....................                flag_timer_chay_lien_tuc_3600s = 3599;
002DA:  MOVLW  0E
002DC:  MOVWF  x72
002DE:  MOVLW  0F
002E0:  MOVWF  x71
....................                if (val_timer_chay_lien_tuc > 0)
002E2:  MOVF   5C,F
002E4:  BZ    02E8
....................                   val_timer_chay_lien_tuc--;
002E6:  DECF   5C,F
....................             }
....................             break;
002E8:  BRA    02FC
....................          case 5:
....................             if (--flag_timer_tam_dung_60s > 59)
002EA:  DECF   x75,F
002EC:  MOVF   x75,W
002EE:  SUBLW  3B
002F0:  BC    02FC
....................             {
....................                flag_timer_tam_dung_60s = 59;
002F2:  MOVLW  3B
002F4:  MOVWF  x75
....................                if (val_timer_tam_dung > 0)
002F6:  MOVF   5F,F
002F8:  BZ    02FC
....................                   val_timer_tam_dung--;
002FA:  DECF   5F,F
....................             }
....................             break;
....................          }
....................          break;
002FC:  BRA    02FE
....................       }
....................       // TRO VE MANG HINH CHINH KHI KHONG NHAN NUT
....................       if (timer_exit != 0)
002FE:  MOVF   53,F
00300:  BZ    0304
....................          timer_exit--;
00302:  DECF   53,F
....................       if (timer_exit == 0)
00304:  MOVF   53,F
00306:  BNZ   030A
....................       {
....................          mode = 0; // ve loading screen
00308:  CLRF   50
....................       }
.................... 
....................       // DEN LCD
....................       if (timer_backlight != 0)
0030A:  MOVF   54,F
0030C:  BZ    0310
....................          timer_backlight--;
0030E:  DECF   54,F
.................... 
....................       // timer 1 phut
....................       if (--flag_timer_60s_password > 59)
00310:  DECF   x74,F
00312:  MOVF   x74,W
00314:  SUBLW  3B
00316:  BC    0326
....................       {
....................          flag_timer_60s_password = 59;
00318:  MOVLW  3B
0031A:  MOVWF  x74
....................          loop_not_display = 1;
0031C:  MOVLW  01
0031E:  MOVWF  x79
....................          if (time_reset_password != 0)
00320:  MOVF   4E,F
00322:  BZ    0326
....................             time_reset_password--;
00324:  DECF   4E,F
.................... 
....................          // nhan nut up mot luc reset ve mat dinh
....................       }
....................    }
....................    enable_interrupts(INT_TIMER0);
00326:  BSF    FF2.5
00328:  BCF    FF2.2
0032A:  GOTO   0060
.................... }

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1D0F   NOPUT BROWNOUT BORV27 WDT WDT16384
   Word  3: 8F00   CCP2C1 PBADEN LPT1OSC HFOFST MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: 8000   PROTECT CPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
